
/**
 * Client
**/

import * as runtime from './runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = {
  id: string
  firstName: string
  lastName: string | null
  username: string
  photoUrl: string | null
  email: string
  isActif: boolean
  isMember: boolean
  isAdmin: boolean
  emailIsVerified: boolean
  twoAuthIsActive: boolean
  phone: string | null
  gender: EnumGender | null
  birthDate: Date | null
  password: string
  socketId: string | null
  refreshToken: string | null
  supportingDocumentUrl: string | null
  isValideSupportingDocument: boolean
  registrationBonus: number | null
  latestConnectedDate: Date | null
  signInCount: number | null
  lotCount: number | null
  createdAt: Date | null
  updatedAt: Date | null
  ruleId: string | null
  stripeCustomerId: string | null
}

/**
 * Model Patronage
 * 
 */
export type Patronage = {
  id: string
  gainPercentage: number | null
  discountPercentage: number | null
  status: EnumStatusPatronage | null
  bonusEndDate: Date | null
  userParentId: string
  userChildId: string
  bonusCollect: boolean | null
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model CodeConfirmLogin
 * 
 */
export type CodeConfirmLogin = {
  id: string
  uuid: string
  useId: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model CodeConfirmMail
 * 
 */
export type CodeConfirmMail = {
  id: string
  uuid: string
  useId: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model TokenBlackList
 * 
 */
export type TokenBlackList = {
  id: string
  token: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Rule
 * 
 */
export type Rule = {
  id: string
  name: string
  keyword: string
  permissionIDs: string[]
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Permission
 * 
 */
export type Permission = {
  id: string
  name: EnumPermission
  keyword: string
  rulesIDs: string[]
  modelsIDs: string[]
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Model
 * 
 */
export type Model = {
  id: string
  name: string
  keyword: string
  permissionIDs: string[]
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Address
 * 
 */
export type Address = {
  id: string
  firstAdress: string
  secondAdress: string | null
  zipCode: string
  city: string
  region: string
  country: string
  additionnalInformation: string | null
  userId: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Wallet
 * 
 */
export type Wallet = {
  id: string
  balance: number
  userId: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model BoxType
 * 
 */
export type BoxType = {
  id: string
  reference: string
  name: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Box
 * 
 */
export type Box = {
  id: string
  reference: string
  name: string
  price: number
  number: number
  description: string
  badge: EnumBadgeBox | null
  boxTypeId: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model DailyReward
 * 
 */
export type DailyReward = {
  id: string
  number: number
  boxId: string
}

/**
 * Model BoxRewardLevel
 * 
 */
export type BoxRewardLevel = {
  id: string
  boxId: string
  rewardLevelId: string
}

/**
 * Model RewardLevel
 * 
 */
export type RewardLevel = {
  id: string
  orderNumber: number
  name: string
  unlockThreshold: number
  description: string | null
}

/**
 * Model BoxImage
 * 
 */
export type BoxImage = {
  id: string
  photoUrl: string
  status: EnumBoxImageStatus
  boxId: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Provider
 * 
 */
export type Provider = {
  id: string
  reference: string
  companyName: string
  address: string | null
  phone: string | null
  webSite: string | null
  logo: string | null
  isPinned: boolean | null
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Category
 * 
 */
export type Category = {
  id: string
  reference: string
  name: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model SubCategory
 * 
 */
export type SubCategory = {
  id: string
  reference: string
  name: string
  categoryId: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model UnitySize
 * 
 */
export type UnitySize = {
  id: string
  name: string
  abbreviation: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Article
 * 
 */
export type Article = {
  id: string
  reference: string
  designation: string
  type: EnumTypeMode | null
  size: string | null
  color: string | null
  productUrl: string | null
  observation: string | null
  winningChance: number | null
  providerId: string | null
  unitySizeId: string | null
  subCategoryId: string
  boxId: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model BoxArticle
 * 
 */
export type BoxArticle = {
  id: string
  winningChance: number
  boxId: string
  articleId: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model ArticlePhoto
 * 
 */
export type ArticlePhoto = {
  id: string
  photoUrl: string
  status: ArticlePhotoStatus | null
  articleId: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Post
 * 
 */
export type Post = {
  id: string
  title: string
  content: string
  postUrl: string
  articleId: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Price
 * 
 */
export type Price = {
  id: string
  reference: string | null
  currentPrice: number
  oldPrice: number | null
  rate: number | null
  reduction: number | null
  sellingPrice: number | null
  articleId: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Order
 * 
 */
export type Order = {
  id: string
  status: EnumOrderStatus
  followedLink: string | null
  orderNumber: string | null
  shoppingCartId: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model ShoppingCart
 * 
 */
export type ShoppingCart = {
  id: string
  winningDate: Date
  isClaimed: boolean | null
  gameId: string
  userId: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Transaction
 * 
 */
export type Transaction = {
  id: string
  type: EnumTypeTransaction
  date: Date
  amount: number
  status: EnumStatusTransaction
  boxId: string | null
  walletId: string
  offerId: string | null
  shoppingCartId: string | null
  bankId: string | null
  gameId: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Bank
 * 
 */
export type Bank = {
  id: string
  accountNumber: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model UserBox
 * 
 */
export type UserBox = {
  id: string
  type: EnumUserBoxType
  duration: Date | null
  dayNumber: number | null
  isPlayed: boolean | null
  isLocked: boolean | null
  playedDate: Date | null
  activationDate: Date | null
  deactivationDate: Date | null
  orderNumber: number | null
  name: string | null
  unlockThreshold: number | null
  description: string | null
  userId: string
  boxId: string
  lot: number | null
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model BannerImage
 * 
 */
export type BannerImage = {
  id: string
  bannerImgUrl: string
  bannerLink: string | null
  type: BannerImageType | null
  boxId: string | null
  offerId: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model BoxParams
 * 
 */
export type BoxParams = {
  id: string
  isBestSelling: boolean
  isRecommended: boolean
  isNew: boolean
  isBigPrice: boolean
  isSubsciptionBonus: boolean
  boxId: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Historical
 * 
 */
export type Historical = {
  id: string
  date: Date
  description: string
  userId: string
  action: EnumHistoricalAction
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Message
 * 
 */
export type Message = {
  id: string
  message: string
  sendingDate: Date
  senderId: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Receiver
 * 
 */
export type Receiver = {
  id: string
  readingDate: Date
  receiverId: string
  messageId: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model NewsLetter
 * 
 */
export type NewsLetter = {
  id: string
  email: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Temoignage
 * 
 */
export type Temoignage = {
  id: string
  comment: string
  rating: number
  commentDate: Date
  isToShow: boolean
  userId: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Offer
 * 
 */
export type Offer = {
  id: string
  name: string
  price: number
  priceThreeMonth: number | null
  color: string | null
  numberMysteryBoxBronze: number
  numberMysteryBoxSylver: number
  numberMysteryBoxGold: number
  isAwardLevelActive: boolean
  isWeeklyAwardActive: boolean
  isStandardSupportActive: boolean
  isVIPSupportActive: boolean
  duration: number | null
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Subscription
 * 
 */
export type Subscription = {
  id: string
  startDate: Date
  endDate: Date
  durationType: EnumPriceSubscription | null
  status: EnumStatusSubscription | null
  autoRenewal: boolean
  userId: string
  offerId: string
  createdAt: Date | null
  updatedAt: Date | null
}

/**
 * Model Game
 * 
 */
export type Game = {
  id: string
  reference: string
  startDate: Date
  endDate: Date | null
  status: EnumStatusGame
  version: EnumVersionGame | null
  type: EnumTypeGame | null
  userBoxId: string | null
  patronageId: string | null
  gainPercentage: number | null
  gainDraw: number | null
  articleId: string | null
  createdAt: Date | null
  updatedAt: Date | null
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const ArticlePhotoStatus: {
  FIRST: 'FIRST',
  SECOND: 'SECOND',
  THIRD: 'THIRD',
  LAST: 'LAST'
};

export type ArticlePhotoStatus = (typeof ArticlePhotoStatus)[keyof typeof ArticlePhotoStatus]


export const BannerImageType: {
  WELCOME: 'WELCOME',
  SUBSCRIPTION: 'SUBSCRIPTION',
  SPONSORSHIP: 'SPONSORSHIP',
  ADVERTISEMENT: 'ADVERTISEMENT'
};

export type BannerImageType = (typeof BannerImageType)[keyof typeof BannerImageType]


export const EnumBadgeBox: {
  TENDANCE: 'TENDANCE',
  SOLDE: 'SOLDE'
};

export type EnumBadgeBox = (typeof EnumBadgeBox)[keyof typeof EnumBadgeBox]


export const EnumBoxImageStatus: {
  CLOSED: 'CLOSED',
  OPENED: 'OPENED',
  PLAYING: 'PLAYING',
  OTHER: 'OTHER'
};

export type EnumBoxImageStatus = (typeof EnumBoxImageStatus)[keyof typeof EnumBoxImageStatus]


export const EnumGender: {
  MAN: 'MAN',
  WOMAN: 'WOMAN'
};

export type EnumGender = (typeof EnumGender)[keyof typeof EnumGender]


export const EnumHistoricalAction: {
  READ: 'READ',
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE'
};

export type EnumHistoricalAction = (typeof EnumHistoricalAction)[keyof typeof EnumHistoricalAction]


export const EnumOrderStatus: {
  PENDING: 'PENDING',
  INPROGRESS: 'INPROGRESS',
  ONDELIVERY: 'ONDELIVERY',
  DELIVERED: 'DELIVERED'
};

export type EnumOrderStatus = (typeof EnumOrderStatus)[keyof typeof EnumOrderStatus]


export const EnumPermission: {
  READ: 'READ',
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE'
};

export type EnumPermission = (typeof EnumPermission)[keyof typeof EnumPermission]


export const EnumPriceSubscription: {
  ONEMONTH: 'ONEMONTH',
  THREEMONTHS: 'THREEMONTHS'
};

export type EnumPriceSubscription = (typeof EnumPriceSubscription)[keyof typeof EnumPriceSubscription]


export const EnumStatusGame: {
  RUNNING: 'RUNNING',
  FINISHED: 'FINISHED',
  ERROR: 'ERROR'
};

export type EnumStatusGame = (typeof EnumStatusGame)[keyof typeof EnumStatusGame]


export const EnumStatusPatronage: {
  APPROVED: 'APPROVED',
  PENDING: 'PENDING',
  END: 'END'
};

export type EnumStatusPatronage = (typeof EnumStatusPatronage)[keyof typeof EnumStatusPatronage]


export const EnumStatusSubscription: {
  INACTIVE: 'INACTIVE',
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  CANCELED: 'CANCELED'
};

export type EnumStatusSubscription = (typeof EnumStatusSubscription)[keyof typeof EnumStatusSubscription]


export const EnumStatusTransaction: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  CANCELED: 'CANCELED'
};

export type EnumStatusTransaction = (typeof EnumStatusTransaction)[keyof typeof EnumStatusTransaction]


export const EnumTypeGame: {
  BOX: 'BOX',
  SPONSORED: 'SPONSORED',
  PARENT: 'PARENT'
};

export type EnumTypeGame = (typeof EnumTypeGame)[keyof typeof EnumTypeGame]


export const EnumTypeMode: {
  MAN: 'MAN',
  WOMAN: 'WOMAN',
  CHILD: 'CHILD'
};

export type EnumTypeMode = (typeof EnumTypeMode)[keyof typeof EnumTypeMode]


export const EnumTypeTransaction: {
  DEPOSIT: 'DEPOSIT',
  EXCHANGE: 'EXCHANGE',
  WITHDRAWAL: 'WITHDRAWAL',
  PURCHASE: 'PURCHASE',
  SUBSCRIBE: 'SUBSCRIBE',
  BONUS: 'BONUS'
};

export type EnumTypeTransaction = (typeof EnumTypeTransaction)[keyof typeof EnumTypeTransaction]


export const EnumUserBoxType: {
  PURCHASE: 'PURCHASE',
  REWARD_LEVEL: 'REWARD_LEVEL',
  DAILY_REWARD: 'DAILY_REWARD'
};

export type EnumUserBoxType = (typeof EnumUserBoxType)[keyof typeof EnumUserBoxType]


export const EnumVersionGame: {
  FULL: 'FULL',
  DEMO: 'DEMO'
};

export type EnumVersionGame = (typeof EnumVersionGame)[keyof typeof EnumVersionGame]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number }): Promise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.patronage`: Exposes CRUD operations for the **Patronage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patronages
    * const patronages = await prisma.patronage.findMany()
    * ```
    */
  get patronage(): Prisma.PatronageDelegate<GlobalReject>;

  /**
   * `prisma.codeConfirmLogin`: Exposes CRUD operations for the **CodeConfirmLogin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodeConfirmLogins
    * const codeConfirmLogins = await prisma.codeConfirmLogin.findMany()
    * ```
    */
  get codeConfirmLogin(): Prisma.CodeConfirmLoginDelegate<GlobalReject>;

  /**
   * `prisma.codeConfirmMail`: Exposes CRUD operations for the **CodeConfirmMail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CodeConfirmMails
    * const codeConfirmMails = await prisma.codeConfirmMail.findMany()
    * ```
    */
  get codeConfirmMail(): Prisma.CodeConfirmMailDelegate<GlobalReject>;

  /**
   * `prisma.tokenBlackList`: Exposes CRUD operations for the **TokenBlackList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TokenBlackLists
    * const tokenBlackLists = await prisma.tokenBlackList.findMany()
    * ```
    */
  get tokenBlackList(): Prisma.TokenBlackListDelegate<GlobalReject>;

  /**
   * `prisma.rule`: Exposes CRUD operations for the **Rule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rules
    * const rules = await prisma.rule.findMany()
    * ```
    */
  get rule(): Prisma.RuleDelegate<GlobalReject>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<GlobalReject>;

  /**
   * `prisma.model`: Exposes CRUD operations for the **Model** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Models
    * const models = await prisma.model.findMany()
    * ```
    */
  get model(): Prisma.ModelDelegate<GlobalReject>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<GlobalReject>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **Wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.WalletDelegate<GlobalReject>;

  /**
   * `prisma.boxType`: Exposes CRUD operations for the **BoxType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoxTypes
    * const boxTypes = await prisma.boxType.findMany()
    * ```
    */
  get boxType(): Prisma.BoxTypeDelegate<GlobalReject>;

  /**
   * `prisma.box`: Exposes CRUD operations for the **Box** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Boxes
    * const boxes = await prisma.box.findMany()
    * ```
    */
  get box(): Prisma.BoxDelegate<GlobalReject>;

  /**
   * `prisma.dailyReward`: Exposes CRUD operations for the **DailyReward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyRewards
    * const dailyRewards = await prisma.dailyReward.findMany()
    * ```
    */
  get dailyReward(): Prisma.DailyRewardDelegate<GlobalReject>;

  /**
   * `prisma.boxRewardLevel`: Exposes CRUD operations for the **BoxRewardLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoxRewardLevels
    * const boxRewardLevels = await prisma.boxRewardLevel.findMany()
    * ```
    */
  get boxRewardLevel(): Prisma.BoxRewardLevelDelegate<GlobalReject>;

  /**
   * `prisma.rewardLevel`: Exposes CRUD operations for the **RewardLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RewardLevels
    * const rewardLevels = await prisma.rewardLevel.findMany()
    * ```
    */
  get rewardLevel(): Prisma.RewardLevelDelegate<GlobalReject>;

  /**
   * `prisma.boxImage`: Exposes CRUD operations for the **BoxImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoxImages
    * const boxImages = await prisma.boxImage.findMany()
    * ```
    */
  get boxImage(): Prisma.BoxImageDelegate<GlobalReject>;

  /**
   * `prisma.provider`: Exposes CRUD operations for the **Provider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Providers
    * const providers = await prisma.provider.findMany()
    * ```
    */
  get provider(): Prisma.ProviderDelegate<GlobalReject>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<GlobalReject>;

  /**
   * `prisma.subCategory`: Exposes CRUD operations for the **SubCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubCategories
    * const subCategories = await prisma.subCategory.findMany()
    * ```
    */
  get subCategory(): Prisma.SubCategoryDelegate<GlobalReject>;

  /**
   * `prisma.unitySize`: Exposes CRUD operations for the **UnitySize** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UnitySizes
    * const unitySizes = await prisma.unitySize.findMany()
    * ```
    */
  get unitySize(): Prisma.UnitySizeDelegate<GlobalReject>;

  /**
   * `prisma.article`: Exposes CRUD operations for the **Article** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Articles
    * const articles = await prisma.article.findMany()
    * ```
    */
  get article(): Prisma.ArticleDelegate<GlobalReject>;

  /**
   * `prisma.boxArticle`: Exposes CRUD operations for the **BoxArticle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoxArticles
    * const boxArticles = await prisma.boxArticle.findMany()
    * ```
    */
  get boxArticle(): Prisma.BoxArticleDelegate<GlobalReject>;

  /**
   * `prisma.articlePhoto`: Exposes CRUD operations for the **ArticlePhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArticlePhotos
    * const articlePhotos = await prisma.articlePhoto.findMany()
    * ```
    */
  get articlePhoto(): Prisma.ArticlePhotoDelegate<GlobalReject>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<GlobalReject>;

  /**
   * `prisma.price`: Exposes CRUD operations for the **Price** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prices
    * const prices = await prisma.price.findMany()
    * ```
    */
  get price(): Prisma.PriceDelegate<GlobalReject>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<GlobalReject>;

  /**
   * `prisma.shoppingCart`: Exposes CRUD operations for the **ShoppingCart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShoppingCarts
    * const shoppingCarts = await prisma.shoppingCart.findMany()
    * ```
    */
  get shoppingCart(): Prisma.ShoppingCartDelegate<GlobalReject>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<GlobalReject>;

  /**
   * `prisma.bank`: Exposes CRUD operations for the **Bank** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banks
    * const banks = await prisma.bank.findMany()
    * ```
    */
  get bank(): Prisma.BankDelegate<GlobalReject>;

  /**
   * `prisma.userBox`: Exposes CRUD operations for the **UserBox** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBoxes
    * const userBoxes = await prisma.userBox.findMany()
    * ```
    */
  get userBox(): Prisma.UserBoxDelegate<GlobalReject>;

  /**
   * `prisma.bannerImage`: Exposes CRUD operations for the **BannerImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BannerImages
    * const bannerImages = await prisma.bannerImage.findMany()
    * ```
    */
  get bannerImage(): Prisma.BannerImageDelegate<GlobalReject>;

  /**
   * `prisma.boxParams`: Exposes CRUD operations for the **BoxParams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoxParams
    * const boxParams = await prisma.boxParams.findMany()
    * ```
    */
  get boxParams(): Prisma.BoxParamsDelegate<GlobalReject>;

  /**
   * `prisma.historical`: Exposes CRUD operations for the **Historical** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Historicals
    * const historicals = await prisma.historical.findMany()
    * ```
    */
  get historical(): Prisma.HistoricalDelegate<GlobalReject>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<GlobalReject>;

  /**
   * `prisma.receiver`: Exposes CRUD operations for the **Receiver** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Receivers
    * const receivers = await prisma.receiver.findMany()
    * ```
    */
  get receiver(): Prisma.ReceiverDelegate<GlobalReject>;

  /**
   * `prisma.newsLetter`: Exposes CRUD operations for the **NewsLetter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NewsLetters
    * const newsLetters = await prisma.newsLetter.findMany()
    * ```
    */
  get newsLetter(): Prisma.NewsLetterDelegate<GlobalReject>;

  /**
   * `prisma.temoignage`: Exposes CRUD operations for the **Temoignage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Temoignages
    * const temoignages = await prisma.temoignage.findMany()
    * ```
    */
  get temoignage(): Prisma.TemoignageDelegate<GlobalReject>;

  /**
   * `prisma.offer`: Exposes CRUD operations for the **Offer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offers
    * const offers = await prisma.offer.findMany()
    * ```
    */
  get offer(): Prisma.OfferDelegate<GlobalReject>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<GlobalReject>;

  /**
   * `prisma.game`: Exposes CRUD operations for the **Game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.game.findMany()
    * ```
    */
  get game(): Prisma.GameDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.14.1
   * Query Engine version: d9a4c5988f480fa576d43970d5a23641aa77bc9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Patronage: 'Patronage',
    CodeConfirmLogin: 'CodeConfirmLogin',
    CodeConfirmMail: 'CodeConfirmMail',
    TokenBlackList: 'TokenBlackList',
    Rule: 'Rule',
    Permission: 'Permission',
    Model: 'Model',
    Address: 'Address',
    Wallet: 'Wallet',
    BoxType: 'BoxType',
    Box: 'Box',
    DailyReward: 'DailyReward',
    BoxRewardLevel: 'BoxRewardLevel',
    RewardLevel: 'RewardLevel',
    BoxImage: 'BoxImage',
    Provider: 'Provider',
    Category: 'Category',
    SubCategory: 'SubCategory',
    UnitySize: 'UnitySize',
    Article: 'Article',
    BoxArticle: 'BoxArticle',
    ArticlePhoto: 'ArticlePhoto',
    Post: 'Post',
    Price: 'Price',
    Order: 'Order',
    ShoppingCart: 'ShoppingCart',
    Transaction: 'Transaction',
    Bank: 'Bank',
    UserBox: 'UserBox',
    BannerImage: 'BannerImage',
    BoxParams: 'BoxParams',
    Historical: 'Historical',
    Message: 'Message',
    Receiver: 'Receiver',
    NewsLetter: 'NewsLetter',
    Temoignage: 'Temoignage',
    Offer: 'Offer',
    Subscription: 'Subscription',
    Game: 'Game'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    codeConfirmLogin: number
    codeConfirmMail: number
    shoppingCart: number
    userBox: number
    historical: number
    message: number
    receiver: number
    temoignage: number
    subscription: number
    patronage: number
  }

  export type UserCountOutputTypeSelect = {
    codeConfirmLogin?: boolean
    codeConfirmMail?: boolean
    shoppingCart?: boolean
    userBox?: boolean
    historical?: boolean
    message?: boolean
    receiver?: boolean
    temoignage?: boolean
    subscription?: boolean
    patronage?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type PatronageCountOutputType
   */


  export type PatronageCountOutputType = {
    game: number
  }

  export type PatronageCountOutputTypeSelect = {
    game?: boolean
  }

  export type PatronageCountOutputTypeGetPayload<S extends boolean | null | undefined | PatronageCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PatronageCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PatronageCountOutputTypeArgs)
    ? PatronageCountOutputType 
    : S extends { select: any } & (PatronageCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PatronageCountOutputType ? PatronageCountOutputType[P] : never
  } 
      : PatronageCountOutputType




  // Custom InputTypes

  /**
   * PatronageCountOutputType without action
   */
  export type PatronageCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PatronageCountOutputType
     */
    select?: PatronageCountOutputTypeSelect | null
  }



  /**
   * Count Type RuleCountOutputType
   */


  export type RuleCountOutputType = {
    user: number
    permissions: number
  }

  export type RuleCountOutputTypeSelect = {
    user?: boolean
    permissions?: boolean
  }

  export type RuleCountOutputTypeGetPayload<S extends boolean | null | undefined | RuleCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RuleCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RuleCountOutputTypeArgs)
    ? RuleCountOutputType 
    : S extends { select: any } & (RuleCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RuleCountOutputType ? RuleCountOutputType[P] : never
  } 
      : RuleCountOutputType




  // Custom InputTypes

  /**
   * RuleCountOutputType without action
   */
  export type RuleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RuleCountOutputType
     */
    select?: RuleCountOutputTypeSelect | null
  }



  /**
   * Count Type PermissionCountOutputType
   */


  export type PermissionCountOutputType = {
    rules: number
    models: number
  }

  export type PermissionCountOutputTypeSelect = {
    rules?: boolean
    models?: boolean
  }

  export type PermissionCountOutputTypeGetPayload<S extends boolean | null | undefined | PermissionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PermissionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PermissionCountOutputTypeArgs)
    ? PermissionCountOutputType 
    : S extends { select: any } & (PermissionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PermissionCountOutputType ? PermissionCountOutputType[P] : never
  } 
      : PermissionCountOutputType




  // Custom InputTypes

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect | null
  }



  /**
   * Count Type ModelCountOutputType
   */


  export type ModelCountOutputType = {
    permissions: number
  }

  export type ModelCountOutputTypeSelect = {
    permissions?: boolean
  }

  export type ModelCountOutputTypeGetPayload<S extends boolean | null | undefined | ModelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ModelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ModelCountOutputTypeArgs)
    ? ModelCountOutputType 
    : S extends { select: any } & (ModelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ModelCountOutputType ? ModelCountOutputType[P] : never
  } 
      : ModelCountOutputType




  // Custom InputTypes

  /**
   * ModelCountOutputType without action
   */
  export type ModelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ModelCountOutputType
     */
    select?: ModelCountOutputTypeSelect | null
  }



  /**
   * Count Type WalletCountOutputType
   */


  export type WalletCountOutputType = {
    transaction: number
  }

  export type WalletCountOutputTypeSelect = {
    transaction?: boolean
  }

  export type WalletCountOutputTypeGetPayload<S extends boolean | null | undefined | WalletCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WalletCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (WalletCountOutputTypeArgs)
    ? WalletCountOutputType 
    : S extends { select: any } & (WalletCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WalletCountOutputType ? WalletCountOutputType[P] : never
  } 
      : WalletCountOutputType




  // Custom InputTypes

  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WalletCountOutputType
     */
    select?: WalletCountOutputTypeSelect | null
  }



  /**
   * Count Type BoxTypeCountOutputType
   */


  export type BoxTypeCountOutputType = {
    box: number
  }

  export type BoxTypeCountOutputTypeSelect = {
    box?: boolean
  }

  export type BoxTypeCountOutputTypeGetPayload<S extends boolean | null | undefined | BoxTypeCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BoxTypeCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BoxTypeCountOutputTypeArgs)
    ? BoxTypeCountOutputType 
    : S extends { select: any } & (BoxTypeCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BoxTypeCountOutputType ? BoxTypeCountOutputType[P] : never
  } 
      : BoxTypeCountOutputType




  // Custom InputTypes

  /**
   * BoxTypeCountOutputType without action
   */
  export type BoxTypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BoxTypeCountOutputType
     */
    select?: BoxTypeCountOutputTypeSelect | null
  }



  /**
   * Count Type BoxCountOutputType
   */


  export type BoxCountOutputType = {
    boxImage: number
    article: number
    transaction: number
    userBox: number
    bannerImage: number
    boxArticle: number
    dailyReward: number
    boxRewardLevel: number
  }

  export type BoxCountOutputTypeSelect = {
    boxImage?: boolean
    article?: boolean
    transaction?: boolean
    userBox?: boolean
    bannerImage?: boolean
    boxArticle?: boolean
    dailyReward?: boolean
    boxRewardLevel?: boolean
  }

  export type BoxCountOutputTypeGetPayload<S extends boolean | null | undefined | BoxCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BoxCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BoxCountOutputTypeArgs)
    ? BoxCountOutputType 
    : S extends { select: any } & (BoxCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BoxCountOutputType ? BoxCountOutputType[P] : never
  } 
      : BoxCountOutputType




  // Custom InputTypes

  /**
   * BoxCountOutputType without action
   */
  export type BoxCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BoxCountOutputType
     */
    select?: BoxCountOutputTypeSelect | null
  }



  /**
   * Count Type RewardLevelCountOutputType
   */


  export type RewardLevelCountOutputType = {
    boxRewardLevel: number
  }

  export type RewardLevelCountOutputTypeSelect = {
    boxRewardLevel?: boolean
  }

  export type RewardLevelCountOutputTypeGetPayload<S extends boolean | null | undefined | RewardLevelCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RewardLevelCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RewardLevelCountOutputTypeArgs)
    ? RewardLevelCountOutputType 
    : S extends { select: any } & (RewardLevelCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RewardLevelCountOutputType ? RewardLevelCountOutputType[P] : never
  } 
      : RewardLevelCountOutputType




  // Custom InputTypes

  /**
   * RewardLevelCountOutputType without action
   */
  export type RewardLevelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RewardLevelCountOutputType
     */
    select?: RewardLevelCountOutputTypeSelect | null
  }



  /**
   * Count Type ProviderCountOutputType
   */


  export type ProviderCountOutputType = {
    article: number
  }

  export type ProviderCountOutputTypeSelect = {
    article?: boolean
  }

  export type ProviderCountOutputTypeGetPayload<S extends boolean | null | undefined | ProviderCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ProviderCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ProviderCountOutputTypeArgs)
    ? ProviderCountOutputType 
    : S extends { select: any } & (ProviderCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ProviderCountOutputType ? ProviderCountOutputType[P] : never
  } 
      : ProviderCountOutputType




  // Custom InputTypes

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProviderCountOutputType
     */
    select?: ProviderCountOutputTypeSelect | null
  }



  /**
   * Count Type CategoryCountOutputType
   */


  export type CategoryCountOutputType = {
    subCategory: number
  }

  export type CategoryCountOutputTypeSelect = {
    subCategory?: boolean
  }

  export type CategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | CategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CategoryCountOutputTypeArgs)
    ? CategoryCountOutputType 
    : S extends { select: any } & (CategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CategoryCountOutputType ? CategoryCountOutputType[P] : never
  } 
      : CategoryCountOutputType




  // Custom InputTypes

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type SubCategoryCountOutputType
   */


  export type SubCategoryCountOutputType = {
    article: number
  }

  export type SubCategoryCountOutputTypeSelect = {
    article?: boolean
  }

  export type SubCategoryCountOutputTypeGetPayload<S extends boolean | null | undefined | SubCategoryCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SubCategoryCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SubCategoryCountOutputTypeArgs)
    ? SubCategoryCountOutputType 
    : S extends { select: any } & (SubCategoryCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SubCategoryCountOutputType ? SubCategoryCountOutputType[P] : never
  } 
      : SubCategoryCountOutputType




  // Custom InputTypes

  /**
   * SubCategoryCountOutputType without action
   */
  export type SubCategoryCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SubCategoryCountOutputType
     */
    select?: SubCategoryCountOutputTypeSelect | null
  }



  /**
   * Count Type UnitySizeCountOutputType
   */


  export type UnitySizeCountOutputType = {
    article: number
  }

  export type UnitySizeCountOutputTypeSelect = {
    article?: boolean
  }

  export type UnitySizeCountOutputTypeGetPayload<S extends boolean | null | undefined | UnitySizeCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UnitySizeCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UnitySizeCountOutputTypeArgs)
    ? UnitySizeCountOutputType 
    : S extends { select: any } & (UnitySizeCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UnitySizeCountOutputType ? UnitySizeCountOutputType[P] : never
  } 
      : UnitySizeCountOutputType




  // Custom InputTypes

  /**
   * UnitySizeCountOutputType without action
   */
  export type UnitySizeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UnitySizeCountOutputType
     */
    select?: UnitySizeCountOutputTypeSelect | null
  }



  /**
   * Count Type ArticleCountOutputType
   */


  export type ArticleCountOutputType = {
    articlePhoto: number
    post: number
    boxArticle: number
    game: number
  }

  export type ArticleCountOutputTypeSelect = {
    articlePhoto?: boolean
    post?: boolean
    boxArticle?: boolean
    game?: boolean
  }

  export type ArticleCountOutputTypeGetPayload<S extends boolean | null | undefined | ArticleCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ArticleCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ArticleCountOutputTypeArgs)
    ? ArticleCountOutputType 
    : S extends { select: any } & (ArticleCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ArticleCountOutputType ? ArticleCountOutputType[P] : never
  } 
      : ArticleCountOutputType




  // Custom InputTypes

  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ArticleCountOutputType
     */
    select?: ArticleCountOutputTypeSelect | null
  }



  /**
   * Count Type ShoppingCartCountOutputType
   */


  export type ShoppingCartCountOutputType = {
    transaction: number
  }

  export type ShoppingCartCountOutputTypeSelect = {
    transaction?: boolean
  }

  export type ShoppingCartCountOutputTypeGetPayload<S extends boolean | null | undefined | ShoppingCartCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ShoppingCartCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ShoppingCartCountOutputTypeArgs)
    ? ShoppingCartCountOutputType 
    : S extends { select: any } & (ShoppingCartCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ShoppingCartCountOutputType ? ShoppingCartCountOutputType[P] : never
  } 
      : ShoppingCartCountOutputType




  // Custom InputTypes

  /**
   * ShoppingCartCountOutputType without action
   */
  export type ShoppingCartCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCartCountOutputType
     */
    select?: ShoppingCartCountOutputTypeSelect | null
  }



  /**
   * Count Type BankCountOutputType
   */


  export type BankCountOutputType = {
    transaction: number
  }

  export type BankCountOutputTypeSelect = {
    transaction?: boolean
  }

  export type BankCountOutputTypeGetPayload<S extends boolean | null | undefined | BankCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BankCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BankCountOutputTypeArgs)
    ? BankCountOutputType 
    : S extends { select: any } & (BankCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof BankCountOutputType ? BankCountOutputType[P] : never
  } 
      : BankCountOutputType




  // Custom InputTypes

  /**
   * BankCountOutputType without action
   */
  export type BankCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BankCountOutputType
     */
    select?: BankCountOutputTypeSelect | null
  }



  /**
   * Count Type UserBoxCountOutputType
   */


  export type UserBoxCountOutputType = {
    game: number
  }

  export type UserBoxCountOutputTypeSelect = {
    game?: boolean
  }

  export type UserBoxCountOutputTypeGetPayload<S extends boolean | null | undefined | UserBoxCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserBoxCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserBoxCountOutputTypeArgs)
    ? UserBoxCountOutputType 
    : S extends { select: any } & (UserBoxCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserBoxCountOutputType ? UserBoxCountOutputType[P] : never
  } 
      : UserBoxCountOutputType




  // Custom InputTypes

  /**
   * UserBoxCountOutputType without action
   */
  export type UserBoxCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserBoxCountOutputType
     */
    select?: UserBoxCountOutputTypeSelect | null
  }



  /**
   * Count Type MessageCountOutputType
   */


  export type MessageCountOutputType = {
    receiver: number
  }

  export type MessageCountOutputTypeSelect = {
    receiver?: boolean
  }

  export type MessageCountOutputTypeGetPayload<S extends boolean | null | undefined | MessageCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MessageCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MessageCountOutputTypeArgs)
    ? MessageCountOutputType 
    : S extends { select: any } & (MessageCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MessageCountOutputType ? MessageCountOutputType[P] : never
  } 
      : MessageCountOutputType




  // Custom InputTypes

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect | null
  }



  /**
   * Count Type OfferCountOutputType
   */


  export type OfferCountOutputType = {
    subscription: number
    bannerImage: number
    transaction: number
  }

  export type OfferCountOutputTypeSelect = {
    subscription?: boolean
    bannerImage?: boolean
    transaction?: boolean
  }

  export type OfferCountOutputTypeGetPayload<S extends boolean | null | undefined | OfferCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OfferCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (OfferCountOutputTypeArgs)
    ? OfferCountOutputType 
    : S extends { select: any } & (OfferCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof OfferCountOutputType ? OfferCountOutputType[P] : never
  } 
      : OfferCountOutputType




  // Custom InputTypes

  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OfferCountOutputType
     */
    select?: OfferCountOutputTypeSelect | null
  }



  /**
   * Count Type GameCountOutputType
   */


  export type GameCountOutputType = {
    transaction: number
  }

  export type GameCountOutputTypeSelect = {
    transaction?: boolean
  }

  export type GameCountOutputTypeGetPayload<S extends boolean | null | undefined | GameCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? GameCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (GameCountOutputTypeArgs)
    ? GameCountOutputType 
    : S extends { select: any } & (GameCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof GameCountOutputType ? GameCountOutputType[P] : never
  } 
      : GameCountOutputType




  // Custom InputTypes

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the GameCountOutputType
     */
    select?: GameCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    registrationBonus: number | null
    signInCount: number | null
    lotCount: number | null
  }

  export type UserSumAggregateOutputType = {
    registrationBonus: number | null
    signInCount: number | null
    lotCount: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    username: string | null
    photoUrl: string | null
    email: string | null
    isActif: boolean | null
    isMember: boolean | null
    isAdmin: boolean | null
    emailIsVerified: boolean | null
    twoAuthIsActive: boolean | null
    phone: string | null
    gender: EnumGender | null
    birthDate: Date | null
    password: string | null
    socketId: string | null
    refreshToken: string | null
    supportingDocumentUrl: string | null
    isValideSupportingDocument: boolean | null
    registrationBonus: number | null
    latestConnectedDate: Date | null
    signInCount: number | null
    lotCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    ruleId: string | null
    stripeCustomerId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    username: string | null
    photoUrl: string | null
    email: string | null
    isActif: boolean | null
    isMember: boolean | null
    isAdmin: boolean | null
    emailIsVerified: boolean | null
    twoAuthIsActive: boolean | null
    phone: string | null
    gender: EnumGender | null
    birthDate: Date | null
    password: string | null
    socketId: string | null
    refreshToken: string | null
    supportingDocumentUrl: string | null
    isValideSupportingDocument: boolean | null
    registrationBonus: number | null
    latestConnectedDate: Date | null
    signInCount: number | null
    lotCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    ruleId: string | null
    stripeCustomerId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    username: number
    photoUrl: number
    email: number
    isActif: number
    isMember: number
    isAdmin: number
    emailIsVerified: number
    twoAuthIsActive: number
    phone: number
    gender: number
    birthDate: number
    password: number
    socketId: number
    refreshToken: number
    supportingDocumentUrl: number
    isValideSupportingDocument: number
    registrationBonus: number
    latestConnectedDate: number
    signInCount: number
    lotCount: number
    createdAt: number
    updatedAt: number
    ruleId: number
    stripeCustomerId: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    registrationBonus?: true
    signInCount?: true
    lotCount?: true
  }

  export type UserSumAggregateInputType = {
    registrationBonus?: true
    signInCount?: true
    lotCount?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    username?: true
    photoUrl?: true
    email?: true
    isActif?: true
    isMember?: true
    isAdmin?: true
    emailIsVerified?: true
    twoAuthIsActive?: true
    phone?: true
    gender?: true
    birthDate?: true
    password?: true
    socketId?: true
    refreshToken?: true
    supportingDocumentUrl?: true
    isValideSupportingDocument?: true
    registrationBonus?: true
    latestConnectedDate?: true
    signInCount?: true
    lotCount?: true
    createdAt?: true
    updatedAt?: true
    ruleId?: true
    stripeCustomerId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    username?: true
    photoUrl?: true
    email?: true
    isActif?: true
    isMember?: true
    isAdmin?: true
    emailIsVerified?: true
    twoAuthIsActive?: true
    phone?: true
    gender?: true
    birthDate?: true
    password?: true
    socketId?: true
    refreshToken?: true
    supportingDocumentUrl?: true
    isValideSupportingDocument?: true
    registrationBonus?: true
    latestConnectedDate?: true
    signInCount?: true
    lotCount?: true
    createdAt?: true
    updatedAt?: true
    ruleId?: true
    stripeCustomerId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    username?: true
    photoUrl?: true
    email?: true
    isActif?: true
    isMember?: true
    isAdmin?: true
    emailIsVerified?: true
    twoAuthIsActive?: true
    phone?: true
    gender?: true
    birthDate?: true
    password?: true
    socketId?: true
    refreshToken?: true
    supportingDocumentUrl?: true
    isValideSupportingDocument?: true
    registrationBonus?: true
    latestConnectedDate?: true
    signInCount?: true
    lotCount?: true
    createdAt?: true
    updatedAt?: true
    ruleId?: true
    stripeCustomerId?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    firstName: string
    lastName: string | null
    username: string
    photoUrl: string | null
    email: string
    isActif: boolean
    isMember: boolean
    isAdmin: boolean
    emailIsVerified: boolean
    twoAuthIsActive: boolean
    phone: string | null
    gender: EnumGender | null
    birthDate: Date | null
    password: string
    socketId: string | null
    refreshToken: string | null
    supportingDocumentUrl: string | null
    isValideSupportingDocument: boolean
    registrationBonus: number | null
    latestConnectedDate: Date | null
    signInCount: number | null
    lotCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    ruleId: string | null
    stripeCustomerId: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    photoUrl?: boolean
    email?: boolean
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: boolean
    gender?: boolean
    birthDate?: boolean
    password?: boolean
    socketId?: boolean
    refreshToken?: boolean
    supportingDocumentUrl?: boolean
    isValideSupportingDocument?: boolean
    registrationBonus?: boolean
    latestConnectedDate?: boolean
    signInCount?: boolean
    lotCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ruleId?: boolean
    stripeCustomerId?: boolean
    rule?: boolean | RuleArgs
    address?: boolean | AddressArgs
    codeConfirmLogin?: boolean | User$codeConfirmLoginArgs
    codeConfirmMail?: boolean | User$codeConfirmMailArgs
    wallet?: boolean | WalletArgs
    shoppingCart?: boolean | User$shoppingCartArgs
    userBox?: boolean | User$userBoxArgs
    historical?: boolean | User$historicalArgs
    message?: boolean | User$messageArgs
    receiver?: boolean | User$receiverArgs
    temoignage?: boolean | User$temoignageArgs
    subscription?: boolean | User$subscriptionArgs
    patronage?: boolean | User$patronageArgs
    userChild?: boolean | PatronageArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    rule?: boolean | RuleArgs
    address?: boolean | AddressArgs
    codeConfirmLogin?: boolean | User$codeConfirmLoginArgs
    codeConfirmMail?: boolean | User$codeConfirmMailArgs
    wallet?: boolean | WalletArgs
    shoppingCart?: boolean | User$shoppingCartArgs
    userBox?: boolean | User$userBoxArgs
    historical?: boolean | User$historicalArgs
    message?: boolean | User$messageArgs
    receiver?: boolean | User$receiverArgs
    temoignage?: boolean | User$temoignageArgs
    subscription?: boolean | User$subscriptionArgs
    patronage?: boolean | User$patronageArgs
    userChild?: boolean | PatronageArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'rule' ? RuleGetPayload<S['include'][P]> | null :
        P extends 'address' ? AddressGetPayload<S['include'][P]> | null :
        P extends 'codeConfirmLogin' ? Array < CodeConfirmLoginGetPayload<S['include'][P]>>  :
        P extends 'codeConfirmMail' ? Array < CodeConfirmMailGetPayload<S['include'][P]>>  :
        P extends 'wallet' ? WalletGetPayload<S['include'][P]> | null :
        P extends 'shoppingCart' ? Array < ShoppingCartGetPayload<S['include'][P]>>  :
        P extends 'userBox' ? Array < UserBoxGetPayload<S['include'][P]>>  :
        P extends 'historical' ? Array < HistoricalGetPayload<S['include'][P]>>  :
        P extends 'message' ? Array < MessageGetPayload<S['include'][P]>>  :
        P extends 'receiver' ? Array < ReceiverGetPayload<S['include'][P]>>  :
        P extends 'temoignage' ? Array < TemoignageGetPayload<S['include'][P]>>  :
        P extends 'subscription' ? Array < SubscriptionGetPayload<S['include'][P]>>  :
        P extends 'patronage' ? Array < PatronageGetPayload<S['include'][P]>>  :
        P extends 'userChild' ? PatronageGetPayload<S['include'][P]> | null :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'rule' ? RuleGetPayload<S['select'][P]> | null :
        P extends 'address' ? AddressGetPayload<S['select'][P]> | null :
        P extends 'codeConfirmLogin' ? Array < CodeConfirmLoginGetPayload<S['select'][P]>>  :
        P extends 'codeConfirmMail' ? Array < CodeConfirmMailGetPayload<S['select'][P]>>  :
        P extends 'wallet' ? WalletGetPayload<S['select'][P]> | null :
        P extends 'shoppingCart' ? Array < ShoppingCartGetPayload<S['select'][P]>>  :
        P extends 'userBox' ? Array < UserBoxGetPayload<S['select'][P]>>  :
        P extends 'historical' ? Array < HistoricalGetPayload<S['select'][P]>>  :
        P extends 'message' ? Array < MessageGetPayload<S['select'][P]>>  :
        P extends 'receiver' ? Array < ReceiverGetPayload<S['select'][P]>>  :
        P extends 'temoignage' ? Array < TemoignageGetPayload<S['select'][P]>>  :
        P extends 'subscription' ? Array < SubscriptionGetPayload<S['select'][P]>>  :
        P extends 'patronage' ? Array < PatronageGetPayload<S['select'][P]>>  :
        P extends 'userChild' ? PatronageGetPayload<S['select'][P]> | null :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: UserFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: UserAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    rule<T extends RuleArgs= {}>(args?: Subset<T, RuleArgs>): Prisma__RuleClient<RuleGetPayload<T> | Null>;

    address<T extends AddressArgs= {}>(args?: Subset<T, AddressArgs>): Prisma__AddressClient<AddressGetPayload<T> | Null>;

    codeConfirmLogin<T extends User$codeConfirmLoginArgs= {}>(args?: Subset<T, User$codeConfirmLoginArgs>): Prisma.PrismaPromise<Array<CodeConfirmLoginGetPayload<T>>| Null>;

    codeConfirmMail<T extends User$codeConfirmMailArgs= {}>(args?: Subset<T, User$codeConfirmMailArgs>): Prisma.PrismaPromise<Array<CodeConfirmMailGetPayload<T>>| Null>;

    wallet<T extends WalletArgs= {}>(args?: Subset<T, WalletArgs>): Prisma__WalletClient<WalletGetPayload<T> | Null>;

    shoppingCart<T extends User$shoppingCartArgs= {}>(args?: Subset<T, User$shoppingCartArgs>): Prisma.PrismaPromise<Array<ShoppingCartGetPayload<T>>| Null>;

    userBox<T extends User$userBoxArgs= {}>(args?: Subset<T, User$userBoxArgs>): Prisma.PrismaPromise<Array<UserBoxGetPayload<T>>| Null>;

    historical<T extends User$historicalArgs= {}>(args?: Subset<T, User$historicalArgs>): Prisma.PrismaPromise<Array<HistoricalGetPayload<T>>| Null>;

    message<T extends User$messageArgs= {}>(args?: Subset<T, User$messageArgs>): Prisma.PrismaPromise<Array<MessageGetPayload<T>>| Null>;

    receiver<T extends User$receiverArgs= {}>(args?: Subset<T, User$receiverArgs>): Prisma.PrismaPromise<Array<ReceiverGetPayload<T>>| Null>;

    temoignage<T extends User$temoignageArgs= {}>(args?: Subset<T, User$temoignageArgs>): Prisma.PrismaPromise<Array<TemoignageGetPayload<T>>| Null>;

    subscription<T extends User$subscriptionArgs= {}>(args?: Subset<T, User$subscriptionArgs>): Prisma.PrismaPromise<Array<SubscriptionGetPayload<T>>| Null>;

    patronage<T extends User$patronageArgs= {}>(args?: Subset<T, User$patronageArgs>): Prisma.PrismaPromise<Array<PatronageGetPayload<T>>| Null>;

    userChild<T extends PatronageArgs= {}>(args?: Subset<T, PatronageArgs>): Prisma__PatronageClient<PatronageGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User findRaw
   */
  export type UserFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * User.codeConfirmLogin
   */
  export type User$codeConfirmLoginArgs = {
    /**
     * Select specific fields to fetch from the CodeConfirmLogin
     */
    select?: CodeConfirmLoginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmLoginInclude | null
    where?: CodeConfirmLoginWhereInput
    orderBy?: Enumerable<CodeConfirmLoginOrderByWithRelationInput>
    cursor?: CodeConfirmLoginWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CodeConfirmLoginScalarFieldEnum>
  }


  /**
   * User.codeConfirmMail
   */
  export type User$codeConfirmMailArgs = {
    /**
     * Select specific fields to fetch from the CodeConfirmMail
     */
    select?: CodeConfirmMailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmMailInclude | null
    where?: CodeConfirmMailWhereInput
    orderBy?: Enumerable<CodeConfirmMailOrderByWithRelationInput>
    cursor?: CodeConfirmMailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CodeConfirmMailScalarFieldEnum>
  }


  /**
   * User.shoppingCart
   */
  export type User$shoppingCartArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoppingCartInclude | null
    where?: ShoppingCartWhereInput
    orderBy?: Enumerable<ShoppingCartOrderByWithRelationInput>
    cursor?: ShoppingCartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ShoppingCartScalarFieldEnum>
  }


  /**
   * User.userBox
   */
  export type User$userBoxArgs = {
    /**
     * Select specific fields to fetch from the UserBox
     */
    select?: UserBoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBoxInclude | null
    where?: UserBoxWhereInput
    orderBy?: Enumerable<UserBoxOrderByWithRelationInput>
    cursor?: UserBoxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserBoxScalarFieldEnum>
  }


  /**
   * User.historical
   */
  export type User$historicalArgs = {
    /**
     * Select specific fields to fetch from the Historical
     */
    select?: HistoricalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoricalInclude | null
    where?: HistoricalWhereInput
    orderBy?: Enumerable<HistoricalOrderByWithRelationInput>
    cursor?: HistoricalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HistoricalScalarFieldEnum>
  }


  /**
   * User.message
   */
  export type User$messageArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    where?: MessageWhereInput
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * User.receiver
   */
  export type User$receiverArgs = {
    /**
     * Select specific fields to fetch from the Receiver
     */
    select?: ReceiverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiverInclude | null
    where?: ReceiverWhereInput
    orderBy?: Enumerable<ReceiverOrderByWithRelationInput>
    cursor?: ReceiverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReceiverScalarFieldEnum>
  }


  /**
   * User.temoignage
   */
  export type User$temoignageArgs = {
    /**
     * Select specific fields to fetch from the Temoignage
     */
    select?: TemoignageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemoignageInclude | null
    where?: TemoignageWhereInput
    orderBy?: Enumerable<TemoignageOrderByWithRelationInput>
    cursor?: TemoignageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TemoignageScalarFieldEnum>
  }


  /**
   * User.subscription
   */
  export type User$subscriptionArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
    where?: SubscriptionWhereInput
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SubscriptionScalarFieldEnum>
  }


  /**
   * User.patronage
   */
  export type User$patronageArgs = {
    /**
     * Select specific fields to fetch from the Patronage
     */
    select?: PatronageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatronageInclude | null
    where?: PatronageWhereInput
    orderBy?: Enumerable<PatronageOrderByWithRelationInput>
    cursor?: PatronageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PatronageScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model Patronage
   */


  export type AggregatePatronage = {
    _count: PatronageCountAggregateOutputType | null
    _avg: PatronageAvgAggregateOutputType | null
    _sum: PatronageSumAggregateOutputType | null
    _min: PatronageMinAggregateOutputType | null
    _max: PatronageMaxAggregateOutputType | null
  }

  export type PatronageAvgAggregateOutputType = {
    gainPercentage: number | null
    discountPercentage: number | null
  }

  export type PatronageSumAggregateOutputType = {
    gainPercentage: number | null
    discountPercentage: number | null
  }

  export type PatronageMinAggregateOutputType = {
    id: string | null
    gainPercentage: number | null
    discountPercentage: number | null
    status: EnumStatusPatronage | null
    bonusEndDate: Date | null
    userParentId: string | null
    userChildId: string | null
    bonusCollect: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatronageMaxAggregateOutputType = {
    id: string | null
    gainPercentage: number | null
    discountPercentage: number | null
    status: EnumStatusPatronage | null
    bonusEndDate: Date | null
    userParentId: string | null
    userChildId: string | null
    bonusCollect: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatronageCountAggregateOutputType = {
    id: number
    gainPercentage: number
    discountPercentage: number
    status: number
    bonusEndDate: number
    userParentId: number
    userChildId: number
    bonusCollect: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatronageAvgAggregateInputType = {
    gainPercentage?: true
    discountPercentage?: true
  }

  export type PatronageSumAggregateInputType = {
    gainPercentage?: true
    discountPercentage?: true
  }

  export type PatronageMinAggregateInputType = {
    id?: true
    gainPercentage?: true
    discountPercentage?: true
    status?: true
    bonusEndDate?: true
    userParentId?: true
    userChildId?: true
    bonusCollect?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatronageMaxAggregateInputType = {
    id?: true
    gainPercentage?: true
    discountPercentage?: true
    status?: true
    bonusEndDate?: true
    userParentId?: true
    userChildId?: true
    bonusCollect?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatronageCountAggregateInputType = {
    id?: true
    gainPercentage?: true
    discountPercentage?: true
    status?: true
    bonusEndDate?: true
    userParentId?: true
    userChildId?: true
    bonusCollect?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatronageAggregateArgs = {
    /**
     * Filter which Patronage to aggregate.
     */
    where?: PatronageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patronages to fetch.
     */
    orderBy?: Enumerable<PatronageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatronageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patronages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patronages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patronages
    **/
    _count?: true | PatronageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatronageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatronageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatronageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatronageMaxAggregateInputType
  }

  export type GetPatronageAggregateType<T extends PatronageAggregateArgs> = {
        [P in keyof T & keyof AggregatePatronage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatronage[P]>
      : GetScalarType<T[P], AggregatePatronage[P]>
  }




  export type PatronageGroupByArgs = {
    where?: PatronageWhereInput
    orderBy?: Enumerable<PatronageOrderByWithAggregationInput>
    by: PatronageScalarFieldEnum[]
    having?: PatronageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatronageCountAggregateInputType | true
    _avg?: PatronageAvgAggregateInputType
    _sum?: PatronageSumAggregateInputType
    _min?: PatronageMinAggregateInputType
    _max?: PatronageMaxAggregateInputType
  }


  export type PatronageGroupByOutputType = {
    id: string
    gainPercentage: number | null
    discountPercentage: number | null
    status: EnumStatusPatronage | null
    bonusEndDate: Date | null
    userParentId: string
    userChildId: string
    bonusCollect: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: PatronageCountAggregateOutputType | null
    _avg: PatronageAvgAggregateOutputType | null
    _sum: PatronageSumAggregateOutputType | null
    _min: PatronageMinAggregateOutputType | null
    _max: PatronageMaxAggregateOutputType | null
  }

  type GetPatronageGroupByPayload<T extends PatronageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PatronageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatronageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatronageGroupByOutputType[P]>
            : GetScalarType<T[P], PatronageGroupByOutputType[P]>
        }
      >
    >


  export type PatronageSelect = {
    id?: boolean
    gainPercentage?: boolean
    discountPercentage?: boolean
    status?: boolean
    bonusEndDate?: boolean
    userParentId?: boolean
    userChildId?: boolean
    bonusCollect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userParent?: boolean | UserArgs
    userChild?: boolean | UserArgs
    game?: boolean | Patronage$gameArgs
    _count?: boolean | PatronageCountOutputTypeArgs
  }


  export type PatronageInclude = {
    userParent?: boolean | UserArgs
    userChild?: boolean | UserArgs
    game?: boolean | Patronage$gameArgs
    _count?: boolean | PatronageCountOutputTypeArgs
  }

  export type PatronageGetPayload<S extends boolean | null | undefined | PatronageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Patronage :
    S extends undefined ? never :
    S extends { include: any } & (PatronageArgs | PatronageFindManyArgs)
    ? Patronage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'userParent' ? UserGetPayload<S['include'][P]> :
        P extends 'userChild' ? UserGetPayload<S['include'][P]> :
        P extends 'game' ? Array < GameGetPayload<S['include'][P]>>  :
        P extends '_count' ? PatronageCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PatronageArgs | PatronageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'userParent' ? UserGetPayload<S['select'][P]> :
        P extends 'userChild' ? UserGetPayload<S['select'][P]> :
        P extends 'game' ? Array < GameGetPayload<S['select'][P]>>  :
        P extends '_count' ? PatronageCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Patronage ? Patronage[P] : never
  } 
      : Patronage


  type PatronageCountArgs = 
    Omit<PatronageFindManyArgs, 'select' | 'include'> & {
      select?: PatronageCountAggregateInputType | true
    }

  export interface PatronageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Patronage that matches the filter.
     * @param {PatronageFindUniqueArgs} args - Arguments to find a Patronage
     * @example
     * // Get one Patronage
     * const patronage = await prisma.patronage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PatronageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PatronageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Patronage'> extends True ? Prisma__PatronageClient<PatronageGetPayload<T>> : Prisma__PatronageClient<PatronageGetPayload<T> | null, null>

    /**
     * Find one Patronage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PatronageFindUniqueOrThrowArgs} args - Arguments to find a Patronage
     * @example
     * // Get one Patronage
     * const patronage = await prisma.patronage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PatronageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PatronageFindUniqueOrThrowArgs>
    ): Prisma__PatronageClient<PatronageGetPayload<T>>

    /**
     * Find the first Patronage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatronageFindFirstArgs} args - Arguments to find a Patronage
     * @example
     * // Get one Patronage
     * const patronage = await prisma.patronage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PatronageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PatronageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Patronage'> extends True ? Prisma__PatronageClient<PatronageGetPayload<T>> : Prisma__PatronageClient<PatronageGetPayload<T> | null, null>

    /**
     * Find the first Patronage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatronageFindFirstOrThrowArgs} args - Arguments to find a Patronage
     * @example
     * // Get one Patronage
     * const patronage = await prisma.patronage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PatronageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PatronageFindFirstOrThrowArgs>
    ): Prisma__PatronageClient<PatronageGetPayload<T>>

    /**
     * Find zero or more Patronages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatronageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patronages
     * const patronages = await prisma.patronage.findMany()
     * 
     * // Get first 10 Patronages
     * const patronages = await prisma.patronage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patronageWithIdOnly = await prisma.patronage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PatronageFindManyArgs>(
      args?: SelectSubset<T, PatronageFindManyArgs>
    ): Prisma.PrismaPromise<Array<PatronageGetPayload<T>>>

    /**
     * Create a Patronage.
     * @param {PatronageCreateArgs} args - Arguments to create a Patronage.
     * @example
     * // Create one Patronage
     * const Patronage = await prisma.patronage.create({
     *   data: {
     *     // ... data to create a Patronage
     *   }
     * })
     * 
    **/
    create<T extends PatronageCreateArgs>(
      args: SelectSubset<T, PatronageCreateArgs>
    ): Prisma__PatronageClient<PatronageGetPayload<T>>

    /**
     * Create many Patronages.
     *     @param {PatronageCreateManyArgs} args - Arguments to create many Patronages.
     *     @example
     *     // Create many Patronages
     *     const patronage = await prisma.patronage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PatronageCreateManyArgs>(
      args?: SelectSubset<T, PatronageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Patronage.
     * @param {PatronageDeleteArgs} args - Arguments to delete one Patronage.
     * @example
     * // Delete one Patronage
     * const Patronage = await prisma.patronage.delete({
     *   where: {
     *     // ... filter to delete one Patronage
     *   }
     * })
     * 
    **/
    delete<T extends PatronageDeleteArgs>(
      args: SelectSubset<T, PatronageDeleteArgs>
    ): Prisma__PatronageClient<PatronageGetPayload<T>>

    /**
     * Update one Patronage.
     * @param {PatronageUpdateArgs} args - Arguments to update one Patronage.
     * @example
     * // Update one Patronage
     * const patronage = await prisma.patronage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PatronageUpdateArgs>(
      args: SelectSubset<T, PatronageUpdateArgs>
    ): Prisma__PatronageClient<PatronageGetPayload<T>>

    /**
     * Delete zero or more Patronages.
     * @param {PatronageDeleteManyArgs} args - Arguments to filter Patronages to delete.
     * @example
     * // Delete a few Patronages
     * const { count } = await prisma.patronage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PatronageDeleteManyArgs>(
      args?: SelectSubset<T, PatronageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patronages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatronageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patronages
     * const patronage = await prisma.patronage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PatronageUpdateManyArgs>(
      args: SelectSubset<T, PatronageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patronage.
     * @param {PatronageUpsertArgs} args - Arguments to update or create a Patronage.
     * @example
     * // Update or create a Patronage
     * const patronage = await prisma.patronage.upsert({
     *   create: {
     *     // ... data to create a Patronage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patronage we want to update
     *   }
     * })
    **/
    upsert<T extends PatronageUpsertArgs>(
      args: SelectSubset<T, PatronageUpsertArgs>
    ): Prisma__PatronageClient<PatronageGetPayload<T>>

    /**
     * Find zero or more Patronages that matches the filter.
     * @param {PatronageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const patronage = await prisma.patronage.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: PatronageFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Patronage.
     * @param {PatronageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const patronage = await prisma.patronage.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: PatronageAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Patronages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatronageCountArgs} args - Arguments to filter Patronages to count.
     * @example
     * // Count the number of Patronages
     * const count = await prisma.patronage.count({
     *   where: {
     *     // ... the filter for the Patronages we want to count
     *   }
     * })
    **/
    count<T extends PatronageCountArgs>(
      args?: Subset<T, PatronageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatronageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patronage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatronageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatronageAggregateArgs>(args: Subset<T, PatronageAggregateArgs>): Prisma.PrismaPromise<GetPatronageAggregateType<T>>

    /**
     * Group by Patronage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatronageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatronageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatronageGroupByArgs['orderBy'] }
        : { orderBy?: PatronageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatronageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatronageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Patronage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PatronageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    userParent<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    userChild<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    game<T extends Patronage$gameArgs= {}>(args?: Subset<T, Patronage$gameArgs>): Prisma.PrismaPromise<Array<GameGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Patronage base type for findUnique actions
   */
  export type PatronageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Patronage
     */
    select?: PatronageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatronageInclude | null
    /**
     * Filter, which Patronage to fetch.
     */
    where: PatronageWhereUniqueInput
  }

  /**
   * Patronage findUnique
   */
  export interface PatronageFindUniqueArgs extends PatronageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Patronage findUniqueOrThrow
   */
  export type PatronageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Patronage
     */
    select?: PatronageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatronageInclude | null
    /**
     * Filter, which Patronage to fetch.
     */
    where: PatronageWhereUniqueInput
  }


  /**
   * Patronage base type for findFirst actions
   */
  export type PatronageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Patronage
     */
    select?: PatronageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatronageInclude | null
    /**
     * Filter, which Patronage to fetch.
     */
    where?: PatronageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patronages to fetch.
     */
    orderBy?: Enumerable<PatronageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patronages.
     */
    cursor?: PatronageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patronages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patronages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patronages.
     */
    distinct?: Enumerable<PatronageScalarFieldEnum>
  }

  /**
   * Patronage findFirst
   */
  export interface PatronageFindFirstArgs extends PatronageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Patronage findFirstOrThrow
   */
  export type PatronageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Patronage
     */
    select?: PatronageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatronageInclude | null
    /**
     * Filter, which Patronage to fetch.
     */
    where?: PatronageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patronages to fetch.
     */
    orderBy?: Enumerable<PatronageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patronages.
     */
    cursor?: PatronageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patronages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patronages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patronages.
     */
    distinct?: Enumerable<PatronageScalarFieldEnum>
  }


  /**
   * Patronage findMany
   */
  export type PatronageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Patronage
     */
    select?: PatronageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatronageInclude | null
    /**
     * Filter, which Patronages to fetch.
     */
    where?: PatronageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patronages to fetch.
     */
    orderBy?: Enumerable<PatronageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patronages.
     */
    cursor?: PatronageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patronages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patronages.
     */
    skip?: number
    distinct?: Enumerable<PatronageScalarFieldEnum>
  }


  /**
   * Patronage create
   */
  export type PatronageCreateArgs = {
    /**
     * Select specific fields to fetch from the Patronage
     */
    select?: PatronageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatronageInclude | null
    /**
     * The data needed to create a Patronage.
     */
    data: XOR<PatronageCreateInput, PatronageUncheckedCreateInput>
  }


  /**
   * Patronage createMany
   */
  export type PatronageCreateManyArgs = {
    /**
     * The data used to create many Patronages.
     */
    data: Enumerable<PatronageCreateManyInput>
  }


  /**
   * Patronage update
   */
  export type PatronageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Patronage
     */
    select?: PatronageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatronageInclude | null
    /**
     * The data needed to update a Patronage.
     */
    data: XOR<PatronageUpdateInput, PatronageUncheckedUpdateInput>
    /**
     * Choose, which Patronage to update.
     */
    where: PatronageWhereUniqueInput
  }


  /**
   * Patronage updateMany
   */
  export type PatronageUpdateManyArgs = {
    /**
     * The data used to update Patronages.
     */
    data: XOR<PatronageUpdateManyMutationInput, PatronageUncheckedUpdateManyInput>
    /**
     * Filter which Patronages to update
     */
    where?: PatronageWhereInput
  }


  /**
   * Patronage upsert
   */
  export type PatronageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Patronage
     */
    select?: PatronageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatronageInclude | null
    /**
     * The filter to search for the Patronage to update in case it exists.
     */
    where: PatronageWhereUniqueInput
    /**
     * In case the Patronage found by the `where` argument doesn't exist, create a new Patronage with this data.
     */
    create: XOR<PatronageCreateInput, PatronageUncheckedCreateInput>
    /**
     * In case the Patronage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatronageUpdateInput, PatronageUncheckedUpdateInput>
  }


  /**
   * Patronage delete
   */
  export type PatronageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Patronage
     */
    select?: PatronageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatronageInclude | null
    /**
     * Filter which Patronage to delete.
     */
    where: PatronageWhereUniqueInput
  }


  /**
   * Patronage deleteMany
   */
  export type PatronageDeleteManyArgs = {
    /**
     * Filter which Patronages to delete
     */
    where?: PatronageWhereInput
  }


  /**
   * Patronage findRaw
   */
  export type PatronageFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Patronage aggregateRaw
   */
  export type PatronageAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Patronage.game
   */
  export type Patronage$gameArgs = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude | null
    where?: GameWhereInput
    orderBy?: Enumerable<GameOrderByWithRelationInput>
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<GameScalarFieldEnum>
  }


  /**
   * Patronage without action
   */
  export type PatronageArgs = {
    /**
     * Select specific fields to fetch from the Patronage
     */
    select?: PatronageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatronageInclude | null
  }



  /**
   * Model CodeConfirmLogin
   */


  export type AggregateCodeConfirmLogin = {
    _count: CodeConfirmLoginCountAggregateOutputType | null
    _min: CodeConfirmLoginMinAggregateOutputType | null
    _max: CodeConfirmLoginMaxAggregateOutputType | null
  }

  export type CodeConfirmLoginMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    useId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CodeConfirmLoginMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    useId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CodeConfirmLoginCountAggregateOutputType = {
    id: number
    uuid: number
    useId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CodeConfirmLoginMinAggregateInputType = {
    id?: true
    uuid?: true
    useId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CodeConfirmLoginMaxAggregateInputType = {
    id?: true
    uuid?: true
    useId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CodeConfirmLoginCountAggregateInputType = {
    id?: true
    uuid?: true
    useId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CodeConfirmLoginAggregateArgs = {
    /**
     * Filter which CodeConfirmLogin to aggregate.
     */
    where?: CodeConfirmLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeConfirmLogins to fetch.
     */
    orderBy?: Enumerable<CodeConfirmLoginOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CodeConfirmLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeConfirmLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeConfirmLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CodeConfirmLogins
    **/
    _count?: true | CodeConfirmLoginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodeConfirmLoginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodeConfirmLoginMaxAggregateInputType
  }

  export type GetCodeConfirmLoginAggregateType<T extends CodeConfirmLoginAggregateArgs> = {
        [P in keyof T & keyof AggregateCodeConfirmLogin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodeConfirmLogin[P]>
      : GetScalarType<T[P], AggregateCodeConfirmLogin[P]>
  }




  export type CodeConfirmLoginGroupByArgs = {
    where?: CodeConfirmLoginWhereInput
    orderBy?: Enumerable<CodeConfirmLoginOrderByWithAggregationInput>
    by: CodeConfirmLoginScalarFieldEnum[]
    having?: CodeConfirmLoginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodeConfirmLoginCountAggregateInputType | true
    _min?: CodeConfirmLoginMinAggregateInputType
    _max?: CodeConfirmLoginMaxAggregateInputType
  }


  export type CodeConfirmLoginGroupByOutputType = {
    id: string
    uuid: string
    useId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: CodeConfirmLoginCountAggregateOutputType | null
    _min: CodeConfirmLoginMinAggregateOutputType | null
    _max: CodeConfirmLoginMaxAggregateOutputType | null
  }

  type GetCodeConfirmLoginGroupByPayload<T extends CodeConfirmLoginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CodeConfirmLoginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CodeConfirmLoginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CodeConfirmLoginGroupByOutputType[P]>
            : GetScalarType<T[P], CodeConfirmLoginGroupByOutputType[P]>
        }
      >
    >


  export type CodeConfirmLoginSelect = {
    id?: boolean
    uuid?: boolean
    useId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
  }


  export type CodeConfirmLoginInclude = {
    user?: boolean | UserArgs
  }

  export type CodeConfirmLoginGetPayload<S extends boolean | null | undefined | CodeConfirmLoginArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CodeConfirmLogin :
    S extends undefined ? never :
    S extends { include: any } & (CodeConfirmLoginArgs | CodeConfirmLoginFindManyArgs)
    ? CodeConfirmLogin  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CodeConfirmLoginArgs | CodeConfirmLoginFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof CodeConfirmLogin ? CodeConfirmLogin[P] : never
  } 
      : CodeConfirmLogin


  type CodeConfirmLoginCountArgs = 
    Omit<CodeConfirmLoginFindManyArgs, 'select' | 'include'> & {
      select?: CodeConfirmLoginCountAggregateInputType | true
    }

  export interface CodeConfirmLoginDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CodeConfirmLogin that matches the filter.
     * @param {CodeConfirmLoginFindUniqueArgs} args - Arguments to find a CodeConfirmLogin
     * @example
     * // Get one CodeConfirmLogin
     * const codeConfirmLogin = await prisma.codeConfirmLogin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CodeConfirmLoginFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CodeConfirmLoginFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CodeConfirmLogin'> extends True ? Prisma__CodeConfirmLoginClient<CodeConfirmLoginGetPayload<T>> : Prisma__CodeConfirmLoginClient<CodeConfirmLoginGetPayload<T> | null, null>

    /**
     * Find one CodeConfirmLogin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CodeConfirmLoginFindUniqueOrThrowArgs} args - Arguments to find a CodeConfirmLogin
     * @example
     * // Get one CodeConfirmLogin
     * const codeConfirmLogin = await prisma.codeConfirmLogin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CodeConfirmLoginFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CodeConfirmLoginFindUniqueOrThrowArgs>
    ): Prisma__CodeConfirmLoginClient<CodeConfirmLoginGetPayload<T>>

    /**
     * Find the first CodeConfirmLogin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeConfirmLoginFindFirstArgs} args - Arguments to find a CodeConfirmLogin
     * @example
     * // Get one CodeConfirmLogin
     * const codeConfirmLogin = await prisma.codeConfirmLogin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CodeConfirmLoginFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CodeConfirmLoginFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CodeConfirmLogin'> extends True ? Prisma__CodeConfirmLoginClient<CodeConfirmLoginGetPayload<T>> : Prisma__CodeConfirmLoginClient<CodeConfirmLoginGetPayload<T> | null, null>

    /**
     * Find the first CodeConfirmLogin that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeConfirmLoginFindFirstOrThrowArgs} args - Arguments to find a CodeConfirmLogin
     * @example
     * // Get one CodeConfirmLogin
     * const codeConfirmLogin = await prisma.codeConfirmLogin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CodeConfirmLoginFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CodeConfirmLoginFindFirstOrThrowArgs>
    ): Prisma__CodeConfirmLoginClient<CodeConfirmLoginGetPayload<T>>

    /**
     * Find zero or more CodeConfirmLogins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeConfirmLoginFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodeConfirmLogins
     * const codeConfirmLogins = await prisma.codeConfirmLogin.findMany()
     * 
     * // Get first 10 CodeConfirmLogins
     * const codeConfirmLogins = await prisma.codeConfirmLogin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const codeConfirmLoginWithIdOnly = await prisma.codeConfirmLogin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CodeConfirmLoginFindManyArgs>(
      args?: SelectSubset<T, CodeConfirmLoginFindManyArgs>
    ): Prisma.PrismaPromise<Array<CodeConfirmLoginGetPayload<T>>>

    /**
     * Create a CodeConfirmLogin.
     * @param {CodeConfirmLoginCreateArgs} args - Arguments to create a CodeConfirmLogin.
     * @example
     * // Create one CodeConfirmLogin
     * const CodeConfirmLogin = await prisma.codeConfirmLogin.create({
     *   data: {
     *     // ... data to create a CodeConfirmLogin
     *   }
     * })
     * 
    **/
    create<T extends CodeConfirmLoginCreateArgs>(
      args: SelectSubset<T, CodeConfirmLoginCreateArgs>
    ): Prisma__CodeConfirmLoginClient<CodeConfirmLoginGetPayload<T>>

    /**
     * Create many CodeConfirmLogins.
     *     @param {CodeConfirmLoginCreateManyArgs} args - Arguments to create many CodeConfirmLogins.
     *     @example
     *     // Create many CodeConfirmLogins
     *     const codeConfirmLogin = await prisma.codeConfirmLogin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CodeConfirmLoginCreateManyArgs>(
      args?: SelectSubset<T, CodeConfirmLoginCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CodeConfirmLogin.
     * @param {CodeConfirmLoginDeleteArgs} args - Arguments to delete one CodeConfirmLogin.
     * @example
     * // Delete one CodeConfirmLogin
     * const CodeConfirmLogin = await prisma.codeConfirmLogin.delete({
     *   where: {
     *     // ... filter to delete one CodeConfirmLogin
     *   }
     * })
     * 
    **/
    delete<T extends CodeConfirmLoginDeleteArgs>(
      args: SelectSubset<T, CodeConfirmLoginDeleteArgs>
    ): Prisma__CodeConfirmLoginClient<CodeConfirmLoginGetPayload<T>>

    /**
     * Update one CodeConfirmLogin.
     * @param {CodeConfirmLoginUpdateArgs} args - Arguments to update one CodeConfirmLogin.
     * @example
     * // Update one CodeConfirmLogin
     * const codeConfirmLogin = await prisma.codeConfirmLogin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CodeConfirmLoginUpdateArgs>(
      args: SelectSubset<T, CodeConfirmLoginUpdateArgs>
    ): Prisma__CodeConfirmLoginClient<CodeConfirmLoginGetPayload<T>>

    /**
     * Delete zero or more CodeConfirmLogins.
     * @param {CodeConfirmLoginDeleteManyArgs} args - Arguments to filter CodeConfirmLogins to delete.
     * @example
     * // Delete a few CodeConfirmLogins
     * const { count } = await prisma.codeConfirmLogin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CodeConfirmLoginDeleteManyArgs>(
      args?: SelectSubset<T, CodeConfirmLoginDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeConfirmLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeConfirmLoginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodeConfirmLogins
     * const codeConfirmLogin = await prisma.codeConfirmLogin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CodeConfirmLoginUpdateManyArgs>(
      args: SelectSubset<T, CodeConfirmLoginUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CodeConfirmLogin.
     * @param {CodeConfirmLoginUpsertArgs} args - Arguments to update or create a CodeConfirmLogin.
     * @example
     * // Update or create a CodeConfirmLogin
     * const codeConfirmLogin = await prisma.codeConfirmLogin.upsert({
     *   create: {
     *     // ... data to create a CodeConfirmLogin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodeConfirmLogin we want to update
     *   }
     * })
    **/
    upsert<T extends CodeConfirmLoginUpsertArgs>(
      args: SelectSubset<T, CodeConfirmLoginUpsertArgs>
    ): Prisma__CodeConfirmLoginClient<CodeConfirmLoginGetPayload<T>>

    /**
     * Find zero or more CodeConfirmLogins that matches the filter.
     * @param {CodeConfirmLoginFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const codeConfirmLogin = await prisma.codeConfirmLogin.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: CodeConfirmLoginFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CodeConfirmLogin.
     * @param {CodeConfirmLoginAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const codeConfirmLogin = await prisma.codeConfirmLogin.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: CodeConfirmLoginAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of CodeConfirmLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeConfirmLoginCountArgs} args - Arguments to filter CodeConfirmLogins to count.
     * @example
     * // Count the number of CodeConfirmLogins
     * const count = await prisma.codeConfirmLogin.count({
     *   where: {
     *     // ... the filter for the CodeConfirmLogins we want to count
     *   }
     * })
    **/
    count<T extends CodeConfirmLoginCountArgs>(
      args?: Subset<T, CodeConfirmLoginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodeConfirmLoginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodeConfirmLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeConfirmLoginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodeConfirmLoginAggregateArgs>(args: Subset<T, CodeConfirmLoginAggregateArgs>): Prisma.PrismaPromise<GetCodeConfirmLoginAggregateType<T>>

    /**
     * Group by CodeConfirmLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeConfirmLoginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodeConfirmLoginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodeConfirmLoginGroupByArgs['orderBy'] }
        : { orderBy?: CodeConfirmLoginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodeConfirmLoginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodeConfirmLoginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CodeConfirmLogin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CodeConfirmLoginClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CodeConfirmLogin base type for findUnique actions
   */
  export type CodeConfirmLoginFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CodeConfirmLogin
     */
    select?: CodeConfirmLoginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmLoginInclude | null
    /**
     * Filter, which CodeConfirmLogin to fetch.
     */
    where: CodeConfirmLoginWhereUniqueInput
  }

  /**
   * CodeConfirmLogin findUnique
   */
  export interface CodeConfirmLoginFindUniqueArgs extends CodeConfirmLoginFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CodeConfirmLogin findUniqueOrThrow
   */
  export type CodeConfirmLoginFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CodeConfirmLogin
     */
    select?: CodeConfirmLoginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmLoginInclude | null
    /**
     * Filter, which CodeConfirmLogin to fetch.
     */
    where: CodeConfirmLoginWhereUniqueInput
  }


  /**
   * CodeConfirmLogin base type for findFirst actions
   */
  export type CodeConfirmLoginFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CodeConfirmLogin
     */
    select?: CodeConfirmLoginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmLoginInclude | null
    /**
     * Filter, which CodeConfirmLogin to fetch.
     */
    where?: CodeConfirmLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeConfirmLogins to fetch.
     */
    orderBy?: Enumerable<CodeConfirmLoginOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodeConfirmLogins.
     */
    cursor?: CodeConfirmLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeConfirmLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeConfirmLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodeConfirmLogins.
     */
    distinct?: Enumerable<CodeConfirmLoginScalarFieldEnum>
  }

  /**
   * CodeConfirmLogin findFirst
   */
  export interface CodeConfirmLoginFindFirstArgs extends CodeConfirmLoginFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CodeConfirmLogin findFirstOrThrow
   */
  export type CodeConfirmLoginFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CodeConfirmLogin
     */
    select?: CodeConfirmLoginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmLoginInclude | null
    /**
     * Filter, which CodeConfirmLogin to fetch.
     */
    where?: CodeConfirmLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeConfirmLogins to fetch.
     */
    orderBy?: Enumerable<CodeConfirmLoginOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodeConfirmLogins.
     */
    cursor?: CodeConfirmLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeConfirmLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeConfirmLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodeConfirmLogins.
     */
    distinct?: Enumerable<CodeConfirmLoginScalarFieldEnum>
  }


  /**
   * CodeConfirmLogin findMany
   */
  export type CodeConfirmLoginFindManyArgs = {
    /**
     * Select specific fields to fetch from the CodeConfirmLogin
     */
    select?: CodeConfirmLoginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmLoginInclude | null
    /**
     * Filter, which CodeConfirmLogins to fetch.
     */
    where?: CodeConfirmLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeConfirmLogins to fetch.
     */
    orderBy?: Enumerable<CodeConfirmLoginOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CodeConfirmLogins.
     */
    cursor?: CodeConfirmLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeConfirmLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeConfirmLogins.
     */
    skip?: number
    distinct?: Enumerable<CodeConfirmLoginScalarFieldEnum>
  }


  /**
   * CodeConfirmLogin create
   */
  export type CodeConfirmLoginCreateArgs = {
    /**
     * Select specific fields to fetch from the CodeConfirmLogin
     */
    select?: CodeConfirmLoginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmLoginInclude | null
    /**
     * The data needed to create a CodeConfirmLogin.
     */
    data: XOR<CodeConfirmLoginCreateInput, CodeConfirmLoginUncheckedCreateInput>
  }


  /**
   * CodeConfirmLogin createMany
   */
  export type CodeConfirmLoginCreateManyArgs = {
    /**
     * The data used to create many CodeConfirmLogins.
     */
    data: Enumerable<CodeConfirmLoginCreateManyInput>
  }


  /**
   * CodeConfirmLogin update
   */
  export type CodeConfirmLoginUpdateArgs = {
    /**
     * Select specific fields to fetch from the CodeConfirmLogin
     */
    select?: CodeConfirmLoginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmLoginInclude | null
    /**
     * The data needed to update a CodeConfirmLogin.
     */
    data: XOR<CodeConfirmLoginUpdateInput, CodeConfirmLoginUncheckedUpdateInput>
    /**
     * Choose, which CodeConfirmLogin to update.
     */
    where: CodeConfirmLoginWhereUniqueInput
  }


  /**
   * CodeConfirmLogin updateMany
   */
  export type CodeConfirmLoginUpdateManyArgs = {
    /**
     * The data used to update CodeConfirmLogins.
     */
    data: XOR<CodeConfirmLoginUpdateManyMutationInput, CodeConfirmLoginUncheckedUpdateManyInput>
    /**
     * Filter which CodeConfirmLogins to update
     */
    where?: CodeConfirmLoginWhereInput
  }


  /**
   * CodeConfirmLogin upsert
   */
  export type CodeConfirmLoginUpsertArgs = {
    /**
     * Select specific fields to fetch from the CodeConfirmLogin
     */
    select?: CodeConfirmLoginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmLoginInclude | null
    /**
     * The filter to search for the CodeConfirmLogin to update in case it exists.
     */
    where: CodeConfirmLoginWhereUniqueInput
    /**
     * In case the CodeConfirmLogin found by the `where` argument doesn't exist, create a new CodeConfirmLogin with this data.
     */
    create: XOR<CodeConfirmLoginCreateInput, CodeConfirmLoginUncheckedCreateInput>
    /**
     * In case the CodeConfirmLogin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CodeConfirmLoginUpdateInput, CodeConfirmLoginUncheckedUpdateInput>
  }


  /**
   * CodeConfirmLogin delete
   */
  export type CodeConfirmLoginDeleteArgs = {
    /**
     * Select specific fields to fetch from the CodeConfirmLogin
     */
    select?: CodeConfirmLoginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmLoginInclude | null
    /**
     * Filter which CodeConfirmLogin to delete.
     */
    where: CodeConfirmLoginWhereUniqueInput
  }


  /**
   * CodeConfirmLogin deleteMany
   */
  export type CodeConfirmLoginDeleteManyArgs = {
    /**
     * Filter which CodeConfirmLogins to delete
     */
    where?: CodeConfirmLoginWhereInput
  }


  /**
   * CodeConfirmLogin findRaw
   */
  export type CodeConfirmLoginFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * CodeConfirmLogin aggregateRaw
   */
  export type CodeConfirmLoginAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * CodeConfirmLogin without action
   */
  export type CodeConfirmLoginArgs = {
    /**
     * Select specific fields to fetch from the CodeConfirmLogin
     */
    select?: CodeConfirmLoginSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmLoginInclude | null
  }



  /**
   * Model CodeConfirmMail
   */


  export type AggregateCodeConfirmMail = {
    _count: CodeConfirmMailCountAggregateOutputType | null
    _min: CodeConfirmMailMinAggregateOutputType | null
    _max: CodeConfirmMailMaxAggregateOutputType | null
  }

  export type CodeConfirmMailMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    useId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CodeConfirmMailMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    useId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CodeConfirmMailCountAggregateOutputType = {
    id: number
    uuid: number
    useId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CodeConfirmMailMinAggregateInputType = {
    id?: true
    uuid?: true
    useId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CodeConfirmMailMaxAggregateInputType = {
    id?: true
    uuid?: true
    useId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CodeConfirmMailCountAggregateInputType = {
    id?: true
    uuid?: true
    useId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CodeConfirmMailAggregateArgs = {
    /**
     * Filter which CodeConfirmMail to aggregate.
     */
    where?: CodeConfirmMailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeConfirmMails to fetch.
     */
    orderBy?: Enumerable<CodeConfirmMailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CodeConfirmMailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeConfirmMails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeConfirmMails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CodeConfirmMails
    **/
    _count?: true | CodeConfirmMailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodeConfirmMailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodeConfirmMailMaxAggregateInputType
  }

  export type GetCodeConfirmMailAggregateType<T extends CodeConfirmMailAggregateArgs> = {
        [P in keyof T & keyof AggregateCodeConfirmMail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodeConfirmMail[P]>
      : GetScalarType<T[P], AggregateCodeConfirmMail[P]>
  }




  export type CodeConfirmMailGroupByArgs = {
    where?: CodeConfirmMailWhereInput
    orderBy?: Enumerable<CodeConfirmMailOrderByWithAggregationInput>
    by: CodeConfirmMailScalarFieldEnum[]
    having?: CodeConfirmMailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodeConfirmMailCountAggregateInputType | true
    _min?: CodeConfirmMailMinAggregateInputType
    _max?: CodeConfirmMailMaxAggregateInputType
  }


  export type CodeConfirmMailGroupByOutputType = {
    id: string
    uuid: string
    useId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: CodeConfirmMailCountAggregateOutputType | null
    _min: CodeConfirmMailMinAggregateOutputType | null
    _max: CodeConfirmMailMaxAggregateOutputType | null
  }

  type GetCodeConfirmMailGroupByPayload<T extends CodeConfirmMailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CodeConfirmMailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CodeConfirmMailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CodeConfirmMailGroupByOutputType[P]>
            : GetScalarType<T[P], CodeConfirmMailGroupByOutputType[P]>
        }
      >
    >


  export type CodeConfirmMailSelect = {
    id?: boolean
    uuid?: boolean
    useId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
  }


  export type CodeConfirmMailInclude = {
    user?: boolean | UserArgs
  }

  export type CodeConfirmMailGetPayload<S extends boolean | null | undefined | CodeConfirmMailArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CodeConfirmMail :
    S extends undefined ? never :
    S extends { include: any } & (CodeConfirmMailArgs | CodeConfirmMailFindManyArgs)
    ? CodeConfirmMail  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CodeConfirmMailArgs | CodeConfirmMailFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof CodeConfirmMail ? CodeConfirmMail[P] : never
  } 
      : CodeConfirmMail


  type CodeConfirmMailCountArgs = 
    Omit<CodeConfirmMailFindManyArgs, 'select' | 'include'> & {
      select?: CodeConfirmMailCountAggregateInputType | true
    }

  export interface CodeConfirmMailDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CodeConfirmMail that matches the filter.
     * @param {CodeConfirmMailFindUniqueArgs} args - Arguments to find a CodeConfirmMail
     * @example
     * // Get one CodeConfirmMail
     * const codeConfirmMail = await prisma.codeConfirmMail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CodeConfirmMailFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CodeConfirmMailFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CodeConfirmMail'> extends True ? Prisma__CodeConfirmMailClient<CodeConfirmMailGetPayload<T>> : Prisma__CodeConfirmMailClient<CodeConfirmMailGetPayload<T> | null, null>

    /**
     * Find one CodeConfirmMail that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CodeConfirmMailFindUniqueOrThrowArgs} args - Arguments to find a CodeConfirmMail
     * @example
     * // Get one CodeConfirmMail
     * const codeConfirmMail = await prisma.codeConfirmMail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CodeConfirmMailFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CodeConfirmMailFindUniqueOrThrowArgs>
    ): Prisma__CodeConfirmMailClient<CodeConfirmMailGetPayload<T>>

    /**
     * Find the first CodeConfirmMail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeConfirmMailFindFirstArgs} args - Arguments to find a CodeConfirmMail
     * @example
     * // Get one CodeConfirmMail
     * const codeConfirmMail = await prisma.codeConfirmMail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CodeConfirmMailFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CodeConfirmMailFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CodeConfirmMail'> extends True ? Prisma__CodeConfirmMailClient<CodeConfirmMailGetPayload<T>> : Prisma__CodeConfirmMailClient<CodeConfirmMailGetPayload<T> | null, null>

    /**
     * Find the first CodeConfirmMail that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeConfirmMailFindFirstOrThrowArgs} args - Arguments to find a CodeConfirmMail
     * @example
     * // Get one CodeConfirmMail
     * const codeConfirmMail = await prisma.codeConfirmMail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CodeConfirmMailFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CodeConfirmMailFindFirstOrThrowArgs>
    ): Prisma__CodeConfirmMailClient<CodeConfirmMailGetPayload<T>>

    /**
     * Find zero or more CodeConfirmMails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeConfirmMailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CodeConfirmMails
     * const codeConfirmMails = await prisma.codeConfirmMail.findMany()
     * 
     * // Get first 10 CodeConfirmMails
     * const codeConfirmMails = await prisma.codeConfirmMail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const codeConfirmMailWithIdOnly = await prisma.codeConfirmMail.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CodeConfirmMailFindManyArgs>(
      args?: SelectSubset<T, CodeConfirmMailFindManyArgs>
    ): Prisma.PrismaPromise<Array<CodeConfirmMailGetPayload<T>>>

    /**
     * Create a CodeConfirmMail.
     * @param {CodeConfirmMailCreateArgs} args - Arguments to create a CodeConfirmMail.
     * @example
     * // Create one CodeConfirmMail
     * const CodeConfirmMail = await prisma.codeConfirmMail.create({
     *   data: {
     *     // ... data to create a CodeConfirmMail
     *   }
     * })
     * 
    **/
    create<T extends CodeConfirmMailCreateArgs>(
      args: SelectSubset<T, CodeConfirmMailCreateArgs>
    ): Prisma__CodeConfirmMailClient<CodeConfirmMailGetPayload<T>>

    /**
     * Create many CodeConfirmMails.
     *     @param {CodeConfirmMailCreateManyArgs} args - Arguments to create many CodeConfirmMails.
     *     @example
     *     // Create many CodeConfirmMails
     *     const codeConfirmMail = await prisma.codeConfirmMail.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CodeConfirmMailCreateManyArgs>(
      args?: SelectSubset<T, CodeConfirmMailCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CodeConfirmMail.
     * @param {CodeConfirmMailDeleteArgs} args - Arguments to delete one CodeConfirmMail.
     * @example
     * // Delete one CodeConfirmMail
     * const CodeConfirmMail = await prisma.codeConfirmMail.delete({
     *   where: {
     *     // ... filter to delete one CodeConfirmMail
     *   }
     * })
     * 
    **/
    delete<T extends CodeConfirmMailDeleteArgs>(
      args: SelectSubset<T, CodeConfirmMailDeleteArgs>
    ): Prisma__CodeConfirmMailClient<CodeConfirmMailGetPayload<T>>

    /**
     * Update one CodeConfirmMail.
     * @param {CodeConfirmMailUpdateArgs} args - Arguments to update one CodeConfirmMail.
     * @example
     * // Update one CodeConfirmMail
     * const codeConfirmMail = await prisma.codeConfirmMail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CodeConfirmMailUpdateArgs>(
      args: SelectSubset<T, CodeConfirmMailUpdateArgs>
    ): Prisma__CodeConfirmMailClient<CodeConfirmMailGetPayload<T>>

    /**
     * Delete zero or more CodeConfirmMails.
     * @param {CodeConfirmMailDeleteManyArgs} args - Arguments to filter CodeConfirmMails to delete.
     * @example
     * // Delete a few CodeConfirmMails
     * const { count } = await prisma.codeConfirmMail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CodeConfirmMailDeleteManyArgs>(
      args?: SelectSubset<T, CodeConfirmMailDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CodeConfirmMails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeConfirmMailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CodeConfirmMails
     * const codeConfirmMail = await prisma.codeConfirmMail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CodeConfirmMailUpdateManyArgs>(
      args: SelectSubset<T, CodeConfirmMailUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CodeConfirmMail.
     * @param {CodeConfirmMailUpsertArgs} args - Arguments to update or create a CodeConfirmMail.
     * @example
     * // Update or create a CodeConfirmMail
     * const codeConfirmMail = await prisma.codeConfirmMail.upsert({
     *   create: {
     *     // ... data to create a CodeConfirmMail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CodeConfirmMail we want to update
     *   }
     * })
    **/
    upsert<T extends CodeConfirmMailUpsertArgs>(
      args: SelectSubset<T, CodeConfirmMailUpsertArgs>
    ): Prisma__CodeConfirmMailClient<CodeConfirmMailGetPayload<T>>

    /**
     * Find zero or more CodeConfirmMails that matches the filter.
     * @param {CodeConfirmMailFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const codeConfirmMail = await prisma.codeConfirmMail.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: CodeConfirmMailFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CodeConfirmMail.
     * @param {CodeConfirmMailAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const codeConfirmMail = await prisma.codeConfirmMail.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: CodeConfirmMailAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of CodeConfirmMails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeConfirmMailCountArgs} args - Arguments to filter CodeConfirmMails to count.
     * @example
     * // Count the number of CodeConfirmMails
     * const count = await prisma.codeConfirmMail.count({
     *   where: {
     *     // ... the filter for the CodeConfirmMails we want to count
     *   }
     * })
    **/
    count<T extends CodeConfirmMailCountArgs>(
      args?: Subset<T, CodeConfirmMailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodeConfirmMailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CodeConfirmMail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeConfirmMailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodeConfirmMailAggregateArgs>(args: Subset<T, CodeConfirmMailAggregateArgs>): Prisma.PrismaPromise<GetCodeConfirmMailAggregateType<T>>

    /**
     * Group by CodeConfirmMail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodeConfirmMailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CodeConfirmMailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CodeConfirmMailGroupByArgs['orderBy'] }
        : { orderBy?: CodeConfirmMailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CodeConfirmMailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodeConfirmMailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CodeConfirmMail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CodeConfirmMailClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CodeConfirmMail base type for findUnique actions
   */
  export type CodeConfirmMailFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CodeConfirmMail
     */
    select?: CodeConfirmMailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmMailInclude | null
    /**
     * Filter, which CodeConfirmMail to fetch.
     */
    where: CodeConfirmMailWhereUniqueInput
  }

  /**
   * CodeConfirmMail findUnique
   */
  export interface CodeConfirmMailFindUniqueArgs extends CodeConfirmMailFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CodeConfirmMail findUniqueOrThrow
   */
  export type CodeConfirmMailFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CodeConfirmMail
     */
    select?: CodeConfirmMailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmMailInclude | null
    /**
     * Filter, which CodeConfirmMail to fetch.
     */
    where: CodeConfirmMailWhereUniqueInput
  }


  /**
   * CodeConfirmMail base type for findFirst actions
   */
  export type CodeConfirmMailFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CodeConfirmMail
     */
    select?: CodeConfirmMailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmMailInclude | null
    /**
     * Filter, which CodeConfirmMail to fetch.
     */
    where?: CodeConfirmMailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeConfirmMails to fetch.
     */
    orderBy?: Enumerable<CodeConfirmMailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodeConfirmMails.
     */
    cursor?: CodeConfirmMailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeConfirmMails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeConfirmMails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodeConfirmMails.
     */
    distinct?: Enumerable<CodeConfirmMailScalarFieldEnum>
  }

  /**
   * CodeConfirmMail findFirst
   */
  export interface CodeConfirmMailFindFirstArgs extends CodeConfirmMailFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CodeConfirmMail findFirstOrThrow
   */
  export type CodeConfirmMailFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CodeConfirmMail
     */
    select?: CodeConfirmMailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmMailInclude | null
    /**
     * Filter, which CodeConfirmMail to fetch.
     */
    where?: CodeConfirmMailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeConfirmMails to fetch.
     */
    orderBy?: Enumerable<CodeConfirmMailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CodeConfirmMails.
     */
    cursor?: CodeConfirmMailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeConfirmMails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeConfirmMails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CodeConfirmMails.
     */
    distinct?: Enumerable<CodeConfirmMailScalarFieldEnum>
  }


  /**
   * CodeConfirmMail findMany
   */
  export type CodeConfirmMailFindManyArgs = {
    /**
     * Select specific fields to fetch from the CodeConfirmMail
     */
    select?: CodeConfirmMailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmMailInclude | null
    /**
     * Filter, which CodeConfirmMails to fetch.
     */
    where?: CodeConfirmMailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CodeConfirmMails to fetch.
     */
    orderBy?: Enumerable<CodeConfirmMailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CodeConfirmMails.
     */
    cursor?: CodeConfirmMailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CodeConfirmMails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CodeConfirmMails.
     */
    skip?: number
    distinct?: Enumerable<CodeConfirmMailScalarFieldEnum>
  }


  /**
   * CodeConfirmMail create
   */
  export type CodeConfirmMailCreateArgs = {
    /**
     * Select specific fields to fetch from the CodeConfirmMail
     */
    select?: CodeConfirmMailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmMailInclude | null
    /**
     * The data needed to create a CodeConfirmMail.
     */
    data: XOR<CodeConfirmMailCreateInput, CodeConfirmMailUncheckedCreateInput>
  }


  /**
   * CodeConfirmMail createMany
   */
  export type CodeConfirmMailCreateManyArgs = {
    /**
     * The data used to create many CodeConfirmMails.
     */
    data: Enumerable<CodeConfirmMailCreateManyInput>
  }


  /**
   * CodeConfirmMail update
   */
  export type CodeConfirmMailUpdateArgs = {
    /**
     * Select specific fields to fetch from the CodeConfirmMail
     */
    select?: CodeConfirmMailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmMailInclude | null
    /**
     * The data needed to update a CodeConfirmMail.
     */
    data: XOR<CodeConfirmMailUpdateInput, CodeConfirmMailUncheckedUpdateInput>
    /**
     * Choose, which CodeConfirmMail to update.
     */
    where: CodeConfirmMailWhereUniqueInput
  }


  /**
   * CodeConfirmMail updateMany
   */
  export type CodeConfirmMailUpdateManyArgs = {
    /**
     * The data used to update CodeConfirmMails.
     */
    data: XOR<CodeConfirmMailUpdateManyMutationInput, CodeConfirmMailUncheckedUpdateManyInput>
    /**
     * Filter which CodeConfirmMails to update
     */
    where?: CodeConfirmMailWhereInput
  }


  /**
   * CodeConfirmMail upsert
   */
  export type CodeConfirmMailUpsertArgs = {
    /**
     * Select specific fields to fetch from the CodeConfirmMail
     */
    select?: CodeConfirmMailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmMailInclude | null
    /**
     * The filter to search for the CodeConfirmMail to update in case it exists.
     */
    where: CodeConfirmMailWhereUniqueInput
    /**
     * In case the CodeConfirmMail found by the `where` argument doesn't exist, create a new CodeConfirmMail with this data.
     */
    create: XOR<CodeConfirmMailCreateInput, CodeConfirmMailUncheckedCreateInput>
    /**
     * In case the CodeConfirmMail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CodeConfirmMailUpdateInput, CodeConfirmMailUncheckedUpdateInput>
  }


  /**
   * CodeConfirmMail delete
   */
  export type CodeConfirmMailDeleteArgs = {
    /**
     * Select specific fields to fetch from the CodeConfirmMail
     */
    select?: CodeConfirmMailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmMailInclude | null
    /**
     * Filter which CodeConfirmMail to delete.
     */
    where: CodeConfirmMailWhereUniqueInput
  }


  /**
   * CodeConfirmMail deleteMany
   */
  export type CodeConfirmMailDeleteManyArgs = {
    /**
     * Filter which CodeConfirmMails to delete
     */
    where?: CodeConfirmMailWhereInput
  }


  /**
   * CodeConfirmMail findRaw
   */
  export type CodeConfirmMailFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * CodeConfirmMail aggregateRaw
   */
  export type CodeConfirmMailAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * CodeConfirmMail without action
   */
  export type CodeConfirmMailArgs = {
    /**
     * Select specific fields to fetch from the CodeConfirmMail
     */
    select?: CodeConfirmMailSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CodeConfirmMailInclude | null
  }



  /**
   * Model TokenBlackList
   */


  export type AggregateTokenBlackList = {
    _count: TokenBlackListCountAggregateOutputType | null
    _min: TokenBlackListMinAggregateOutputType | null
    _max: TokenBlackListMaxAggregateOutputType | null
  }

  export type TokenBlackListMinAggregateOutputType = {
    id: string | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TokenBlackListMaxAggregateOutputType = {
    id: string | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TokenBlackListCountAggregateOutputType = {
    id: number
    token: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TokenBlackListMinAggregateInputType = {
    id?: true
    token?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TokenBlackListMaxAggregateInputType = {
    id?: true
    token?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TokenBlackListCountAggregateInputType = {
    id?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TokenBlackListAggregateArgs = {
    /**
     * Filter which TokenBlackList to aggregate.
     */
    where?: TokenBlackListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenBlackLists to fetch.
     */
    orderBy?: Enumerable<TokenBlackListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenBlackListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenBlackLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenBlackLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TokenBlackLists
    **/
    _count?: true | TokenBlackListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenBlackListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenBlackListMaxAggregateInputType
  }

  export type GetTokenBlackListAggregateType<T extends TokenBlackListAggregateArgs> = {
        [P in keyof T & keyof AggregateTokenBlackList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokenBlackList[P]>
      : GetScalarType<T[P], AggregateTokenBlackList[P]>
  }




  export type TokenBlackListGroupByArgs = {
    where?: TokenBlackListWhereInput
    orderBy?: Enumerable<TokenBlackListOrderByWithAggregationInput>
    by: TokenBlackListScalarFieldEnum[]
    having?: TokenBlackListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenBlackListCountAggregateInputType | true
    _min?: TokenBlackListMinAggregateInputType
    _max?: TokenBlackListMaxAggregateInputType
  }


  export type TokenBlackListGroupByOutputType = {
    id: string
    token: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: TokenBlackListCountAggregateOutputType | null
    _min: TokenBlackListMinAggregateOutputType | null
    _max: TokenBlackListMaxAggregateOutputType | null
  }

  type GetTokenBlackListGroupByPayload<T extends TokenBlackListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TokenBlackListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenBlackListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenBlackListGroupByOutputType[P]>
            : GetScalarType<T[P], TokenBlackListGroupByOutputType[P]>
        }
      >
    >


  export type TokenBlackListSelect = {
    id?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type TokenBlackListGetPayload<S extends boolean | null | undefined | TokenBlackListArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TokenBlackList :
    S extends undefined ? never :
    S extends { include: any } & (TokenBlackListArgs | TokenBlackListFindManyArgs)
    ? TokenBlackList 
    : S extends { select: any } & (TokenBlackListArgs | TokenBlackListFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TokenBlackList ? TokenBlackList[P] : never
  } 
      : TokenBlackList


  type TokenBlackListCountArgs = 
    Omit<TokenBlackListFindManyArgs, 'select' | 'include'> & {
      select?: TokenBlackListCountAggregateInputType | true
    }

  export interface TokenBlackListDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TokenBlackList that matches the filter.
     * @param {TokenBlackListFindUniqueArgs} args - Arguments to find a TokenBlackList
     * @example
     * // Get one TokenBlackList
     * const tokenBlackList = await prisma.tokenBlackList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TokenBlackListFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TokenBlackListFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TokenBlackList'> extends True ? Prisma__TokenBlackListClient<TokenBlackListGetPayload<T>> : Prisma__TokenBlackListClient<TokenBlackListGetPayload<T> | null, null>

    /**
     * Find one TokenBlackList that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TokenBlackListFindUniqueOrThrowArgs} args - Arguments to find a TokenBlackList
     * @example
     * // Get one TokenBlackList
     * const tokenBlackList = await prisma.tokenBlackList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TokenBlackListFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TokenBlackListFindUniqueOrThrowArgs>
    ): Prisma__TokenBlackListClient<TokenBlackListGetPayload<T>>

    /**
     * Find the first TokenBlackList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenBlackListFindFirstArgs} args - Arguments to find a TokenBlackList
     * @example
     * // Get one TokenBlackList
     * const tokenBlackList = await prisma.tokenBlackList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TokenBlackListFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TokenBlackListFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TokenBlackList'> extends True ? Prisma__TokenBlackListClient<TokenBlackListGetPayload<T>> : Prisma__TokenBlackListClient<TokenBlackListGetPayload<T> | null, null>

    /**
     * Find the first TokenBlackList that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenBlackListFindFirstOrThrowArgs} args - Arguments to find a TokenBlackList
     * @example
     * // Get one TokenBlackList
     * const tokenBlackList = await prisma.tokenBlackList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TokenBlackListFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TokenBlackListFindFirstOrThrowArgs>
    ): Prisma__TokenBlackListClient<TokenBlackListGetPayload<T>>

    /**
     * Find zero or more TokenBlackLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenBlackListFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TokenBlackLists
     * const tokenBlackLists = await prisma.tokenBlackList.findMany()
     * 
     * // Get first 10 TokenBlackLists
     * const tokenBlackLists = await prisma.tokenBlackList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenBlackListWithIdOnly = await prisma.tokenBlackList.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TokenBlackListFindManyArgs>(
      args?: SelectSubset<T, TokenBlackListFindManyArgs>
    ): Prisma.PrismaPromise<Array<TokenBlackListGetPayload<T>>>

    /**
     * Create a TokenBlackList.
     * @param {TokenBlackListCreateArgs} args - Arguments to create a TokenBlackList.
     * @example
     * // Create one TokenBlackList
     * const TokenBlackList = await prisma.tokenBlackList.create({
     *   data: {
     *     // ... data to create a TokenBlackList
     *   }
     * })
     * 
    **/
    create<T extends TokenBlackListCreateArgs>(
      args: SelectSubset<T, TokenBlackListCreateArgs>
    ): Prisma__TokenBlackListClient<TokenBlackListGetPayload<T>>

    /**
     * Create many TokenBlackLists.
     *     @param {TokenBlackListCreateManyArgs} args - Arguments to create many TokenBlackLists.
     *     @example
     *     // Create many TokenBlackLists
     *     const tokenBlackList = await prisma.tokenBlackList.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TokenBlackListCreateManyArgs>(
      args?: SelectSubset<T, TokenBlackListCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TokenBlackList.
     * @param {TokenBlackListDeleteArgs} args - Arguments to delete one TokenBlackList.
     * @example
     * // Delete one TokenBlackList
     * const TokenBlackList = await prisma.tokenBlackList.delete({
     *   where: {
     *     // ... filter to delete one TokenBlackList
     *   }
     * })
     * 
    **/
    delete<T extends TokenBlackListDeleteArgs>(
      args: SelectSubset<T, TokenBlackListDeleteArgs>
    ): Prisma__TokenBlackListClient<TokenBlackListGetPayload<T>>

    /**
     * Update one TokenBlackList.
     * @param {TokenBlackListUpdateArgs} args - Arguments to update one TokenBlackList.
     * @example
     * // Update one TokenBlackList
     * const tokenBlackList = await prisma.tokenBlackList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TokenBlackListUpdateArgs>(
      args: SelectSubset<T, TokenBlackListUpdateArgs>
    ): Prisma__TokenBlackListClient<TokenBlackListGetPayload<T>>

    /**
     * Delete zero or more TokenBlackLists.
     * @param {TokenBlackListDeleteManyArgs} args - Arguments to filter TokenBlackLists to delete.
     * @example
     * // Delete a few TokenBlackLists
     * const { count } = await prisma.tokenBlackList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TokenBlackListDeleteManyArgs>(
      args?: SelectSubset<T, TokenBlackListDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TokenBlackLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenBlackListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TokenBlackLists
     * const tokenBlackList = await prisma.tokenBlackList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TokenBlackListUpdateManyArgs>(
      args: SelectSubset<T, TokenBlackListUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TokenBlackList.
     * @param {TokenBlackListUpsertArgs} args - Arguments to update or create a TokenBlackList.
     * @example
     * // Update or create a TokenBlackList
     * const tokenBlackList = await prisma.tokenBlackList.upsert({
     *   create: {
     *     // ... data to create a TokenBlackList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TokenBlackList we want to update
     *   }
     * })
    **/
    upsert<T extends TokenBlackListUpsertArgs>(
      args: SelectSubset<T, TokenBlackListUpsertArgs>
    ): Prisma__TokenBlackListClient<TokenBlackListGetPayload<T>>

    /**
     * Find zero or more TokenBlackLists that matches the filter.
     * @param {TokenBlackListFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tokenBlackList = await prisma.tokenBlackList.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TokenBlackListFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TokenBlackList.
     * @param {TokenBlackListAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tokenBlackList = await prisma.tokenBlackList.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TokenBlackListAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of TokenBlackLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenBlackListCountArgs} args - Arguments to filter TokenBlackLists to count.
     * @example
     * // Count the number of TokenBlackLists
     * const count = await prisma.tokenBlackList.count({
     *   where: {
     *     // ... the filter for the TokenBlackLists we want to count
     *   }
     * })
    **/
    count<T extends TokenBlackListCountArgs>(
      args?: Subset<T, TokenBlackListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenBlackListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TokenBlackList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenBlackListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenBlackListAggregateArgs>(args: Subset<T, TokenBlackListAggregateArgs>): Prisma.PrismaPromise<GetTokenBlackListAggregateType<T>>

    /**
     * Group by TokenBlackList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenBlackListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenBlackListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenBlackListGroupByArgs['orderBy'] }
        : { orderBy?: TokenBlackListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenBlackListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenBlackListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TokenBlackList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TokenBlackListClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TokenBlackList base type for findUnique actions
   */
  export type TokenBlackListFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TokenBlackList
     */
    select?: TokenBlackListSelect | null
    /**
     * Filter, which TokenBlackList to fetch.
     */
    where: TokenBlackListWhereUniqueInput
  }

  /**
   * TokenBlackList findUnique
   */
  export interface TokenBlackListFindUniqueArgs extends TokenBlackListFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TokenBlackList findUniqueOrThrow
   */
  export type TokenBlackListFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TokenBlackList
     */
    select?: TokenBlackListSelect | null
    /**
     * Filter, which TokenBlackList to fetch.
     */
    where: TokenBlackListWhereUniqueInput
  }


  /**
   * TokenBlackList base type for findFirst actions
   */
  export type TokenBlackListFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TokenBlackList
     */
    select?: TokenBlackListSelect | null
    /**
     * Filter, which TokenBlackList to fetch.
     */
    where?: TokenBlackListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenBlackLists to fetch.
     */
    orderBy?: Enumerable<TokenBlackListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenBlackLists.
     */
    cursor?: TokenBlackListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenBlackLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenBlackLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenBlackLists.
     */
    distinct?: Enumerable<TokenBlackListScalarFieldEnum>
  }

  /**
   * TokenBlackList findFirst
   */
  export interface TokenBlackListFindFirstArgs extends TokenBlackListFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TokenBlackList findFirstOrThrow
   */
  export type TokenBlackListFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TokenBlackList
     */
    select?: TokenBlackListSelect | null
    /**
     * Filter, which TokenBlackList to fetch.
     */
    where?: TokenBlackListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenBlackLists to fetch.
     */
    orderBy?: Enumerable<TokenBlackListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenBlackLists.
     */
    cursor?: TokenBlackListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenBlackLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenBlackLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenBlackLists.
     */
    distinct?: Enumerable<TokenBlackListScalarFieldEnum>
  }


  /**
   * TokenBlackList findMany
   */
  export type TokenBlackListFindManyArgs = {
    /**
     * Select specific fields to fetch from the TokenBlackList
     */
    select?: TokenBlackListSelect | null
    /**
     * Filter, which TokenBlackLists to fetch.
     */
    where?: TokenBlackListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenBlackLists to fetch.
     */
    orderBy?: Enumerable<TokenBlackListOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TokenBlackLists.
     */
    cursor?: TokenBlackListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenBlackLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenBlackLists.
     */
    skip?: number
    distinct?: Enumerable<TokenBlackListScalarFieldEnum>
  }


  /**
   * TokenBlackList create
   */
  export type TokenBlackListCreateArgs = {
    /**
     * Select specific fields to fetch from the TokenBlackList
     */
    select?: TokenBlackListSelect | null
    /**
     * The data needed to create a TokenBlackList.
     */
    data: XOR<TokenBlackListCreateInput, TokenBlackListUncheckedCreateInput>
  }


  /**
   * TokenBlackList createMany
   */
  export type TokenBlackListCreateManyArgs = {
    /**
     * The data used to create many TokenBlackLists.
     */
    data: Enumerable<TokenBlackListCreateManyInput>
  }


  /**
   * TokenBlackList update
   */
  export type TokenBlackListUpdateArgs = {
    /**
     * Select specific fields to fetch from the TokenBlackList
     */
    select?: TokenBlackListSelect | null
    /**
     * The data needed to update a TokenBlackList.
     */
    data: XOR<TokenBlackListUpdateInput, TokenBlackListUncheckedUpdateInput>
    /**
     * Choose, which TokenBlackList to update.
     */
    where: TokenBlackListWhereUniqueInput
  }


  /**
   * TokenBlackList updateMany
   */
  export type TokenBlackListUpdateManyArgs = {
    /**
     * The data used to update TokenBlackLists.
     */
    data: XOR<TokenBlackListUpdateManyMutationInput, TokenBlackListUncheckedUpdateManyInput>
    /**
     * Filter which TokenBlackLists to update
     */
    where?: TokenBlackListWhereInput
  }


  /**
   * TokenBlackList upsert
   */
  export type TokenBlackListUpsertArgs = {
    /**
     * Select specific fields to fetch from the TokenBlackList
     */
    select?: TokenBlackListSelect | null
    /**
     * The filter to search for the TokenBlackList to update in case it exists.
     */
    where: TokenBlackListWhereUniqueInput
    /**
     * In case the TokenBlackList found by the `where` argument doesn't exist, create a new TokenBlackList with this data.
     */
    create: XOR<TokenBlackListCreateInput, TokenBlackListUncheckedCreateInput>
    /**
     * In case the TokenBlackList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenBlackListUpdateInput, TokenBlackListUncheckedUpdateInput>
  }


  /**
   * TokenBlackList delete
   */
  export type TokenBlackListDeleteArgs = {
    /**
     * Select specific fields to fetch from the TokenBlackList
     */
    select?: TokenBlackListSelect | null
    /**
     * Filter which TokenBlackList to delete.
     */
    where: TokenBlackListWhereUniqueInput
  }


  /**
   * TokenBlackList deleteMany
   */
  export type TokenBlackListDeleteManyArgs = {
    /**
     * Filter which TokenBlackLists to delete
     */
    where?: TokenBlackListWhereInput
  }


  /**
   * TokenBlackList findRaw
   */
  export type TokenBlackListFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TokenBlackList aggregateRaw
   */
  export type TokenBlackListAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TokenBlackList without action
   */
  export type TokenBlackListArgs = {
    /**
     * Select specific fields to fetch from the TokenBlackList
     */
    select?: TokenBlackListSelect | null
  }



  /**
   * Model Rule
   */


  export type AggregateRule = {
    _count: RuleCountAggregateOutputType | null
    _min: RuleMinAggregateOutputType | null
    _max: RuleMaxAggregateOutputType | null
  }

  export type RuleMinAggregateOutputType = {
    id: string | null
    name: string | null
    keyword: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RuleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    keyword: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RuleCountAggregateOutputType = {
    id: number
    name: number
    keyword: number
    permissionIDs: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RuleMinAggregateInputType = {
    id?: true
    name?: true
    keyword?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RuleMaxAggregateInputType = {
    id?: true
    name?: true
    keyword?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RuleCountAggregateInputType = {
    id?: true
    name?: true
    keyword?: true
    permissionIDs?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RuleAggregateArgs = {
    /**
     * Filter which Rule to aggregate.
     */
    where?: RuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rules to fetch.
     */
    orderBy?: Enumerable<RuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rules
    **/
    _count?: true | RuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RuleMaxAggregateInputType
  }

  export type GetRuleAggregateType<T extends RuleAggregateArgs> = {
        [P in keyof T & keyof AggregateRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRule[P]>
      : GetScalarType<T[P], AggregateRule[P]>
  }




  export type RuleGroupByArgs = {
    where?: RuleWhereInput
    orderBy?: Enumerable<RuleOrderByWithAggregationInput>
    by: RuleScalarFieldEnum[]
    having?: RuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RuleCountAggregateInputType | true
    _min?: RuleMinAggregateInputType
    _max?: RuleMaxAggregateInputType
  }


  export type RuleGroupByOutputType = {
    id: string
    name: string
    keyword: string
    permissionIDs: string[]
    createdAt: Date | null
    updatedAt: Date | null
    _count: RuleCountAggregateOutputType | null
    _min: RuleMinAggregateOutputType | null
    _max: RuleMaxAggregateOutputType | null
  }

  type GetRuleGroupByPayload<T extends RuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RuleGroupByOutputType[P]>
            : GetScalarType<T[P], RuleGroupByOutputType[P]>
        }
      >
    >


  export type RuleSelect = {
    id?: boolean
    name?: boolean
    keyword?: boolean
    permissionIDs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Rule$userArgs
    permissions?: boolean | Rule$permissionsArgs
    _count?: boolean | RuleCountOutputTypeArgs
  }


  export type RuleInclude = {
    user?: boolean | Rule$userArgs
    permissions?: boolean | Rule$permissionsArgs
    _count?: boolean | RuleCountOutputTypeArgs
  }

  export type RuleGetPayload<S extends boolean | null | undefined | RuleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Rule :
    S extends undefined ? never :
    S extends { include: any } & (RuleArgs | RuleFindManyArgs)
    ? Rule  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'permissions' ? Array < PermissionGetPayload<S['include'][P]>>  :
        P extends '_count' ? RuleCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RuleArgs | RuleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'permissions' ? Array < PermissionGetPayload<S['select'][P]>>  :
        P extends '_count' ? RuleCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Rule ? Rule[P] : never
  } 
      : Rule


  type RuleCountArgs = 
    Omit<RuleFindManyArgs, 'select' | 'include'> & {
      select?: RuleCountAggregateInputType | true
    }

  export interface RuleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Rule that matches the filter.
     * @param {RuleFindUniqueArgs} args - Arguments to find a Rule
     * @example
     * // Get one Rule
     * const rule = await prisma.rule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RuleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RuleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Rule'> extends True ? Prisma__RuleClient<RuleGetPayload<T>> : Prisma__RuleClient<RuleGetPayload<T> | null, null>

    /**
     * Find one Rule that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RuleFindUniqueOrThrowArgs} args - Arguments to find a Rule
     * @example
     * // Get one Rule
     * const rule = await prisma.rule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RuleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RuleFindUniqueOrThrowArgs>
    ): Prisma__RuleClient<RuleGetPayload<T>>

    /**
     * Find the first Rule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuleFindFirstArgs} args - Arguments to find a Rule
     * @example
     * // Get one Rule
     * const rule = await prisma.rule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RuleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RuleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Rule'> extends True ? Prisma__RuleClient<RuleGetPayload<T>> : Prisma__RuleClient<RuleGetPayload<T> | null, null>

    /**
     * Find the first Rule that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuleFindFirstOrThrowArgs} args - Arguments to find a Rule
     * @example
     * // Get one Rule
     * const rule = await prisma.rule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RuleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RuleFindFirstOrThrowArgs>
    ): Prisma__RuleClient<RuleGetPayload<T>>

    /**
     * Find zero or more Rules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rules
     * const rules = await prisma.rule.findMany()
     * 
     * // Get first 10 Rules
     * const rules = await prisma.rule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ruleWithIdOnly = await prisma.rule.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RuleFindManyArgs>(
      args?: SelectSubset<T, RuleFindManyArgs>
    ): Prisma.PrismaPromise<Array<RuleGetPayload<T>>>

    /**
     * Create a Rule.
     * @param {RuleCreateArgs} args - Arguments to create a Rule.
     * @example
     * // Create one Rule
     * const Rule = await prisma.rule.create({
     *   data: {
     *     // ... data to create a Rule
     *   }
     * })
     * 
    **/
    create<T extends RuleCreateArgs>(
      args: SelectSubset<T, RuleCreateArgs>
    ): Prisma__RuleClient<RuleGetPayload<T>>

    /**
     * Create many Rules.
     *     @param {RuleCreateManyArgs} args - Arguments to create many Rules.
     *     @example
     *     // Create many Rules
     *     const rule = await prisma.rule.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RuleCreateManyArgs>(
      args?: SelectSubset<T, RuleCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rule.
     * @param {RuleDeleteArgs} args - Arguments to delete one Rule.
     * @example
     * // Delete one Rule
     * const Rule = await prisma.rule.delete({
     *   where: {
     *     // ... filter to delete one Rule
     *   }
     * })
     * 
    **/
    delete<T extends RuleDeleteArgs>(
      args: SelectSubset<T, RuleDeleteArgs>
    ): Prisma__RuleClient<RuleGetPayload<T>>

    /**
     * Update one Rule.
     * @param {RuleUpdateArgs} args - Arguments to update one Rule.
     * @example
     * // Update one Rule
     * const rule = await prisma.rule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RuleUpdateArgs>(
      args: SelectSubset<T, RuleUpdateArgs>
    ): Prisma__RuleClient<RuleGetPayload<T>>

    /**
     * Delete zero or more Rules.
     * @param {RuleDeleteManyArgs} args - Arguments to filter Rules to delete.
     * @example
     * // Delete a few Rules
     * const { count } = await prisma.rule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RuleDeleteManyArgs>(
      args?: SelectSubset<T, RuleDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rules
     * const rule = await prisma.rule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RuleUpdateManyArgs>(
      args: SelectSubset<T, RuleUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rule.
     * @param {RuleUpsertArgs} args - Arguments to update or create a Rule.
     * @example
     * // Update or create a Rule
     * const rule = await prisma.rule.upsert({
     *   create: {
     *     // ... data to create a Rule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rule we want to update
     *   }
     * })
    **/
    upsert<T extends RuleUpsertArgs>(
      args: SelectSubset<T, RuleUpsertArgs>
    ): Prisma__RuleClient<RuleGetPayload<T>>

    /**
     * Find zero or more Rules that matches the filter.
     * @param {RuleFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const rule = await prisma.rule.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: RuleFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Rule.
     * @param {RuleAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const rule = await prisma.rule.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: RuleAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Rules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuleCountArgs} args - Arguments to filter Rules to count.
     * @example
     * // Count the number of Rules
     * const count = await prisma.rule.count({
     *   where: {
     *     // ... the filter for the Rules we want to count
     *   }
     * })
    **/
    count<T extends RuleCountArgs>(
      args?: Subset<T, RuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RuleAggregateArgs>(args: Subset<T, RuleAggregateArgs>): Prisma.PrismaPromise<GetRuleAggregateType<T>>

    /**
     * Group by Rule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RuleGroupByArgs['orderBy'] }
        : { orderBy?: RuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Rule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RuleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends Rule$userArgs= {}>(args?: Subset<T, Rule$userArgs>): Prisma.PrismaPromise<Array<UserGetPayload<T>>| Null>;

    permissions<T extends Rule$permissionsArgs= {}>(args?: Subset<T, Rule$permissionsArgs>): Prisma.PrismaPromise<Array<PermissionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Rule base type for findUnique actions
   */
  export type RuleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RuleInclude | null
    /**
     * Filter, which Rule to fetch.
     */
    where: RuleWhereUniqueInput
  }

  /**
   * Rule findUnique
   */
  export interface RuleFindUniqueArgs extends RuleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Rule findUniqueOrThrow
   */
  export type RuleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RuleInclude | null
    /**
     * Filter, which Rule to fetch.
     */
    where: RuleWhereUniqueInput
  }


  /**
   * Rule base type for findFirst actions
   */
  export type RuleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RuleInclude | null
    /**
     * Filter, which Rule to fetch.
     */
    where?: RuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rules to fetch.
     */
    orderBy?: Enumerable<RuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rules.
     */
    cursor?: RuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rules.
     */
    distinct?: Enumerable<RuleScalarFieldEnum>
  }

  /**
   * Rule findFirst
   */
  export interface RuleFindFirstArgs extends RuleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Rule findFirstOrThrow
   */
  export type RuleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RuleInclude | null
    /**
     * Filter, which Rule to fetch.
     */
    where?: RuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rules to fetch.
     */
    orderBy?: Enumerable<RuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rules.
     */
    cursor?: RuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rules.
     */
    distinct?: Enumerable<RuleScalarFieldEnum>
  }


  /**
   * Rule findMany
   */
  export type RuleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RuleInclude | null
    /**
     * Filter, which Rules to fetch.
     */
    where?: RuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rules to fetch.
     */
    orderBy?: Enumerable<RuleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rules.
     */
    cursor?: RuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rules.
     */
    skip?: number
    distinct?: Enumerable<RuleScalarFieldEnum>
  }


  /**
   * Rule create
   */
  export type RuleCreateArgs = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RuleInclude | null
    /**
     * The data needed to create a Rule.
     */
    data: XOR<RuleCreateInput, RuleUncheckedCreateInput>
  }


  /**
   * Rule createMany
   */
  export type RuleCreateManyArgs = {
    /**
     * The data used to create many Rules.
     */
    data: Enumerable<RuleCreateManyInput>
  }


  /**
   * Rule update
   */
  export type RuleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RuleInclude | null
    /**
     * The data needed to update a Rule.
     */
    data: XOR<RuleUpdateInput, RuleUncheckedUpdateInput>
    /**
     * Choose, which Rule to update.
     */
    where: RuleWhereUniqueInput
  }


  /**
   * Rule updateMany
   */
  export type RuleUpdateManyArgs = {
    /**
     * The data used to update Rules.
     */
    data: XOR<RuleUpdateManyMutationInput, RuleUncheckedUpdateManyInput>
    /**
     * Filter which Rules to update
     */
    where?: RuleWhereInput
  }


  /**
   * Rule upsert
   */
  export type RuleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RuleInclude | null
    /**
     * The filter to search for the Rule to update in case it exists.
     */
    where: RuleWhereUniqueInput
    /**
     * In case the Rule found by the `where` argument doesn't exist, create a new Rule with this data.
     */
    create: XOR<RuleCreateInput, RuleUncheckedCreateInput>
    /**
     * In case the Rule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RuleUpdateInput, RuleUncheckedUpdateInput>
  }


  /**
   * Rule delete
   */
  export type RuleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RuleInclude | null
    /**
     * Filter which Rule to delete.
     */
    where: RuleWhereUniqueInput
  }


  /**
   * Rule deleteMany
   */
  export type RuleDeleteManyArgs = {
    /**
     * Filter which Rules to delete
     */
    where?: RuleWhereInput
  }


  /**
   * Rule findRaw
   */
  export type RuleFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Rule aggregateRaw
   */
  export type RuleAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Rule.user
   */
  export type Rule$userArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Rule.permissions
   */
  export type Rule$permissionsArgs = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude | null
    where?: PermissionWhereInput
    orderBy?: Enumerable<PermissionOrderByWithRelationInput>
    cursor?: PermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PermissionScalarFieldEnum>
  }


  /**
   * Rule without action
   */
  export type RuleArgs = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RuleInclude | null
  }



  /**
   * Model Permission
   */


  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    name: EnumPermission | null
    keyword: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    name: EnumPermission | null
    keyword: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    keyword: number
    rulesIDs: number
    modelsIDs: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    keyword?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    keyword?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    keyword?: true
    rulesIDs?: true
    modelsIDs?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: Enumerable<PermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs = {
    where?: PermissionWhereInput
    orderBy?: Enumerable<PermissionOrderByWithAggregationInput>
    by: PermissionScalarFieldEnum[]
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }


  export type PermissionGroupByOutputType = {
    id: string
    name: EnumPermission
    keyword: string
    rulesIDs: string[]
    modelsIDs: string[]
    createdAt: Date | null
    updatedAt: Date | null
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect = {
    id?: boolean
    name?: boolean
    keyword?: boolean
    rulesIDs?: boolean
    modelsIDs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rules?: boolean | Permission$rulesArgs
    models?: boolean | Permission$modelsArgs
    _count?: boolean | PermissionCountOutputTypeArgs
  }


  export type PermissionInclude = {
    rules?: boolean | Permission$rulesArgs
    models?: boolean | Permission$modelsArgs
    _count?: boolean | PermissionCountOutputTypeArgs
  }

  export type PermissionGetPayload<S extends boolean | null | undefined | PermissionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Permission :
    S extends undefined ? never :
    S extends { include: any } & (PermissionArgs | PermissionFindManyArgs)
    ? Permission  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'rules' ? Array < RuleGetPayload<S['include'][P]>>  :
        P extends 'models' ? Array < ModelGetPayload<S['include'][P]>>  :
        P extends '_count' ? PermissionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PermissionArgs | PermissionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'rules' ? Array < RuleGetPayload<S['select'][P]>>  :
        P extends 'models' ? Array < ModelGetPayload<S['select'][P]>>  :
        P extends '_count' ? PermissionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Permission ? Permission[P] : never
  } 
      : Permission


  type PermissionCountArgs = 
    Omit<PermissionFindManyArgs, 'select' | 'include'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PermissionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PermissionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Permission'> extends True ? Prisma__PermissionClient<PermissionGetPayload<T>> : Prisma__PermissionClient<PermissionGetPayload<T> | null, null>

    /**
     * Find one Permission that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PermissionFindUniqueOrThrowArgs>
    ): Prisma__PermissionClient<PermissionGetPayload<T>>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PermissionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PermissionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Permission'> extends True ? Prisma__PermissionClient<PermissionGetPayload<T>> : Prisma__PermissionClient<PermissionGetPayload<T> | null, null>

    /**
     * Find the first Permission that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PermissionFindFirstOrThrowArgs>
    ): Prisma__PermissionClient<PermissionGetPayload<T>>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PermissionFindManyArgs>(
      args?: SelectSubset<T, PermissionFindManyArgs>
    ): Prisma.PrismaPromise<Array<PermissionGetPayload<T>>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
    **/
    create<T extends PermissionCreateArgs>(
      args: SelectSubset<T, PermissionCreateArgs>
    ): Prisma__PermissionClient<PermissionGetPayload<T>>

    /**
     * Create many Permissions.
     *     @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     *     @example
     *     // Create many Permissions
     *     const permission = await prisma.permission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PermissionCreateManyArgs>(
      args?: SelectSubset<T, PermissionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
    **/
    delete<T extends PermissionDeleteArgs>(
      args: SelectSubset<T, PermissionDeleteArgs>
    ): Prisma__PermissionClient<PermissionGetPayload<T>>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PermissionUpdateArgs>(
      args: SelectSubset<T, PermissionUpdateArgs>
    ): Prisma__PermissionClient<PermissionGetPayload<T>>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PermissionDeleteManyArgs>(
      args?: SelectSubset<T, PermissionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PermissionUpdateManyArgs>(
      args: SelectSubset<T, PermissionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
    **/
    upsert<T extends PermissionUpsertArgs>(
      args: SelectSubset<T, PermissionUpsertArgs>
    ): Prisma__PermissionClient<PermissionGetPayload<T>>

    /**
     * Find zero or more Permissions that matches the filter.
     * @param {PermissionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const permission = await prisma.permission.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: PermissionFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Permission.
     * @param {PermissionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const permission = await prisma.permission.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: PermissionAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PermissionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    rules<T extends Permission$rulesArgs= {}>(args?: Subset<T, Permission$rulesArgs>): Prisma.PrismaPromise<Array<RuleGetPayload<T>>| Null>;

    models<T extends Permission$modelsArgs= {}>(args?: Subset<T, Permission$modelsArgs>): Prisma.PrismaPromise<Array<ModelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Permission base type for findUnique actions
   */
  export type PermissionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUnique
   */
  export interface PermissionFindUniqueArgs extends PermissionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }


  /**
   * Permission base type for findFirst actions
   */
  export type PermissionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: Enumerable<PermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: Enumerable<PermissionScalarFieldEnum>
  }

  /**
   * Permission findFirst
   */
  export interface PermissionFindFirstArgs extends PermissionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: Enumerable<PermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: Enumerable<PermissionScalarFieldEnum>
  }


  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: Enumerable<PermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: Enumerable<PermissionScalarFieldEnum>
  }


  /**
   * Permission create
   */
  export type PermissionCreateArgs = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }


  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs = {
    /**
     * The data used to create many Permissions.
     */
    data: Enumerable<PermissionCreateManyInput>
  }


  /**
   * Permission update
   */
  export type PermissionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }


  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
  }


  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }


  /**
   * Permission delete
   */
  export type PermissionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }


  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
  }


  /**
   * Permission findRaw
   */
  export type PermissionFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Permission aggregateRaw
   */
  export type PermissionAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Permission.rules
   */
  export type Permission$rulesArgs = {
    /**
     * Select specific fields to fetch from the Rule
     */
    select?: RuleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RuleInclude | null
    where?: RuleWhereInput
    orderBy?: Enumerable<RuleOrderByWithRelationInput>
    cursor?: RuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<RuleScalarFieldEnum>
  }


  /**
   * Permission.models
   */
  export type Permission$modelsArgs = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModelInclude | null
    where?: ModelWhereInput
    orderBy?: Enumerable<ModelOrderByWithRelationInput>
    cursor?: ModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ModelScalarFieldEnum>
  }


  /**
   * Permission without action
   */
  export type PermissionArgs = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude | null
  }



  /**
   * Model Model
   */


  export type AggregateModel = {
    _count: ModelCountAggregateOutputType | null
    _min: ModelMinAggregateOutputType | null
    _max: ModelMaxAggregateOutputType | null
  }

  export type ModelMinAggregateOutputType = {
    id: string | null
    name: string | null
    keyword: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    keyword: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelCountAggregateOutputType = {
    id: number
    name: number
    keyword: number
    permissionIDs: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModelMinAggregateInputType = {
    id?: true
    name?: true
    keyword?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelMaxAggregateInputType = {
    id?: true
    name?: true
    keyword?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelCountAggregateInputType = {
    id?: true
    name?: true
    keyword?: true
    permissionIDs?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModelAggregateArgs = {
    /**
     * Filter which Model to aggregate.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: Enumerable<ModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Models
    **/
    _count?: true | ModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelMaxAggregateInputType
  }

  export type GetModelAggregateType<T extends ModelAggregateArgs> = {
        [P in keyof T & keyof AggregateModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModel[P]>
      : GetScalarType<T[P], AggregateModel[P]>
  }




  export type ModelGroupByArgs = {
    where?: ModelWhereInput
    orderBy?: Enumerable<ModelOrderByWithAggregationInput>
    by: ModelScalarFieldEnum[]
    having?: ModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelCountAggregateInputType | true
    _min?: ModelMinAggregateInputType
    _max?: ModelMaxAggregateInputType
  }


  export type ModelGroupByOutputType = {
    id: string
    name: string
    keyword: string
    permissionIDs: string[]
    createdAt: Date | null
    updatedAt: Date | null
    _count: ModelCountAggregateOutputType | null
    _min: ModelMinAggregateOutputType | null
    _max: ModelMaxAggregateOutputType | null
  }

  type GetModelGroupByPayload<T extends ModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelGroupByOutputType[P]>
            : GetScalarType<T[P], ModelGroupByOutputType[P]>
        }
      >
    >


  export type ModelSelect = {
    id?: boolean
    name?: boolean
    keyword?: boolean
    permissionIDs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissions?: boolean | Model$permissionsArgs
    _count?: boolean | ModelCountOutputTypeArgs
  }


  export type ModelInclude = {
    permissions?: boolean | Model$permissionsArgs
    _count?: boolean | ModelCountOutputTypeArgs
  }

  export type ModelGetPayload<S extends boolean | null | undefined | ModelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Model :
    S extends undefined ? never :
    S extends { include: any } & (ModelArgs | ModelFindManyArgs)
    ? Model  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'permissions' ? Array < PermissionGetPayload<S['include'][P]>>  :
        P extends '_count' ? ModelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ModelArgs | ModelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'permissions' ? Array < PermissionGetPayload<S['select'][P]>>  :
        P extends '_count' ? ModelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Model ? Model[P] : never
  } 
      : Model


  type ModelCountArgs = 
    Omit<ModelFindManyArgs, 'select' | 'include'> & {
      select?: ModelCountAggregateInputType | true
    }

  export interface ModelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Model that matches the filter.
     * @param {ModelFindUniqueArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ModelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ModelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Model'> extends True ? Prisma__ModelClient<ModelGetPayload<T>> : Prisma__ModelClient<ModelGetPayload<T> | null, null>

    /**
     * Find one Model that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ModelFindUniqueOrThrowArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ModelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ModelFindUniqueOrThrowArgs>
    ): Prisma__ModelClient<ModelGetPayload<T>>

    /**
     * Find the first Model that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindFirstArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ModelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ModelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Model'> extends True ? Prisma__ModelClient<ModelGetPayload<T>> : Prisma__ModelClient<ModelGetPayload<T> | null, null>

    /**
     * Find the first Model that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindFirstOrThrowArgs} args - Arguments to find a Model
     * @example
     * // Get one Model
     * const model = await prisma.model.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ModelFindFirstOrThrowArgs>
    ): Prisma__ModelClient<ModelGetPayload<T>>

    /**
     * Find zero or more Models that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Models
     * const models = await prisma.model.findMany()
     * 
     * // Get first 10 Models
     * const models = await prisma.model.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelWithIdOnly = await prisma.model.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ModelFindManyArgs>(
      args?: SelectSubset<T, ModelFindManyArgs>
    ): Prisma.PrismaPromise<Array<ModelGetPayload<T>>>

    /**
     * Create a Model.
     * @param {ModelCreateArgs} args - Arguments to create a Model.
     * @example
     * // Create one Model
     * const Model = await prisma.model.create({
     *   data: {
     *     // ... data to create a Model
     *   }
     * })
     * 
    **/
    create<T extends ModelCreateArgs>(
      args: SelectSubset<T, ModelCreateArgs>
    ): Prisma__ModelClient<ModelGetPayload<T>>

    /**
     * Create many Models.
     *     @param {ModelCreateManyArgs} args - Arguments to create many Models.
     *     @example
     *     // Create many Models
     *     const model = await prisma.model.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ModelCreateManyArgs>(
      args?: SelectSubset<T, ModelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Model.
     * @param {ModelDeleteArgs} args - Arguments to delete one Model.
     * @example
     * // Delete one Model
     * const Model = await prisma.model.delete({
     *   where: {
     *     // ... filter to delete one Model
     *   }
     * })
     * 
    **/
    delete<T extends ModelDeleteArgs>(
      args: SelectSubset<T, ModelDeleteArgs>
    ): Prisma__ModelClient<ModelGetPayload<T>>

    /**
     * Update one Model.
     * @param {ModelUpdateArgs} args - Arguments to update one Model.
     * @example
     * // Update one Model
     * const model = await prisma.model.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ModelUpdateArgs>(
      args: SelectSubset<T, ModelUpdateArgs>
    ): Prisma__ModelClient<ModelGetPayload<T>>

    /**
     * Delete zero or more Models.
     * @param {ModelDeleteManyArgs} args - Arguments to filter Models to delete.
     * @example
     * // Delete a few Models
     * const { count } = await prisma.model.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ModelDeleteManyArgs>(
      args?: SelectSubset<T, ModelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Models
     * const model = await prisma.model.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ModelUpdateManyArgs>(
      args: SelectSubset<T, ModelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Model.
     * @param {ModelUpsertArgs} args - Arguments to update or create a Model.
     * @example
     * // Update or create a Model
     * const model = await prisma.model.upsert({
     *   create: {
     *     // ... data to create a Model
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Model we want to update
     *   }
     * })
    **/
    upsert<T extends ModelUpsertArgs>(
      args: SelectSubset<T, ModelUpsertArgs>
    ): Prisma__ModelClient<ModelGetPayload<T>>

    /**
     * Find zero or more Models that matches the filter.
     * @param {ModelFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const model = await prisma.model.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ModelFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Model.
     * @param {ModelAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const model = await prisma.model.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ModelAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelCountArgs} args - Arguments to filter Models to count.
     * @example
     * // Count the number of Models
     * const count = await prisma.model.count({
     *   where: {
     *     // ... the filter for the Models we want to count
     *   }
     * })
    **/
    count<T extends ModelCountArgs>(
      args?: Subset<T, ModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Model.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelAggregateArgs>(args: Subset<T, ModelAggregateArgs>): Prisma.PrismaPromise<GetModelAggregateType<T>>

    /**
     * Group by Model.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelGroupByArgs['orderBy'] }
        : { orderBy?: ModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Model.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ModelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    permissions<T extends Model$permissionsArgs= {}>(args?: Subset<T, Model$permissionsArgs>): Prisma.PrismaPromise<Array<PermissionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Model base type for findUnique actions
   */
  export type ModelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModelInclude | null
    /**
     * Filter, which Model to fetch.
     */
    where: ModelWhereUniqueInput
  }

  /**
   * Model findUnique
   */
  export interface ModelFindUniqueArgs extends ModelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Model findUniqueOrThrow
   */
  export type ModelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModelInclude | null
    /**
     * Filter, which Model to fetch.
     */
    where: ModelWhereUniqueInput
  }


  /**
   * Model base type for findFirst actions
   */
  export type ModelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModelInclude | null
    /**
     * Filter, which Model to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: Enumerable<ModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Models.
     */
    distinct?: Enumerable<ModelScalarFieldEnum>
  }

  /**
   * Model findFirst
   */
  export interface ModelFindFirstArgs extends ModelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Model findFirstOrThrow
   */
  export type ModelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModelInclude | null
    /**
     * Filter, which Model to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: Enumerable<ModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Models.
     */
    distinct?: Enumerable<ModelScalarFieldEnum>
  }


  /**
   * Model findMany
   */
  export type ModelFindManyArgs = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModelInclude | null
    /**
     * Filter, which Models to fetch.
     */
    where?: ModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Models to fetch.
     */
    orderBy?: Enumerable<ModelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Models.
     */
    cursor?: ModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Models.
     */
    skip?: number
    distinct?: Enumerable<ModelScalarFieldEnum>
  }


  /**
   * Model create
   */
  export type ModelCreateArgs = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModelInclude | null
    /**
     * The data needed to create a Model.
     */
    data: XOR<ModelCreateInput, ModelUncheckedCreateInput>
  }


  /**
   * Model createMany
   */
  export type ModelCreateManyArgs = {
    /**
     * The data used to create many Models.
     */
    data: Enumerable<ModelCreateManyInput>
  }


  /**
   * Model update
   */
  export type ModelUpdateArgs = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModelInclude | null
    /**
     * The data needed to update a Model.
     */
    data: XOR<ModelUpdateInput, ModelUncheckedUpdateInput>
    /**
     * Choose, which Model to update.
     */
    where: ModelWhereUniqueInput
  }


  /**
   * Model updateMany
   */
  export type ModelUpdateManyArgs = {
    /**
     * The data used to update Models.
     */
    data: XOR<ModelUpdateManyMutationInput, ModelUncheckedUpdateManyInput>
    /**
     * Filter which Models to update
     */
    where?: ModelWhereInput
  }


  /**
   * Model upsert
   */
  export type ModelUpsertArgs = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModelInclude | null
    /**
     * The filter to search for the Model to update in case it exists.
     */
    where: ModelWhereUniqueInput
    /**
     * In case the Model found by the `where` argument doesn't exist, create a new Model with this data.
     */
    create: XOR<ModelCreateInput, ModelUncheckedCreateInput>
    /**
     * In case the Model was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelUpdateInput, ModelUncheckedUpdateInput>
  }


  /**
   * Model delete
   */
  export type ModelDeleteArgs = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModelInclude | null
    /**
     * Filter which Model to delete.
     */
    where: ModelWhereUniqueInput
  }


  /**
   * Model deleteMany
   */
  export type ModelDeleteManyArgs = {
    /**
     * Filter which Models to delete
     */
    where?: ModelWhereInput
  }


  /**
   * Model findRaw
   */
  export type ModelFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Model aggregateRaw
   */
  export type ModelAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Model.permissions
   */
  export type Model$permissionsArgs = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PermissionInclude | null
    where?: PermissionWhereInput
    orderBy?: Enumerable<PermissionOrderByWithRelationInput>
    cursor?: PermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PermissionScalarFieldEnum>
  }


  /**
   * Model without action
   */
  export type ModelArgs = {
    /**
     * Select specific fields to fetch from the Model
     */
    select?: ModelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModelInclude | null
  }



  /**
   * Model Address
   */


  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    id: string | null
    firstAdress: string | null
    secondAdress: string | null
    zipCode: string | null
    city: string | null
    region: string | null
    country: string | null
    additionnalInformation: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    id: string | null
    firstAdress: string | null
    secondAdress: string | null
    zipCode: string | null
    city: string | null
    region: string | null
    country: string | null
    additionnalInformation: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    firstAdress: number
    secondAdress: number
    zipCode: number
    city: number
    region: number
    country: number
    additionnalInformation: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    id?: true
    firstAdress?: true
    secondAdress?: true
    zipCode?: true
    city?: true
    region?: true
    country?: true
    additionnalInformation?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    firstAdress?: true
    secondAdress?: true
    zipCode?: true
    city?: true
    region?: true
    country?: true
    additionnalInformation?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    firstAdress?: true
    secondAdress?: true
    zipCode?: true
    city?: true
    region?: true
    country?: true
    additionnalInformation?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddressAggregateArgs = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs = {
    where?: AddressWhereInput
    orderBy?: Enumerable<AddressOrderByWithAggregationInput>
    by: AddressScalarFieldEnum[]
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }


  export type AddressGroupByOutputType = {
    id: string
    firstAdress: string
    secondAdress: string | null
    zipCode: string
    city: string
    region: string
    country: string
    additionnalInformation: string | null
    userId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect = {
    id?: boolean
    firstAdress?: boolean
    secondAdress?: boolean
    zipCode?: boolean
    city?: boolean
    region?: boolean
    country?: boolean
    additionnalInformation?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
  }


  export type AddressInclude = {
    user?: boolean | UserArgs
  }

  export type AddressGetPayload<S extends boolean | null | undefined | AddressArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Address :
    S extends undefined ? never :
    S extends { include: any } & (AddressArgs | AddressFindManyArgs)
    ? Address  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AddressArgs | AddressFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Address ? Address[P] : never
  } 
      : Address


  type AddressCountArgs = 
    Omit<AddressFindManyArgs, 'select' | 'include'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Address'> extends True ? Prisma__AddressClient<AddressGetPayload<T>> : Prisma__AddressClient<AddressGetPayload<T> | null, null>

    /**
     * Find one Address that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AddressFindUniqueOrThrowArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Address'> extends True ? Prisma__AddressClient<AddressGetPayload<T>> : Prisma__AddressClient<AddressGetPayload<T> | null, null>

    /**
     * Find the first Address that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AddressFindFirstOrThrowArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AddressFindManyArgs>(
      args?: SelectSubset<T, AddressFindManyArgs>
    ): Prisma.PrismaPromise<Array<AddressGetPayload<T>>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
    **/
    create<T extends AddressCreateArgs>(
      args: SelectSubset<T, AddressCreateArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Create many Addresses.
     *     @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const address = await prisma.address.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AddressCreateManyArgs>(
      args?: SelectSubset<T, AddressCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
    **/
    delete<T extends AddressDeleteArgs>(
      args: SelectSubset<T, AddressDeleteArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddressUpdateArgs>(
      args: SelectSubset<T, AddressUpdateArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddressDeleteManyArgs>(
      args?: SelectSubset<T, AddressDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddressUpdateManyArgs>(
      args: SelectSubset<T, AddressUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
    **/
    upsert<T extends AddressUpsertArgs>(
      args: SelectSubset<T, AddressUpsertArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Find zero or more Addresses that matches the filter.
     * @param {AddressFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const address = await prisma.address.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: AddressFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Address.
     * @param {AddressAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const address = await prisma.address.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: AddressAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AddressClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Address base type for findUnique actions
   */
  export type AddressFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUnique
   */
  export interface AddressFindUniqueArgs extends AddressFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }


  /**
   * Address base type for findFirst actions
   */
  export type AddressFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: Enumerable<AddressScalarFieldEnum>
  }

  /**
   * Address findFirst
   */
  export interface AddressFindFirstArgs extends AddressFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address findMany
   */
  export type AddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address create
   */
  export type AddressCreateArgs = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }


  /**
   * Address createMany
   */
  export type AddressCreateManyArgs = {
    /**
     * The data used to create many Addresses.
     */
    data: Enumerable<AddressCreateManyInput>
  }


  /**
   * Address update
   */
  export type AddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }


  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
  }


  /**
   * Address upsert
   */
  export type AddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }


  /**
   * Address delete
   */
  export type AddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }


  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
  }


  /**
   * Address findRaw
   */
  export type AddressFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Address aggregateRaw
   */
  export type AddressAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Address without action
   */
  export type AddressArgs = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
  }



  /**
   * Model Wallet
   */


  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletAvgAggregateOutputType = {
    balance: number | null
  }

  export type WalletSumAggregateOutputType = {
    balance: number | null
  }

  export type WalletMinAggregateOutputType = {
    id: string | null
    balance: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletMaxAggregateOutputType = {
    id: string | null
    balance: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    balance: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WalletAvgAggregateInputType = {
    balance?: true
  }

  export type WalletSumAggregateInputType = {
    balance?: true
  }

  export type WalletMinAggregateInputType = {
    id?: true
    balance?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    balance?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    balance?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WalletAggregateArgs = {
    /**
     * Filter which Wallet to aggregate.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: Enumerable<WalletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type WalletGroupByArgs = {
    where?: WalletWhereInput
    orderBy?: Enumerable<WalletOrderByWithAggregationInput>
    by: WalletScalarFieldEnum[]
    having?: WalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _avg?: WalletAvgAggregateInputType
    _sum?: WalletSumAggregateInputType
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }


  export type WalletGroupByOutputType = {
    id: string
    balance: number
    userId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends WalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type WalletSelect = {
    id?: boolean
    balance?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
    transaction?: boolean | Wallet$transactionArgs
    _count?: boolean | WalletCountOutputTypeArgs
  }


  export type WalletInclude = {
    user?: boolean | UserArgs
    transaction?: boolean | Wallet$transactionArgs
    _count?: boolean | WalletCountOutputTypeArgs
  }

  export type WalletGetPayload<S extends boolean | null | undefined | WalletArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Wallet :
    S extends undefined ? never :
    S extends { include: any } & (WalletArgs | WalletFindManyArgs)
    ? Wallet  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'transaction' ? Array < TransactionGetPayload<S['include'][P]>>  :
        P extends '_count' ? WalletCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WalletArgs | WalletFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'transaction' ? Array < TransactionGetPayload<S['select'][P]>>  :
        P extends '_count' ? WalletCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Wallet ? Wallet[P] : never
  } 
      : Wallet


  type WalletCountArgs = 
    Omit<WalletFindManyArgs, 'select' | 'include'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface WalletDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Wallet that matches the filter.
     * @param {WalletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WalletFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WalletFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Wallet'> extends True ? Prisma__WalletClient<WalletGetPayload<T>> : Prisma__WalletClient<WalletGetPayload<T> | null, null>

    /**
     * Find one Wallet that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WalletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WalletFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WalletFindUniqueOrThrowArgs>
    ): Prisma__WalletClient<WalletGetPayload<T>>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WalletFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WalletFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Wallet'> extends True ? Prisma__WalletClient<WalletGetPayload<T>> : Prisma__WalletClient<WalletGetPayload<T> | null, null>

    /**
     * Find the first Wallet that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WalletFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WalletFindFirstOrThrowArgs>
    ): Prisma__WalletClient<WalletGetPayload<T>>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WalletFindManyArgs>(
      args?: SelectSubset<T, WalletFindManyArgs>
    ): Prisma.PrismaPromise<Array<WalletGetPayload<T>>>

    /**
     * Create a Wallet.
     * @param {WalletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
    **/
    create<T extends WalletCreateArgs>(
      args: SelectSubset<T, WalletCreateArgs>
    ): Prisma__WalletClient<WalletGetPayload<T>>

    /**
     * Create many Wallets.
     *     @param {WalletCreateManyArgs} args - Arguments to create many Wallets.
     *     @example
     *     // Create many Wallets
     *     const wallet = await prisma.wallet.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WalletCreateManyArgs>(
      args?: SelectSubset<T, WalletCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Wallet.
     * @param {WalletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
    **/
    delete<T extends WalletDeleteArgs>(
      args: SelectSubset<T, WalletDeleteArgs>
    ): Prisma__WalletClient<WalletGetPayload<T>>

    /**
     * Update one Wallet.
     * @param {WalletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WalletUpdateArgs>(
      args: SelectSubset<T, WalletUpdateArgs>
    ): Prisma__WalletClient<WalletGetPayload<T>>

    /**
     * Delete zero or more Wallets.
     * @param {WalletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WalletDeleteManyArgs>(
      args?: SelectSubset<T, WalletDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WalletUpdateManyArgs>(
      args: SelectSubset<T, WalletUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet.
     * @param {WalletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
    **/
    upsert<T extends WalletUpsertArgs>(
      args: SelectSubset<T, WalletUpsertArgs>
    ): Prisma__WalletClient<WalletGetPayload<T>>

    /**
     * Find zero or more Wallets that matches the filter.
     * @param {WalletFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const wallet = await prisma.wallet.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: WalletFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Wallet.
     * @param {WalletAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const wallet = await prisma.wallet.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: WalletAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends WalletCountArgs>(
      args?: Subset<T, WalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletGroupByArgs['orderBy'] }
        : { orderBy?: WalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WalletClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    transaction<T extends Wallet$transactionArgs= {}>(args?: Subset<T, Wallet$transactionArgs>): Prisma.PrismaPromise<Array<TransactionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Wallet base type for findUnique actions
   */
  export type WalletFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WalletInclude | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findUnique
   */
  export interface WalletFindUniqueArgs extends WalletFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Wallet findUniqueOrThrow
   */
  export type WalletFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WalletInclude | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }


  /**
   * Wallet base type for findFirst actions
   */
  export type WalletFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WalletInclude | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: Enumerable<WalletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: Enumerable<WalletScalarFieldEnum>
  }

  /**
   * Wallet findFirst
   */
  export interface WalletFindFirstArgs extends WalletFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Wallet findFirstOrThrow
   */
  export type WalletFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WalletInclude | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: Enumerable<WalletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: Enumerable<WalletScalarFieldEnum>
  }


  /**
   * Wallet findMany
   */
  export type WalletFindManyArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WalletInclude | null
    /**
     * Filter, which Wallets to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: Enumerable<WalletOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    distinct?: Enumerable<WalletScalarFieldEnum>
  }


  /**
   * Wallet create
   */
  export type WalletCreateArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WalletInclude | null
    /**
     * The data needed to create a Wallet.
     */
    data: XOR<WalletCreateInput, WalletUncheckedCreateInput>
  }


  /**
   * Wallet createMany
   */
  export type WalletCreateManyArgs = {
    /**
     * The data used to create many Wallets.
     */
    data: Enumerable<WalletCreateManyInput>
  }


  /**
   * Wallet update
   */
  export type WalletUpdateArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WalletInclude | null
    /**
     * The data needed to update a Wallet.
     */
    data: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
    /**
     * Choose, which Wallet to update.
     */
    where: WalletWhereUniqueInput
  }


  /**
   * Wallet updateMany
   */
  export type WalletUpdateManyArgs = {
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
  }


  /**
   * Wallet upsert
   */
  export type WalletUpsertArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WalletInclude | null
    /**
     * The filter to search for the Wallet to update in case it exists.
     */
    where: WalletWhereUniqueInput
    /**
     * In case the Wallet found by the `where` argument doesn't exist, create a new Wallet with this data.
     */
    create: XOR<WalletCreateInput, WalletUncheckedCreateInput>
    /**
     * In case the Wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
  }


  /**
   * Wallet delete
   */
  export type WalletDeleteArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WalletInclude | null
    /**
     * Filter which Wallet to delete.
     */
    where: WalletWhereUniqueInput
  }


  /**
   * Wallet deleteMany
   */
  export type WalletDeleteManyArgs = {
    /**
     * Filter which Wallets to delete
     */
    where?: WalletWhereInput
  }


  /**
   * Wallet findRaw
   */
  export type WalletFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Wallet aggregateRaw
   */
  export type WalletAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Wallet.transaction
   */
  export type Wallet$transactionArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude | null
    where?: TransactionWhereInput
    orderBy?: Enumerable<TransactionOrderByWithRelationInput>
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * Wallet without action
   */
  export type WalletArgs = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WalletInclude | null
  }



  /**
   * Model BoxType
   */


  export type AggregateBoxType = {
    _count: BoxTypeCountAggregateOutputType | null
    _min: BoxTypeMinAggregateOutputType | null
    _max: BoxTypeMaxAggregateOutputType | null
  }

  export type BoxTypeMinAggregateOutputType = {
    id: string | null
    reference: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BoxTypeMaxAggregateOutputType = {
    id: string | null
    reference: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BoxTypeCountAggregateOutputType = {
    id: number
    reference: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BoxTypeMinAggregateInputType = {
    id?: true
    reference?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BoxTypeMaxAggregateInputType = {
    id?: true
    reference?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BoxTypeCountAggregateInputType = {
    id?: true
    reference?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BoxTypeAggregateArgs = {
    /**
     * Filter which BoxType to aggregate.
     */
    where?: BoxTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoxTypes to fetch.
     */
    orderBy?: Enumerable<BoxTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoxTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoxTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoxTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoxTypes
    **/
    _count?: true | BoxTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoxTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoxTypeMaxAggregateInputType
  }

  export type GetBoxTypeAggregateType<T extends BoxTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateBoxType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoxType[P]>
      : GetScalarType<T[P], AggregateBoxType[P]>
  }




  export type BoxTypeGroupByArgs = {
    where?: BoxTypeWhereInput
    orderBy?: Enumerable<BoxTypeOrderByWithAggregationInput>
    by: BoxTypeScalarFieldEnum[]
    having?: BoxTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoxTypeCountAggregateInputType | true
    _min?: BoxTypeMinAggregateInputType
    _max?: BoxTypeMaxAggregateInputType
  }


  export type BoxTypeGroupByOutputType = {
    id: string
    reference: string
    name: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: BoxTypeCountAggregateOutputType | null
    _min: BoxTypeMinAggregateOutputType | null
    _max: BoxTypeMaxAggregateOutputType | null
  }

  type GetBoxTypeGroupByPayload<T extends BoxTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BoxTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoxTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoxTypeGroupByOutputType[P]>
            : GetScalarType<T[P], BoxTypeGroupByOutputType[P]>
        }
      >
    >


  export type BoxTypeSelect = {
    id?: boolean
    reference?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    box?: boolean | BoxType$boxArgs
    _count?: boolean | BoxTypeCountOutputTypeArgs
  }


  export type BoxTypeInclude = {
    box?: boolean | BoxType$boxArgs
    _count?: boolean | BoxTypeCountOutputTypeArgs
  }

  export type BoxTypeGetPayload<S extends boolean | null | undefined | BoxTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BoxType :
    S extends undefined ? never :
    S extends { include: any } & (BoxTypeArgs | BoxTypeFindManyArgs)
    ? BoxType  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'box' ? Array < BoxGetPayload<S['include'][P]>>  :
        P extends '_count' ? BoxTypeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BoxTypeArgs | BoxTypeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'box' ? Array < BoxGetPayload<S['select'][P]>>  :
        P extends '_count' ? BoxTypeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof BoxType ? BoxType[P] : never
  } 
      : BoxType


  type BoxTypeCountArgs = 
    Omit<BoxTypeFindManyArgs, 'select' | 'include'> & {
      select?: BoxTypeCountAggregateInputType | true
    }

  export interface BoxTypeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BoxType that matches the filter.
     * @param {BoxTypeFindUniqueArgs} args - Arguments to find a BoxType
     * @example
     * // Get one BoxType
     * const boxType = await prisma.boxType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BoxTypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BoxTypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BoxType'> extends True ? Prisma__BoxTypeClient<BoxTypeGetPayload<T>> : Prisma__BoxTypeClient<BoxTypeGetPayload<T> | null, null>

    /**
     * Find one BoxType that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BoxTypeFindUniqueOrThrowArgs} args - Arguments to find a BoxType
     * @example
     * // Get one BoxType
     * const boxType = await prisma.boxType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BoxTypeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BoxTypeFindUniqueOrThrowArgs>
    ): Prisma__BoxTypeClient<BoxTypeGetPayload<T>>

    /**
     * Find the first BoxType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxTypeFindFirstArgs} args - Arguments to find a BoxType
     * @example
     * // Get one BoxType
     * const boxType = await prisma.boxType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BoxTypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BoxTypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BoxType'> extends True ? Prisma__BoxTypeClient<BoxTypeGetPayload<T>> : Prisma__BoxTypeClient<BoxTypeGetPayload<T> | null, null>

    /**
     * Find the first BoxType that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxTypeFindFirstOrThrowArgs} args - Arguments to find a BoxType
     * @example
     * // Get one BoxType
     * const boxType = await prisma.boxType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BoxTypeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BoxTypeFindFirstOrThrowArgs>
    ): Prisma__BoxTypeClient<BoxTypeGetPayload<T>>

    /**
     * Find zero or more BoxTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxTypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoxTypes
     * const boxTypes = await prisma.boxType.findMany()
     * 
     * // Get first 10 BoxTypes
     * const boxTypes = await prisma.boxType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boxTypeWithIdOnly = await prisma.boxType.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BoxTypeFindManyArgs>(
      args?: SelectSubset<T, BoxTypeFindManyArgs>
    ): Prisma.PrismaPromise<Array<BoxTypeGetPayload<T>>>

    /**
     * Create a BoxType.
     * @param {BoxTypeCreateArgs} args - Arguments to create a BoxType.
     * @example
     * // Create one BoxType
     * const BoxType = await prisma.boxType.create({
     *   data: {
     *     // ... data to create a BoxType
     *   }
     * })
     * 
    **/
    create<T extends BoxTypeCreateArgs>(
      args: SelectSubset<T, BoxTypeCreateArgs>
    ): Prisma__BoxTypeClient<BoxTypeGetPayload<T>>

    /**
     * Create many BoxTypes.
     *     @param {BoxTypeCreateManyArgs} args - Arguments to create many BoxTypes.
     *     @example
     *     // Create many BoxTypes
     *     const boxType = await prisma.boxType.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BoxTypeCreateManyArgs>(
      args?: SelectSubset<T, BoxTypeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BoxType.
     * @param {BoxTypeDeleteArgs} args - Arguments to delete one BoxType.
     * @example
     * // Delete one BoxType
     * const BoxType = await prisma.boxType.delete({
     *   where: {
     *     // ... filter to delete one BoxType
     *   }
     * })
     * 
    **/
    delete<T extends BoxTypeDeleteArgs>(
      args: SelectSubset<T, BoxTypeDeleteArgs>
    ): Prisma__BoxTypeClient<BoxTypeGetPayload<T>>

    /**
     * Update one BoxType.
     * @param {BoxTypeUpdateArgs} args - Arguments to update one BoxType.
     * @example
     * // Update one BoxType
     * const boxType = await prisma.boxType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BoxTypeUpdateArgs>(
      args: SelectSubset<T, BoxTypeUpdateArgs>
    ): Prisma__BoxTypeClient<BoxTypeGetPayload<T>>

    /**
     * Delete zero or more BoxTypes.
     * @param {BoxTypeDeleteManyArgs} args - Arguments to filter BoxTypes to delete.
     * @example
     * // Delete a few BoxTypes
     * const { count } = await prisma.boxType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BoxTypeDeleteManyArgs>(
      args?: SelectSubset<T, BoxTypeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoxTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoxTypes
     * const boxType = await prisma.boxType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BoxTypeUpdateManyArgs>(
      args: SelectSubset<T, BoxTypeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BoxType.
     * @param {BoxTypeUpsertArgs} args - Arguments to update or create a BoxType.
     * @example
     * // Update or create a BoxType
     * const boxType = await prisma.boxType.upsert({
     *   create: {
     *     // ... data to create a BoxType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoxType we want to update
     *   }
     * })
    **/
    upsert<T extends BoxTypeUpsertArgs>(
      args: SelectSubset<T, BoxTypeUpsertArgs>
    ): Prisma__BoxTypeClient<BoxTypeGetPayload<T>>

    /**
     * Find zero or more BoxTypes that matches the filter.
     * @param {BoxTypeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const boxType = await prisma.boxType.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: BoxTypeFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a BoxType.
     * @param {BoxTypeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const boxType = await prisma.boxType.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: BoxTypeAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of BoxTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxTypeCountArgs} args - Arguments to filter BoxTypes to count.
     * @example
     * // Count the number of BoxTypes
     * const count = await prisma.boxType.count({
     *   where: {
     *     // ... the filter for the BoxTypes we want to count
     *   }
     * })
    **/
    count<T extends BoxTypeCountArgs>(
      args?: Subset<T, BoxTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoxTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoxType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoxTypeAggregateArgs>(args: Subset<T, BoxTypeAggregateArgs>): Prisma.PrismaPromise<GetBoxTypeAggregateType<T>>

    /**
     * Group by BoxType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoxTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoxTypeGroupByArgs['orderBy'] }
        : { orderBy?: BoxTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoxTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoxTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BoxType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BoxTypeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    box<T extends BoxType$boxArgs= {}>(args?: Subset<T, BoxType$boxArgs>): Prisma.PrismaPromise<Array<BoxGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BoxType base type for findUnique actions
   */
  export type BoxTypeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BoxType
     */
    select?: BoxTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxTypeInclude | null
    /**
     * Filter, which BoxType to fetch.
     */
    where: BoxTypeWhereUniqueInput
  }

  /**
   * BoxType findUnique
   */
  export interface BoxTypeFindUniqueArgs extends BoxTypeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoxType findUniqueOrThrow
   */
  export type BoxTypeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoxType
     */
    select?: BoxTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxTypeInclude | null
    /**
     * Filter, which BoxType to fetch.
     */
    where: BoxTypeWhereUniqueInput
  }


  /**
   * BoxType base type for findFirst actions
   */
  export type BoxTypeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BoxType
     */
    select?: BoxTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxTypeInclude | null
    /**
     * Filter, which BoxType to fetch.
     */
    where?: BoxTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoxTypes to fetch.
     */
    orderBy?: Enumerable<BoxTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoxTypes.
     */
    cursor?: BoxTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoxTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoxTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoxTypes.
     */
    distinct?: Enumerable<BoxTypeScalarFieldEnum>
  }

  /**
   * BoxType findFirst
   */
  export interface BoxTypeFindFirstArgs extends BoxTypeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoxType findFirstOrThrow
   */
  export type BoxTypeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoxType
     */
    select?: BoxTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxTypeInclude | null
    /**
     * Filter, which BoxType to fetch.
     */
    where?: BoxTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoxTypes to fetch.
     */
    orderBy?: Enumerable<BoxTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoxTypes.
     */
    cursor?: BoxTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoxTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoxTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoxTypes.
     */
    distinct?: Enumerable<BoxTypeScalarFieldEnum>
  }


  /**
   * BoxType findMany
   */
  export type BoxTypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the BoxType
     */
    select?: BoxTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxTypeInclude | null
    /**
     * Filter, which BoxTypes to fetch.
     */
    where?: BoxTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoxTypes to fetch.
     */
    orderBy?: Enumerable<BoxTypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoxTypes.
     */
    cursor?: BoxTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoxTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoxTypes.
     */
    skip?: number
    distinct?: Enumerable<BoxTypeScalarFieldEnum>
  }


  /**
   * BoxType create
   */
  export type BoxTypeCreateArgs = {
    /**
     * Select specific fields to fetch from the BoxType
     */
    select?: BoxTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxTypeInclude | null
    /**
     * The data needed to create a BoxType.
     */
    data: XOR<BoxTypeCreateInput, BoxTypeUncheckedCreateInput>
  }


  /**
   * BoxType createMany
   */
  export type BoxTypeCreateManyArgs = {
    /**
     * The data used to create many BoxTypes.
     */
    data: Enumerable<BoxTypeCreateManyInput>
  }


  /**
   * BoxType update
   */
  export type BoxTypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the BoxType
     */
    select?: BoxTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxTypeInclude | null
    /**
     * The data needed to update a BoxType.
     */
    data: XOR<BoxTypeUpdateInput, BoxTypeUncheckedUpdateInput>
    /**
     * Choose, which BoxType to update.
     */
    where: BoxTypeWhereUniqueInput
  }


  /**
   * BoxType updateMany
   */
  export type BoxTypeUpdateManyArgs = {
    /**
     * The data used to update BoxTypes.
     */
    data: XOR<BoxTypeUpdateManyMutationInput, BoxTypeUncheckedUpdateManyInput>
    /**
     * Filter which BoxTypes to update
     */
    where?: BoxTypeWhereInput
  }


  /**
   * BoxType upsert
   */
  export type BoxTypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the BoxType
     */
    select?: BoxTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxTypeInclude | null
    /**
     * The filter to search for the BoxType to update in case it exists.
     */
    where: BoxTypeWhereUniqueInput
    /**
     * In case the BoxType found by the `where` argument doesn't exist, create a new BoxType with this data.
     */
    create: XOR<BoxTypeCreateInput, BoxTypeUncheckedCreateInput>
    /**
     * In case the BoxType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoxTypeUpdateInput, BoxTypeUncheckedUpdateInput>
  }


  /**
   * BoxType delete
   */
  export type BoxTypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the BoxType
     */
    select?: BoxTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxTypeInclude | null
    /**
     * Filter which BoxType to delete.
     */
    where: BoxTypeWhereUniqueInput
  }


  /**
   * BoxType deleteMany
   */
  export type BoxTypeDeleteManyArgs = {
    /**
     * Filter which BoxTypes to delete
     */
    where?: BoxTypeWhereInput
  }


  /**
   * BoxType findRaw
   */
  export type BoxTypeFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * BoxType aggregateRaw
   */
  export type BoxTypeAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * BoxType.box
   */
  export type BoxType$boxArgs = {
    /**
     * Select specific fields to fetch from the Box
     */
    select?: BoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxInclude | null
    where?: BoxWhereInput
    orderBy?: Enumerable<BoxOrderByWithRelationInput>
    cursor?: BoxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BoxScalarFieldEnum>
  }


  /**
   * BoxType without action
   */
  export type BoxTypeArgs = {
    /**
     * Select specific fields to fetch from the BoxType
     */
    select?: BoxTypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxTypeInclude | null
  }



  /**
   * Model Box
   */


  export type AggregateBox = {
    _count: BoxCountAggregateOutputType | null
    _avg: BoxAvgAggregateOutputType | null
    _sum: BoxSumAggregateOutputType | null
    _min: BoxMinAggregateOutputType | null
    _max: BoxMaxAggregateOutputType | null
  }

  export type BoxAvgAggregateOutputType = {
    price: number | null
    number: number | null
  }

  export type BoxSumAggregateOutputType = {
    price: number | null
    number: number | null
  }

  export type BoxMinAggregateOutputType = {
    id: string | null
    reference: string | null
    name: string | null
    price: number | null
    number: number | null
    description: string | null
    badge: EnumBadgeBox | null
    boxTypeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BoxMaxAggregateOutputType = {
    id: string | null
    reference: string | null
    name: string | null
    price: number | null
    number: number | null
    description: string | null
    badge: EnumBadgeBox | null
    boxTypeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BoxCountAggregateOutputType = {
    id: number
    reference: number
    name: number
    price: number
    number: number
    description: number
    badge: number
    boxTypeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BoxAvgAggregateInputType = {
    price?: true
    number?: true
  }

  export type BoxSumAggregateInputType = {
    price?: true
    number?: true
  }

  export type BoxMinAggregateInputType = {
    id?: true
    reference?: true
    name?: true
    price?: true
    number?: true
    description?: true
    badge?: true
    boxTypeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BoxMaxAggregateInputType = {
    id?: true
    reference?: true
    name?: true
    price?: true
    number?: true
    description?: true
    badge?: true
    boxTypeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BoxCountAggregateInputType = {
    id?: true
    reference?: true
    name?: true
    price?: true
    number?: true
    description?: true
    badge?: true
    boxTypeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BoxAggregateArgs = {
    /**
     * Filter which Box to aggregate.
     */
    where?: BoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boxes to fetch.
     */
    orderBy?: Enumerable<BoxOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Boxes
    **/
    _count?: true | BoxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BoxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BoxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoxMaxAggregateInputType
  }

  export type GetBoxAggregateType<T extends BoxAggregateArgs> = {
        [P in keyof T & keyof AggregateBox]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBox[P]>
      : GetScalarType<T[P], AggregateBox[P]>
  }




  export type BoxGroupByArgs = {
    where?: BoxWhereInput
    orderBy?: Enumerable<BoxOrderByWithAggregationInput>
    by: BoxScalarFieldEnum[]
    having?: BoxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoxCountAggregateInputType | true
    _avg?: BoxAvgAggregateInputType
    _sum?: BoxSumAggregateInputType
    _min?: BoxMinAggregateInputType
    _max?: BoxMaxAggregateInputType
  }


  export type BoxGroupByOutputType = {
    id: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge: EnumBadgeBox | null
    boxTypeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: BoxCountAggregateOutputType | null
    _avg: BoxAvgAggregateOutputType | null
    _sum: BoxSumAggregateOutputType | null
    _min: BoxMinAggregateOutputType | null
    _max: BoxMaxAggregateOutputType | null
  }

  type GetBoxGroupByPayload<T extends BoxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BoxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoxGroupByOutputType[P]>
            : GetScalarType<T[P], BoxGroupByOutputType[P]>
        }
      >
    >


  export type BoxSelect = {
    id?: boolean
    reference?: boolean
    name?: boolean
    price?: boolean
    number?: boolean
    description?: boolean
    badge?: boolean
    boxTypeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    boxImage?: boolean | Box$boxImageArgs
    article?: boolean | Box$articleArgs
    transaction?: boolean | Box$transactionArgs
    userBox?: boolean | Box$userBoxArgs
    bannerImage?: boolean | Box$bannerImageArgs
    boxParams?: boolean | BoxParamsArgs
    boxType?: boolean | BoxTypeArgs
    boxArticle?: boolean | Box$boxArticleArgs
    dailyReward?: boolean | Box$dailyRewardArgs
    boxRewardLevel?: boolean | Box$boxRewardLevelArgs
    _count?: boolean | BoxCountOutputTypeArgs
  }


  export type BoxInclude = {
    boxImage?: boolean | Box$boxImageArgs
    article?: boolean | Box$articleArgs
    transaction?: boolean | Box$transactionArgs
    userBox?: boolean | Box$userBoxArgs
    bannerImage?: boolean | Box$bannerImageArgs
    boxParams?: boolean | BoxParamsArgs
    boxType?: boolean | BoxTypeArgs
    boxArticle?: boolean | Box$boxArticleArgs
    dailyReward?: boolean | Box$dailyRewardArgs
    boxRewardLevel?: boolean | Box$boxRewardLevelArgs
    _count?: boolean | BoxCountOutputTypeArgs
  }

  export type BoxGetPayload<S extends boolean | null | undefined | BoxArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Box :
    S extends undefined ? never :
    S extends { include: any } & (BoxArgs | BoxFindManyArgs)
    ? Box  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'boxImage' ? Array < BoxImageGetPayload<S['include'][P]>>  :
        P extends 'article' ? Array < ArticleGetPayload<S['include'][P]>>  :
        P extends 'transaction' ? Array < TransactionGetPayload<S['include'][P]>>  :
        P extends 'userBox' ? Array < UserBoxGetPayload<S['include'][P]>>  :
        P extends 'bannerImage' ? Array < BannerImageGetPayload<S['include'][P]>>  :
        P extends 'boxParams' ? BoxParamsGetPayload<S['include'][P]> | null :
        P extends 'boxType' ? BoxTypeGetPayload<S['include'][P]> | null :
        P extends 'boxArticle' ? Array < BoxArticleGetPayload<S['include'][P]>>  :
        P extends 'dailyReward' ? Array < DailyRewardGetPayload<S['include'][P]>>  :
        P extends 'boxRewardLevel' ? Array < BoxRewardLevelGetPayload<S['include'][P]>>  :
        P extends '_count' ? BoxCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BoxArgs | BoxFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'boxImage' ? Array < BoxImageGetPayload<S['select'][P]>>  :
        P extends 'article' ? Array < ArticleGetPayload<S['select'][P]>>  :
        P extends 'transaction' ? Array < TransactionGetPayload<S['select'][P]>>  :
        P extends 'userBox' ? Array < UserBoxGetPayload<S['select'][P]>>  :
        P extends 'bannerImage' ? Array < BannerImageGetPayload<S['select'][P]>>  :
        P extends 'boxParams' ? BoxParamsGetPayload<S['select'][P]> | null :
        P extends 'boxType' ? BoxTypeGetPayload<S['select'][P]> | null :
        P extends 'boxArticle' ? Array < BoxArticleGetPayload<S['select'][P]>>  :
        P extends 'dailyReward' ? Array < DailyRewardGetPayload<S['select'][P]>>  :
        P extends 'boxRewardLevel' ? Array < BoxRewardLevelGetPayload<S['select'][P]>>  :
        P extends '_count' ? BoxCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Box ? Box[P] : never
  } 
      : Box


  type BoxCountArgs = 
    Omit<BoxFindManyArgs, 'select' | 'include'> & {
      select?: BoxCountAggregateInputType | true
    }

  export interface BoxDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Box that matches the filter.
     * @param {BoxFindUniqueArgs} args - Arguments to find a Box
     * @example
     * // Get one Box
     * const box = await prisma.box.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BoxFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BoxFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Box'> extends True ? Prisma__BoxClient<BoxGetPayload<T>> : Prisma__BoxClient<BoxGetPayload<T> | null, null>

    /**
     * Find one Box that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BoxFindUniqueOrThrowArgs} args - Arguments to find a Box
     * @example
     * // Get one Box
     * const box = await prisma.box.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BoxFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BoxFindUniqueOrThrowArgs>
    ): Prisma__BoxClient<BoxGetPayload<T>>

    /**
     * Find the first Box that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxFindFirstArgs} args - Arguments to find a Box
     * @example
     * // Get one Box
     * const box = await prisma.box.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BoxFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BoxFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Box'> extends True ? Prisma__BoxClient<BoxGetPayload<T>> : Prisma__BoxClient<BoxGetPayload<T> | null, null>

    /**
     * Find the first Box that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxFindFirstOrThrowArgs} args - Arguments to find a Box
     * @example
     * // Get one Box
     * const box = await prisma.box.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BoxFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BoxFindFirstOrThrowArgs>
    ): Prisma__BoxClient<BoxGetPayload<T>>

    /**
     * Find zero or more Boxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Boxes
     * const boxes = await prisma.box.findMany()
     * 
     * // Get first 10 Boxes
     * const boxes = await prisma.box.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boxWithIdOnly = await prisma.box.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BoxFindManyArgs>(
      args?: SelectSubset<T, BoxFindManyArgs>
    ): Prisma.PrismaPromise<Array<BoxGetPayload<T>>>

    /**
     * Create a Box.
     * @param {BoxCreateArgs} args - Arguments to create a Box.
     * @example
     * // Create one Box
     * const Box = await prisma.box.create({
     *   data: {
     *     // ... data to create a Box
     *   }
     * })
     * 
    **/
    create<T extends BoxCreateArgs>(
      args: SelectSubset<T, BoxCreateArgs>
    ): Prisma__BoxClient<BoxGetPayload<T>>

    /**
     * Create many Boxes.
     *     @param {BoxCreateManyArgs} args - Arguments to create many Boxes.
     *     @example
     *     // Create many Boxes
     *     const box = await prisma.box.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BoxCreateManyArgs>(
      args?: SelectSubset<T, BoxCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Box.
     * @param {BoxDeleteArgs} args - Arguments to delete one Box.
     * @example
     * // Delete one Box
     * const Box = await prisma.box.delete({
     *   where: {
     *     // ... filter to delete one Box
     *   }
     * })
     * 
    **/
    delete<T extends BoxDeleteArgs>(
      args: SelectSubset<T, BoxDeleteArgs>
    ): Prisma__BoxClient<BoxGetPayload<T>>

    /**
     * Update one Box.
     * @param {BoxUpdateArgs} args - Arguments to update one Box.
     * @example
     * // Update one Box
     * const box = await prisma.box.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BoxUpdateArgs>(
      args: SelectSubset<T, BoxUpdateArgs>
    ): Prisma__BoxClient<BoxGetPayload<T>>

    /**
     * Delete zero or more Boxes.
     * @param {BoxDeleteManyArgs} args - Arguments to filter Boxes to delete.
     * @example
     * // Delete a few Boxes
     * const { count } = await prisma.box.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BoxDeleteManyArgs>(
      args?: SelectSubset<T, BoxDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Boxes
     * const box = await prisma.box.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BoxUpdateManyArgs>(
      args: SelectSubset<T, BoxUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Box.
     * @param {BoxUpsertArgs} args - Arguments to update or create a Box.
     * @example
     * // Update or create a Box
     * const box = await prisma.box.upsert({
     *   create: {
     *     // ... data to create a Box
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Box we want to update
     *   }
     * })
    **/
    upsert<T extends BoxUpsertArgs>(
      args: SelectSubset<T, BoxUpsertArgs>
    ): Prisma__BoxClient<BoxGetPayload<T>>

    /**
     * Find zero or more Boxes that matches the filter.
     * @param {BoxFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const box = await prisma.box.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: BoxFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Box.
     * @param {BoxAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const box = await prisma.box.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: BoxAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Boxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxCountArgs} args - Arguments to filter Boxes to count.
     * @example
     * // Count the number of Boxes
     * const count = await prisma.box.count({
     *   where: {
     *     // ... the filter for the Boxes we want to count
     *   }
     * })
    **/
    count<T extends BoxCountArgs>(
      args?: Subset<T, BoxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Box.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoxAggregateArgs>(args: Subset<T, BoxAggregateArgs>): Prisma.PrismaPromise<GetBoxAggregateType<T>>

    /**
     * Group by Box.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoxGroupByArgs['orderBy'] }
        : { orderBy?: BoxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Box.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BoxClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    boxImage<T extends Box$boxImageArgs= {}>(args?: Subset<T, Box$boxImageArgs>): Prisma.PrismaPromise<Array<BoxImageGetPayload<T>>| Null>;

    article<T extends Box$articleArgs= {}>(args?: Subset<T, Box$articleArgs>): Prisma.PrismaPromise<Array<ArticleGetPayload<T>>| Null>;

    transaction<T extends Box$transactionArgs= {}>(args?: Subset<T, Box$transactionArgs>): Prisma.PrismaPromise<Array<TransactionGetPayload<T>>| Null>;

    userBox<T extends Box$userBoxArgs= {}>(args?: Subset<T, Box$userBoxArgs>): Prisma.PrismaPromise<Array<UserBoxGetPayload<T>>| Null>;

    bannerImage<T extends Box$bannerImageArgs= {}>(args?: Subset<T, Box$bannerImageArgs>): Prisma.PrismaPromise<Array<BannerImageGetPayload<T>>| Null>;

    boxParams<T extends BoxParamsArgs= {}>(args?: Subset<T, BoxParamsArgs>): Prisma__BoxParamsClient<BoxParamsGetPayload<T> | Null>;

    boxType<T extends BoxTypeArgs= {}>(args?: Subset<T, BoxTypeArgs>): Prisma__BoxTypeClient<BoxTypeGetPayload<T> | Null>;

    boxArticle<T extends Box$boxArticleArgs= {}>(args?: Subset<T, Box$boxArticleArgs>): Prisma.PrismaPromise<Array<BoxArticleGetPayload<T>>| Null>;

    dailyReward<T extends Box$dailyRewardArgs= {}>(args?: Subset<T, Box$dailyRewardArgs>): Prisma.PrismaPromise<Array<DailyRewardGetPayload<T>>| Null>;

    boxRewardLevel<T extends Box$boxRewardLevelArgs= {}>(args?: Subset<T, Box$boxRewardLevelArgs>): Prisma.PrismaPromise<Array<BoxRewardLevelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Box base type for findUnique actions
   */
  export type BoxFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Box
     */
    select?: BoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxInclude | null
    /**
     * Filter, which Box to fetch.
     */
    where: BoxWhereUniqueInput
  }

  /**
   * Box findUnique
   */
  export interface BoxFindUniqueArgs extends BoxFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Box findUniqueOrThrow
   */
  export type BoxFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Box
     */
    select?: BoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxInclude | null
    /**
     * Filter, which Box to fetch.
     */
    where: BoxWhereUniqueInput
  }


  /**
   * Box base type for findFirst actions
   */
  export type BoxFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Box
     */
    select?: BoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxInclude | null
    /**
     * Filter, which Box to fetch.
     */
    where?: BoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boxes to fetch.
     */
    orderBy?: Enumerable<BoxOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boxes.
     */
    cursor?: BoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boxes.
     */
    distinct?: Enumerable<BoxScalarFieldEnum>
  }

  /**
   * Box findFirst
   */
  export interface BoxFindFirstArgs extends BoxFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Box findFirstOrThrow
   */
  export type BoxFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Box
     */
    select?: BoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxInclude | null
    /**
     * Filter, which Box to fetch.
     */
    where?: BoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boxes to fetch.
     */
    orderBy?: Enumerable<BoxOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boxes.
     */
    cursor?: BoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boxes.
     */
    distinct?: Enumerable<BoxScalarFieldEnum>
  }


  /**
   * Box findMany
   */
  export type BoxFindManyArgs = {
    /**
     * Select specific fields to fetch from the Box
     */
    select?: BoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxInclude | null
    /**
     * Filter, which Boxes to fetch.
     */
    where?: BoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boxes to fetch.
     */
    orderBy?: Enumerable<BoxOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Boxes.
     */
    cursor?: BoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boxes.
     */
    skip?: number
    distinct?: Enumerable<BoxScalarFieldEnum>
  }


  /**
   * Box create
   */
  export type BoxCreateArgs = {
    /**
     * Select specific fields to fetch from the Box
     */
    select?: BoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxInclude | null
    /**
     * The data needed to create a Box.
     */
    data: XOR<BoxCreateInput, BoxUncheckedCreateInput>
  }


  /**
   * Box createMany
   */
  export type BoxCreateManyArgs = {
    /**
     * The data used to create many Boxes.
     */
    data: Enumerable<BoxCreateManyInput>
  }


  /**
   * Box update
   */
  export type BoxUpdateArgs = {
    /**
     * Select specific fields to fetch from the Box
     */
    select?: BoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxInclude | null
    /**
     * The data needed to update a Box.
     */
    data: XOR<BoxUpdateInput, BoxUncheckedUpdateInput>
    /**
     * Choose, which Box to update.
     */
    where: BoxWhereUniqueInput
  }


  /**
   * Box updateMany
   */
  export type BoxUpdateManyArgs = {
    /**
     * The data used to update Boxes.
     */
    data: XOR<BoxUpdateManyMutationInput, BoxUncheckedUpdateManyInput>
    /**
     * Filter which Boxes to update
     */
    where?: BoxWhereInput
  }


  /**
   * Box upsert
   */
  export type BoxUpsertArgs = {
    /**
     * Select specific fields to fetch from the Box
     */
    select?: BoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxInclude | null
    /**
     * The filter to search for the Box to update in case it exists.
     */
    where: BoxWhereUniqueInput
    /**
     * In case the Box found by the `where` argument doesn't exist, create a new Box with this data.
     */
    create: XOR<BoxCreateInput, BoxUncheckedCreateInput>
    /**
     * In case the Box was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoxUpdateInput, BoxUncheckedUpdateInput>
  }


  /**
   * Box delete
   */
  export type BoxDeleteArgs = {
    /**
     * Select specific fields to fetch from the Box
     */
    select?: BoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxInclude | null
    /**
     * Filter which Box to delete.
     */
    where: BoxWhereUniqueInput
  }


  /**
   * Box deleteMany
   */
  export type BoxDeleteManyArgs = {
    /**
     * Filter which Boxes to delete
     */
    where?: BoxWhereInput
  }


  /**
   * Box findRaw
   */
  export type BoxFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Box aggregateRaw
   */
  export type BoxAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Box.boxImage
   */
  export type Box$boxImageArgs = {
    /**
     * Select specific fields to fetch from the BoxImage
     */
    select?: BoxImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxImageInclude | null
    where?: BoxImageWhereInput
    orderBy?: Enumerable<BoxImageOrderByWithRelationInput>
    cursor?: BoxImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BoxImageScalarFieldEnum>
  }


  /**
   * Box.article
   */
  export type Box$articleArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    where?: ArticleWhereInput
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ArticleScalarFieldEnum>
  }


  /**
   * Box.transaction
   */
  export type Box$transactionArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude | null
    where?: TransactionWhereInput
    orderBy?: Enumerable<TransactionOrderByWithRelationInput>
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * Box.userBox
   */
  export type Box$userBoxArgs = {
    /**
     * Select specific fields to fetch from the UserBox
     */
    select?: UserBoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBoxInclude | null
    where?: UserBoxWhereInput
    orderBy?: Enumerable<UserBoxOrderByWithRelationInput>
    cursor?: UserBoxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserBoxScalarFieldEnum>
  }


  /**
   * Box.bannerImage
   */
  export type Box$bannerImageArgs = {
    /**
     * Select specific fields to fetch from the BannerImage
     */
    select?: BannerImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannerImageInclude | null
    where?: BannerImageWhereInput
    orderBy?: Enumerable<BannerImageOrderByWithRelationInput>
    cursor?: BannerImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BannerImageScalarFieldEnum>
  }


  /**
   * Box.boxArticle
   */
  export type Box$boxArticleArgs = {
    /**
     * Select specific fields to fetch from the BoxArticle
     */
    select?: BoxArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxArticleInclude | null
    where?: BoxArticleWhereInput
    orderBy?: Enumerable<BoxArticleOrderByWithRelationInput>
    cursor?: BoxArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BoxArticleScalarFieldEnum>
  }


  /**
   * Box.dailyReward
   */
  export type Box$dailyRewardArgs = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyRewardInclude | null
    where?: DailyRewardWhereInput
    orderBy?: Enumerable<DailyRewardOrderByWithRelationInput>
    cursor?: DailyRewardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DailyRewardScalarFieldEnum>
  }


  /**
   * Box.boxRewardLevel
   */
  export type Box$boxRewardLevelArgs = {
    /**
     * Select specific fields to fetch from the BoxRewardLevel
     */
    select?: BoxRewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxRewardLevelInclude | null
    where?: BoxRewardLevelWhereInput
    orderBy?: Enumerable<BoxRewardLevelOrderByWithRelationInput>
    cursor?: BoxRewardLevelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BoxRewardLevelScalarFieldEnum>
  }


  /**
   * Box without action
   */
  export type BoxArgs = {
    /**
     * Select specific fields to fetch from the Box
     */
    select?: BoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxInclude | null
  }



  /**
   * Model DailyReward
   */


  export type AggregateDailyReward = {
    _count: DailyRewardCountAggregateOutputType | null
    _avg: DailyRewardAvgAggregateOutputType | null
    _sum: DailyRewardSumAggregateOutputType | null
    _min: DailyRewardMinAggregateOutputType | null
    _max: DailyRewardMaxAggregateOutputType | null
  }

  export type DailyRewardAvgAggregateOutputType = {
    number: number | null
  }

  export type DailyRewardSumAggregateOutputType = {
    number: number | null
  }

  export type DailyRewardMinAggregateOutputType = {
    id: string | null
    number: number | null
    boxId: string | null
  }

  export type DailyRewardMaxAggregateOutputType = {
    id: string | null
    number: number | null
    boxId: string | null
  }

  export type DailyRewardCountAggregateOutputType = {
    id: number
    number: number
    boxId: number
    _all: number
  }


  export type DailyRewardAvgAggregateInputType = {
    number?: true
  }

  export type DailyRewardSumAggregateInputType = {
    number?: true
  }

  export type DailyRewardMinAggregateInputType = {
    id?: true
    number?: true
    boxId?: true
  }

  export type DailyRewardMaxAggregateInputType = {
    id?: true
    number?: true
    boxId?: true
  }

  export type DailyRewardCountAggregateInputType = {
    id?: true
    number?: true
    boxId?: true
    _all?: true
  }

  export type DailyRewardAggregateArgs = {
    /**
     * Filter which DailyReward to aggregate.
     */
    where?: DailyRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRewards to fetch.
     */
    orderBy?: Enumerable<DailyRewardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyRewards
    **/
    _count?: true | DailyRewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyRewardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyRewardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyRewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyRewardMaxAggregateInputType
  }

  export type GetDailyRewardAggregateType<T extends DailyRewardAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyReward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyReward[P]>
      : GetScalarType<T[P], AggregateDailyReward[P]>
  }




  export type DailyRewardGroupByArgs = {
    where?: DailyRewardWhereInput
    orderBy?: Enumerable<DailyRewardOrderByWithAggregationInput>
    by: DailyRewardScalarFieldEnum[]
    having?: DailyRewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyRewardCountAggregateInputType | true
    _avg?: DailyRewardAvgAggregateInputType
    _sum?: DailyRewardSumAggregateInputType
    _min?: DailyRewardMinAggregateInputType
    _max?: DailyRewardMaxAggregateInputType
  }


  export type DailyRewardGroupByOutputType = {
    id: string
    number: number
    boxId: string
    _count: DailyRewardCountAggregateOutputType | null
    _avg: DailyRewardAvgAggregateOutputType | null
    _sum: DailyRewardSumAggregateOutputType | null
    _min: DailyRewardMinAggregateOutputType | null
    _max: DailyRewardMaxAggregateOutputType | null
  }

  type GetDailyRewardGroupByPayload<T extends DailyRewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DailyRewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyRewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyRewardGroupByOutputType[P]>
            : GetScalarType<T[P], DailyRewardGroupByOutputType[P]>
        }
      >
    >


  export type DailyRewardSelect = {
    id?: boolean
    number?: boolean
    boxId?: boolean
    box?: boolean | BoxArgs
  }


  export type DailyRewardInclude = {
    box?: boolean | BoxArgs
  }

  export type DailyRewardGetPayload<S extends boolean | null | undefined | DailyRewardArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DailyReward :
    S extends undefined ? never :
    S extends { include: any } & (DailyRewardArgs | DailyRewardFindManyArgs)
    ? DailyReward  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'box' ? BoxGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DailyRewardArgs | DailyRewardFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'box' ? BoxGetPayload<S['select'][P]> :  P extends keyof DailyReward ? DailyReward[P] : never
  } 
      : DailyReward


  type DailyRewardCountArgs = 
    Omit<DailyRewardFindManyArgs, 'select' | 'include'> & {
      select?: DailyRewardCountAggregateInputType | true
    }

  export interface DailyRewardDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DailyReward that matches the filter.
     * @param {DailyRewardFindUniqueArgs} args - Arguments to find a DailyReward
     * @example
     * // Get one DailyReward
     * const dailyReward = await prisma.dailyReward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DailyRewardFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DailyRewardFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DailyReward'> extends True ? Prisma__DailyRewardClient<DailyRewardGetPayload<T>> : Prisma__DailyRewardClient<DailyRewardGetPayload<T> | null, null>

    /**
     * Find one DailyReward that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DailyRewardFindUniqueOrThrowArgs} args - Arguments to find a DailyReward
     * @example
     * // Get one DailyReward
     * const dailyReward = await prisma.dailyReward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DailyRewardFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DailyRewardFindUniqueOrThrowArgs>
    ): Prisma__DailyRewardClient<DailyRewardGetPayload<T>>

    /**
     * Find the first DailyReward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardFindFirstArgs} args - Arguments to find a DailyReward
     * @example
     * // Get one DailyReward
     * const dailyReward = await prisma.dailyReward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DailyRewardFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DailyRewardFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DailyReward'> extends True ? Prisma__DailyRewardClient<DailyRewardGetPayload<T>> : Prisma__DailyRewardClient<DailyRewardGetPayload<T> | null, null>

    /**
     * Find the first DailyReward that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardFindFirstOrThrowArgs} args - Arguments to find a DailyReward
     * @example
     * // Get one DailyReward
     * const dailyReward = await prisma.dailyReward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DailyRewardFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DailyRewardFindFirstOrThrowArgs>
    ): Prisma__DailyRewardClient<DailyRewardGetPayload<T>>

    /**
     * Find zero or more DailyRewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyRewards
     * const dailyRewards = await prisma.dailyReward.findMany()
     * 
     * // Get first 10 DailyRewards
     * const dailyRewards = await prisma.dailyReward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyRewardWithIdOnly = await prisma.dailyReward.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DailyRewardFindManyArgs>(
      args?: SelectSubset<T, DailyRewardFindManyArgs>
    ): Prisma.PrismaPromise<Array<DailyRewardGetPayload<T>>>

    /**
     * Create a DailyReward.
     * @param {DailyRewardCreateArgs} args - Arguments to create a DailyReward.
     * @example
     * // Create one DailyReward
     * const DailyReward = await prisma.dailyReward.create({
     *   data: {
     *     // ... data to create a DailyReward
     *   }
     * })
     * 
    **/
    create<T extends DailyRewardCreateArgs>(
      args: SelectSubset<T, DailyRewardCreateArgs>
    ): Prisma__DailyRewardClient<DailyRewardGetPayload<T>>

    /**
     * Create many DailyRewards.
     *     @param {DailyRewardCreateManyArgs} args - Arguments to create many DailyRewards.
     *     @example
     *     // Create many DailyRewards
     *     const dailyReward = await prisma.dailyReward.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DailyRewardCreateManyArgs>(
      args?: SelectSubset<T, DailyRewardCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DailyReward.
     * @param {DailyRewardDeleteArgs} args - Arguments to delete one DailyReward.
     * @example
     * // Delete one DailyReward
     * const DailyReward = await prisma.dailyReward.delete({
     *   where: {
     *     // ... filter to delete one DailyReward
     *   }
     * })
     * 
    **/
    delete<T extends DailyRewardDeleteArgs>(
      args: SelectSubset<T, DailyRewardDeleteArgs>
    ): Prisma__DailyRewardClient<DailyRewardGetPayload<T>>

    /**
     * Update one DailyReward.
     * @param {DailyRewardUpdateArgs} args - Arguments to update one DailyReward.
     * @example
     * // Update one DailyReward
     * const dailyReward = await prisma.dailyReward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DailyRewardUpdateArgs>(
      args: SelectSubset<T, DailyRewardUpdateArgs>
    ): Prisma__DailyRewardClient<DailyRewardGetPayload<T>>

    /**
     * Delete zero or more DailyRewards.
     * @param {DailyRewardDeleteManyArgs} args - Arguments to filter DailyRewards to delete.
     * @example
     * // Delete a few DailyRewards
     * const { count } = await prisma.dailyReward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DailyRewardDeleteManyArgs>(
      args?: SelectSubset<T, DailyRewardDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyRewards
     * const dailyReward = await prisma.dailyReward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DailyRewardUpdateManyArgs>(
      args: SelectSubset<T, DailyRewardUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyReward.
     * @param {DailyRewardUpsertArgs} args - Arguments to update or create a DailyReward.
     * @example
     * // Update or create a DailyReward
     * const dailyReward = await prisma.dailyReward.upsert({
     *   create: {
     *     // ... data to create a DailyReward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyReward we want to update
     *   }
     * })
    **/
    upsert<T extends DailyRewardUpsertArgs>(
      args: SelectSubset<T, DailyRewardUpsertArgs>
    ): Prisma__DailyRewardClient<DailyRewardGetPayload<T>>

    /**
     * Find zero or more DailyRewards that matches the filter.
     * @param {DailyRewardFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dailyReward = await prisma.dailyReward.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: DailyRewardFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DailyReward.
     * @param {DailyRewardAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dailyReward = await prisma.dailyReward.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: DailyRewardAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of DailyRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardCountArgs} args - Arguments to filter DailyRewards to count.
     * @example
     * // Count the number of DailyRewards
     * const count = await prisma.dailyReward.count({
     *   where: {
     *     // ... the filter for the DailyRewards we want to count
     *   }
     * })
    **/
    count<T extends DailyRewardCountArgs>(
      args?: Subset<T, DailyRewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyRewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyRewardAggregateArgs>(args: Subset<T, DailyRewardAggregateArgs>): Prisma.PrismaPromise<GetDailyRewardAggregateType<T>>

    /**
     * Group by DailyReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyRewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyRewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyRewardGroupByArgs['orderBy'] }
        : { orderBy?: DailyRewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyRewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyRewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyReward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DailyRewardClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    box<T extends BoxArgs= {}>(args?: Subset<T, BoxArgs>): Prisma__BoxClient<BoxGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DailyReward base type for findUnique actions
   */
  export type DailyRewardFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyRewardInclude | null
    /**
     * Filter, which DailyReward to fetch.
     */
    where: DailyRewardWhereUniqueInput
  }

  /**
   * DailyReward findUnique
   */
  export interface DailyRewardFindUniqueArgs extends DailyRewardFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DailyReward findUniqueOrThrow
   */
  export type DailyRewardFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyRewardInclude | null
    /**
     * Filter, which DailyReward to fetch.
     */
    where: DailyRewardWhereUniqueInput
  }


  /**
   * DailyReward base type for findFirst actions
   */
  export type DailyRewardFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyRewardInclude | null
    /**
     * Filter, which DailyReward to fetch.
     */
    where?: DailyRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRewards to fetch.
     */
    orderBy?: Enumerable<DailyRewardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyRewards.
     */
    cursor?: DailyRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyRewards.
     */
    distinct?: Enumerable<DailyRewardScalarFieldEnum>
  }

  /**
   * DailyReward findFirst
   */
  export interface DailyRewardFindFirstArgs extends DailyRewardFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DailyReward findFirstOrThrow
   */
  export type DailyRewardFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyRewardInclude | null
    /**
     * Filter, which DailyReward to fetch.
     */
    where?: DailyRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRewards to fetch.
     */
    orderBy?: Enumerable<DailyRewardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyRewards.
     */
    cursor?: DailyRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyRewards.
     */
    distinct?: Enumerable<DailyRewardScalarFieldEnum>
  }


  /**
   * DailyReward findMany
   */
  export type DailyRewardFindManyArgs = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyRewardInclude | null
    /**
     * Filter, which DailyRewards to fetch.
     */
    where?: DailyRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyRewards to fetch.
     */
    orderBy?: Enumerable<DailyRewardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyRewards.
     */
    cursor?: DailyRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyRewards.
     */
    skip?: number
    distinct?: Enumerable<DailyRewardScalarFieldEnum>
  }


  /**
   * DailyReward create
   */
  export type DailyRewardCreateArgs = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyRewardInclude | null
    /**
     * The data needed to create a DailyReward.
     */
    data: XOR<DailyRewardCreateInput, DailyRewardUncheckedCreateInput>
  }


  /**
   * DailyReward createMany
   */
  export type DailyRewardCreateManyArgs = {
    /**
     * The data used to create many DailyRewards.
     */
    data: Enumerable<DailyRewardCreateManyInput>
  }


  /**
   * DailyReward update
   */
  export type DailyRewardUpdateArgs = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyRewardInclude | null
    /**
     * The data needed to update a DailyReward.
     */
    data: XOR<DailyRewardUpdateInput, DailyRewardUncheckedUpdateInput>
    /**
     * Choose, which DailyReward to update.
     */
    where: DailyRewardWhereUniqueInput
  }


  /**
   * DailyReward updateMany
   */
  export type DailyRewardUpdateManyArgs = {
    /**
     * The data used to update DailyRewards.
     */
    data: XOR<DailyRewardUpdateManyMutationInput, DailyRewardUncheckedUpdateManyInput>
    /**
     * Filter which DailyRewards to update
     */
    where?: DailyRewardWhereInput
  }


  /**
   * DailyReward upsert
   */
  export type DailyRewardUpsertArgs = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyRewardInclude | null
    /**
     * The filter to search for the DailyReward to update in case it exists.
     */
    where: DailyRewardWhereUniqueInput
    /**
     * In case the DailyReward found by the `where` argument doesn't exist, create a new DailyReward with this data.
     */
    create: XOR<DailyRewardCreateInput, DailyRewardUncheckedCreateInput>
    /**
     * In case the DailyReward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyRewardUpdateInput, DailyRewardUncheckedUpdateInput>
  }


  /**
   * DailyReward delete
   */
  export type DailyRewardDeleteArgs = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyRewardInclude | null
    /**
     * Filter which DailyReward to delete.
     */
    where: DailyRewardWhereUniqueInput
  }


  /**
   * DailyReward deleteMany
   */
  export type DailyRewardDeleteManyArgs = {
    /**
     * Filter which DailyRewards to delete
     */
    where?: DailyRewardWhereInput
  }


  /**
   * DailyReward findRaw
   */
  export type DailyRewardFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * DailyReward aggregateRaw
   */
  export type DailyRewardAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * DailyReward without action
   */
  export type DailyRewardArgs = {
    /**
     * Select specific fields to fetch from the DailyReward
     */
    select?: DailyRewardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyRewardInclude | null
  }



  /**
   * Model BoxRewardLevel
   */


  export type AggregateBoxRewardLevel = {
    _count: BoxRewardLevelCountAggregateOutputType | null
    _min: BoxRewardLevelMinAggregateOutputType | null
    _max: BoxRewardLevelMaxAggregateOutputType | null
  }

  export type BoxRewardLevelMinAggregateOutputType = {
    id: string | null
    boxId: string | null
    rewardLevelId: string | null
  }

  export type BoxRewardLevelMaxAggregateOutputType = {
    id: string | null
    boxId: string | null
    rewardLevelId: string | null
  }

  export type BoxRewardLevelCountAggregateOutputType = {
    id: number
    boxId: number
    rewardLevelId: number
    _all: number
  }


  export type BoxRewardLevelMinAggregateInputType = {
    id?: true
    boxId?: true
    rewardLevelId?: true
  }

  export type BoxRewardLevelMaxAggregateInputType = {
    id?: true
    boxId?: true
    rewardLevelId?: true
  }

  export type BoxRewardLevelCountAggregateInputType = {
    id?: true
    boxId?: true
    rewardLevelId?: true
    _all?: true
  }

  export type BoxRewardLevelAggregateArgs = {
    /**
     * Filter which BoxRewardLevel to aggregate.
     */
    where?: BoxRewardLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoxRewardLevels to fetch.
     */
    orderBy?: Enumerable<BoxRewardLevelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoxRewardLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoxRewardLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoxRewardLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoxRewardLevels
    **/
    _count?: true | BoxRewardLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoxRewardLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoxRewardLevelMaxAggregateInputType
  }

  export type GetBoxRewardLevelAggregateType<T extends BoxRewardLevelAggregateArgs> = {
        [P in keyof T & keyof AggregateBoxRewardLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoxRewardLevel[P]>
      : GetScalarType<T[P], AggregateBoxRewardLevel[P]>
  }




  export type BoxRewardLevelGroupByArgs = {
    where?: BoxRewardLevelWhereInput
    orderBy?: Enumerable<BoxRewardLevelOrderByWithAggregationInput>
    by: BoxRewardLevelScalarFieldEnum[]
    having?: BoxRewardLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoxRewardLevelCountAggregateInputType | true
    _min?: BoxRewardLevelMinAggregateInputType
    _max?: BoxRewardLevelMaxAggregateInputType
  }


  export type BoxRewardLevelGroupByOutputType = {
    id: string
    boxId: string
    rewardLevelId: string
    _count: BoxRewardLevelCountAggregateOutputType | null
    _min: BoxRewardLevelMinAggregateOutputType | null
    _max: BoxRewardLevelMaxAggregateOutputType | null
  }

  type GetBoxRewardLevelGroupByPayload<T extends BoxRewardLevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BoxRewardLevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoxRewardLevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoxRewardLevelGroupByOutputType[P]>
            : GetScalarType<T[P], BoxRewardLevelGroupByOutputType[P]>
        }
      >
    >


  export type BoxRewardLevelSelect = {
    id?: boolean
    boxId?: boolean
    rewardLevelId?: boolean
    box?: boolean | BoxArgs
    rewardLevel?: boolean | RewardLevelArgs
  }


  export type BoxRewardLevelInclude = {
    box?: boolean | BoxArgs
    rewardLevel?: boolean | RewardLevelArgs
  }

  export type BoxRewardLevelGetPayload<S extends boolean | null | undefined | BoxRewardLevelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BoxRewardLevel :
    S extends undefined ? never :
    S extends { include: any } & (BoxRewardLevelArgs | BoxRewardLevelFindManyArgs)
    ? BoxRewardLevel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'box' ? BoxGetPayload<S['include'][P]> :
        P extends 'rewardLevel' ? RewardLevelGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BoxRewardLevelArgs | BoxRewardLevelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'box' ? BoxGetPayload<S['select'][P]> :
        P extends 'rewardLevel' ? RewardLevelGetPayload<S['select'][P]> :  P extends keyof BoxRewardLevel ? BoxRewardLevel[P] : never
  } 
      : BoxRewardLevel


  type BoxRewardLevelCountArgs = 
    Omit<BoxRewardLevelFindManyArgs, 'select' | 'include'> & {
      select?: BoxRewardLevelCountAggregateInputType | true
    }

  export interface BoxRewardLevelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BoxRewardLevel that matches the filter.
     * @param {BoxRewardLevelFindUniqueArgs} args - Arguments to find a BoxRewardLevel
     * @example
     * // Get one BoxRewardLevel
     * const boxRewardLevel = await prisma.boxRewardLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BoxRewardLevelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BoxRewardLevelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BoxRewardLevel'> extends True ? Prisma__BoxRewardLevelClient<BoxRewardLevelGetPayload<T>> : Prisma__BoxRewardLevelClient<BoxRewardLevelGetPayload<T> | null, null>

    /**
     * Find one BoxRewardLevel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BoxRewardLevelFindUniqueOrThrowArgs} args - Arguments to find a BoxRewardLevel
     * @example
     * // Get one BoxRewardLevel
     * const boxRewardLevel = await prisma.boxRewardLevel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BoxRewardLevelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BoxRewardLevelFindUniqueOrThrowArgs>
    ): Prisma__BoxRewardLevelClient<BoxRewardLevelGetPayload<T>>

    /**
     * Find the first BoxRewardLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxRewardLevelFindFirstArgs} args - Arguments to find a BoxRewardLevel
     * @example
     * // Get one BoxRewardLevel
     * const boxRewardLevel = await prisma.boxRewardLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BoxRewardLevelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BoxRewardLevelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BoxRewardLevel'> extends True ? Prisma__BoxRewardLevelClient<BoxRewardLevelGetPayload<T>> : Prisma__BoxRewardLevelClient<BoxRewardLevelGetPayload<T> | null, null>

    /**
     * Find the first BoxRewardLevel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxRewardLevelFindFirstOrThrowArgs} args - Arguments to find a BoxRewardLevel
     * @example
     * // Get one BoxRewardLevel
     * const boxRewardLevel = await prisma.boxRewardLevel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BoxRewardLevelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BoxRewardLevelFindFirstOrThrowArgs>
    ): Prisma__BoxRewardLevelClient<BoxRewardLevelGetPayload<T>>

    /**
     * Find zero or more BoxRewardLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxRewardLevelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoxRewardLevels
     * const boxRewardLevels = await prisma.boxRewardLevel.findMany()
     * 
     * // Get first 10 BoxRewardLevels
     * const boxRewardLevels = await prisma.boxRewardLevel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boxRewardLevelWithIdOnly = await prisma.boxRewardLevel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BoxRewardLevelFindManyArgs>(
      args?: SelectSubset<T, BoxRewardLevelFindManyArgs>
    ): Prisma.PrismaPromise<Array<BoxRewardLevelGetPayload<T>>>

    /**
     * Create a BoxRewardLevel.
     * @param {BoxRewardLevelCreateArgs} args - Arguments to create a BoxRewardLevel.
     * @example
     * // Create one BoxRewardLevel
     * const BoxRewardLevel = await prisma.boxRewardLevel.create({
     *   data: {
     *     // ... data to create a BoxRewardLevel
     *   }
     * })
     * 
    **/
    create<T extends BoxRewardLevelCreateArgs>(
      args: SelectSubset<T, BoxRewardLevelCreateArgs>
    ): Prisma__BoxRewardLevelClient<BoxRewardLevelGetPayload<T>>

    /**
     * Create many BoxRewardLevels.
     *     @param {BoxRewardLevelCreateManyArgs} args - Arguments to create many BoxRewardLevels.
     *     @example
     *     // Create many BoxRewardLevels
     *     const boxRewardLevel = await prisma.boxRewardLevel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BoxRewardLevelCreateManyArgs>(
      args?: SelectSubset<T, BoxRewardLevelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BoxRewardLevel.
     * @param {BoxRewardLevelDeleteArgs} args - Arguments to delete one BoxRewardLevel.
     * @example
     * // Delete one BoxRewardLevel
     * const BoxRewardLevel = await prisma.boxRewardLevel.delete({
     *   where: {
     *     // ... filter to delete one BoxRewardLevel
     *   }
     * })
     * 
    **/
    delete<T extends BoxRewardLevelDeleteArgs>(
      args: SelectSubset<T, BoxRewardLevelDeleteArgs>
    ): Prisma__BoxRewardLevelClient<BoxRewardLevelGetPayload<T>>

    /**
     * Update one BoxRewardLevel.
     * @param {BoxRewardLevelUpdateArgs} args - Arguments to update one BoxRewardLevel.
     * @example
     * // Update one BoxRewardLevel
     * const boxRewardLevel = await prisma.boxRewardLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BoxRewardLevelUpdateArgs>(
      args: SelectSubset<T, BoxRewardLevelUpdateArgs>
    ): Prisma__BoxRewardLevelClient<BoxRewardLevelGetPayload<T>>

    /**
     * Delete zero or more BoxRewardLevels.
     * @param {BoxRewardLevelDeleteManyArgs} args - Arguments to filter BoxRewardLevels to delete.
     * @example
     * // Delete a few BoxRewardLevels
     * const { count } = await prisma.boxRewardLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BoxRewardLevelDeleteManyArgs>(
      args?: SelectSubset<T, BoxRewardLevelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoxRewardLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxRewardLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoxRewardLevels
     * const boxRewardLevel = await prisma.boxRewardLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BoxRewardLevelUpdateManyArgs>(
      args: SelectSubset<T, BoxRewardLevelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BoxRewardLevel.
     * @param {BoxRewardLevelUpsertArgs} args - Arguments to update or create a BoxRewardLevel.
     * @example
     * // Update or create a BoxRewardLevel
     * const boxRewardLevel = await prisma.boxRewardLevel.upsert({
     *   create: {
     *     // ... data to create a BoxRewardLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoxRewardLevel we want to update
     *   }
     * })
    **/
    upsert<T extends BoxRewardLevelUpsertArgs>(
      args: SelectSubset<T, BoxRewardLevelUpsertArgs>
    ): Prisma__BoxRewardLevelClient<BoxRewardLevelGetPayload<T>>

    /**
     * Find zero or more BoxRewardLevels that matches the filter.
     * @param {BoxRewardLevelFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const boxRewardLevel = await prisma.boxRewardLevel.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: BoxRewardLevelFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a BoxRewardLevel.
     * @param {BoxRewardLevelAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const boxRewardLevel = await prisma.boxRewardLevel.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: BoxRewardLevelAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of BoxRewardLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxRewardLevelCountArgs} args - Arguments to filter BoxRewardLevels to count.
     * @example
     * // Count the number of BoxRewardLevels
     * const count = await prisma.boxRewardLevel.count({
     *   where: {
     *     // ... the filter for the BoxRewardLevels we want to count
     *   }
     * })
    **/
    count<T extends BoxRewardLevelCountArgs>(
      args?: Subset<T, BoxRewardLevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoxRewardLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoxRewardLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxRewardLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoxRewardLevelAggregateArgs>(args: Subset<T, BoxRewardLevelAggregateArgs>): Prisma.PrismaPromise<GetBoxRewardLevelAggregateType<T>>

    /**
     * Group by BoxRewardLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxRewardLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoxRewardLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoxRewardLevelGroupByArgs['orderBy'] }
        : { orderBy?: BoxRewardLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoxRewardLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoxRewardLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BoxRewardLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BoxRewardLevelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    box<T extends BoxArgs= {}>(args?: Subset<T, BoxArgs>): Prisma__BoxClient<BoxGetPayload<T> | Null>;

    rewardLevel<T extends RewardLevelArgs= {}>(args?: Subset<T, RewardLevelArgs>): Prisma__RewardLevelClient<RewardLevelGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BoxRewardLevel base type for findUnique actions
   */
  export type BoxRewardLevelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BoxRewardLevel
     */
    select?: BoxRewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxRewardLevelInclude | null
    /**
     * Filter, which BoxRewardLevel to fetch.
     */
    where: BoxRewardLevelWhereUniqueInput
  }

  /**
   * BoxRewardLevel findUnique
   */
  export interface BoxRewardLevelFindUniqueArgs extends BoxRewardLevelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoxRewardLevel findUniqueOrThrow
   */
  export type BoxRewardLevelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoxRewardLevel
     */
    select?: BoxRewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxRewardLevelInclude | null
    /**
     * Filter, which BoxRewardLevel to fetch.
     */
    where: BoxRewardLevelWhereUniqueInput
  }


  /**
   * BoxRewardLevel base type for findFirst actions
   */
  export type BoxRewardLevelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BoxRewardLevel
     */
    select?: BoxRewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxRewardLevelInclude | null
    /**
     * Filter, which BoxRewardLevel to fetch.
     */
    where?: BoxRewardLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoxRewardLevels to fetch.
     */
    orderBy?: Enumerable<BoxRewardLevelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoxRewardLevels.
     */
    cursor?: BoxRewardLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoxRewardLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoxRewardLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoxRewardLevels.
     */
    distinct?: Enumerable<BoxRewardLevelScalarFieldEnum>
  }

  /**
   * BoxRewardLevel findFirst
   */
  export interface BoxRewardLevelFindFirstArgs extends BoxRewardLevelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoxRewardLevel findFirstOrThrow
   */
  export type BoxRewardLevelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoxRewardLevel
     */
    select?: BoxRewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxRewardLevelInclude | null
    /**
     * Filter, which BoxRewardLevel to fetch.
     */
    where?: BoxRewardLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoxRewardLevels to fetch.
     */
    orderBy?: Enumerable<BoxRewardLevelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoxRewardLevels.
     */
    cursor?: BoxRewardLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoxRewardLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoxRewardLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoxRewardLevels.
     */
    distinct?: Enumerable<BoxRewardLevelScalarFieldEnum>
  }


  /**
   * BoxRewardLevel findMany
   */
  export type BoxRewardLevelFindManyArgs = {
    /**
     * Select specific fields to fetch from the BoxRewardLevel
     */
    select?: BoxRewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxRewardLevelInclude | null
    /**
     * Filter, which BoxRewardLevels to fetch.
     */
    where?: BoxRewardLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoxRewardLevels to fetch.
     */
    orderBy?: Enumerable<BoxRewardLevelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoxRewardLevels.
     */
    cursor?: BoxRewardLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoxRewardLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoxRewardLevels.
     */
    skip?: number
    distinct?: Enumerable<BoxRewardLevelScalarFieldEnum>
  }


  /**
   * BoxRewardLevel create
   */
  export type BoxRewardLevelCreateArgs = {
    /**
     * Select specific fields to fetch from the BoxRewardLevel
     */
    select?: BoxRewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxRewardLevelInclude | null
    /**
     * The data needed to create a BoxRewardLevel.
     */
    data: XOR<BoxRewardLevelCreateInput, BoxRewardLevelUncheckedCreateInput>
  }


  /**
   * BoxRewardLevel createMany
   */
  export type BoxRewardLevelCreateManyArgs = {
    /**
     * The data used to create many BoxRewardLevels.
     */
    data: Enumerable<BoxRewardLevelCreateManyInput>
  }


  /**
   * BoxRewardLevel update
   */
  export type BoxRewardLevelUpdateArgs = {
    /**
     * Select specific fields to fetch from the BoxRewardLevel
     */
    select?: BoxRewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxRewardLevelInclude | null
    /**
     * The data needed to update a BoxRewardLevel.
     */
    data: XOR<BoxRewardLevelUpdateInput, BoxRewardLevelUncheckedUpdateInput>
    /**
     * Choose, which BoxRewardLevel to update.
     */
    where: BoxRewardLevelWhereUniqueInput
  }


  /**
   * BoxRewardLevel updateMany
   */
  export type BoxRewardLevelUpdateManyArgs = {
    /**
     * The data used to update BoxRewardLevels.
     */
    data: XOR<BoxRewardLevelUpdateManyMutationInput, BoxRewardLevelUncheckedUpdateManyInput>
    /**
     * Filter which BoxRewardLevels to update
     */
    where?: BoxRewardLevelWhereInput
  }


  /**
   * BoxRewardLevel upsert
   */
  export type BoxRewardLevelUpsertArgs = {
    /**
     * Select specific fields to fetch from the BoxRewardLevel
     */
    select?: BoxRewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxRewardLevelInclude | null
    /**
     * The filter to search for the BoxRewardLevel to update in case it exists.
     */
    where: BoxRewardLevelWhereUniqueInput
    /**
     * In case the BoxRewardLevel found by the `where` argument doesn't exist, create a new BoxRewardLevel with this data.
     */
    create: XOR<BoxRewardLevelCreateInput, BoxRewardLevelUncheckedCreateInput>
    /**
     * In case the BoxRewardLevel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoxRewardLevelUpdateInput, BoxRewardLevelUncheckedUpdateInput>
  }


  /**
   * BoxRewardLevel delete
   */
  export type BoxRewardLevelDeleteArgs = {
    /**
     * Select specific fields to fetch from the BoxRewardLevel
     */
    select?: BoxRewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxRewardLevelInclude | null
    /**
     * Filter which BoxRewardLevel to delete.
     */
    where: BoxRewardLevelWhereUniqueInput
  }


  /**
   * BoxRewardLevel deleteMany
   */
  export type BoxRewardLevelDeleteManyArgs = {
    /**
     * Filter which BoxRewardLevels to delete
     */
    where?: BoxRewardLevelWhereInput
  }


  /**
   * BoxRewardLevel findRaw
   */
  export type BoxRewardLevelFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * BoxRewardLevel aggregateRaw
   */
  export type BoxRewardLevelAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * BoxRewardLevel without action
   */
  export type BoxRewardLevelArgs = {
    /**
     * Select specific fields to fetch from the BoxRewardLevel
     */
    select?: BoxRewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxRewardLevelInclude | null
  }



  /**
   * Model RewardLevel
   */


  export type AggregateRewardLevel = {
    _count: RewardLevelCountAggregateOutputType | null
    _avg: RewardLevelAvgAggregateOutputType | null
    _sum: RewardLevelSumAggregateOutputType | null
    _min: RewardLevelMinAggregateOutputType | null
    _max: RewardLevelMaxAggregateOutputType | null
  }

  export type RewardLevelAvgAggregateOutputType = {
    orderNumber: number | null
    unlockThreshold: number | null
  }

  export type RewardLevelSumAggregateOutputType = {
    orderNumber: number | null
    unlockThreshold: number | null
  }

  export type RewardLevelMinAggregateOutputType = {
    id: string | null
    orderNumber: number | null
    name: string | null
    unlockThreshold: number | null
    description: string | null
  }

  export type RewardLevelMaxAggregateOutputType = {
    id: string | null
    orderNumber: number | null
    name: string | null
    unlockThreshold: number | null
    description: string | null
  }

  export type RewardLevelCountAggregateOutputType = {
    id: number
    orderNumber: number
    name: number
    unlockThreshold: number
    description: number
    _all: number
  }


  export type RewardLevelAvgAggregateInputType = {
    orderNumber?: true
    unlockThreshold?: true
  }

  export type RewardLevelSumAggregateInputType = {
    orderNumber?: true
    unlockThreshold?: true
  }

  export type RewardLevelMinAggregateInputType = {
    id?: true
    orderNumber?: true
    name?: true
    unlockThreshold?: true
    description?: true
  }

  export type RewardLevelMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    name?: true
    unlockThreshold?: true
    description?: true
  }

  export type RewardLevelCountAggregateInputType = {
    id?: true
    orderNumber?: true
    name?: true
    unlockThreshold?: true
    description?: true
    _all?: true
  }

  export type RewardLevelAggregateArgs = {
    /**
     * Filter which RewardLevel to aggregate.
     */
    where?: RewardLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardLevels to fetch.
     */
    orderBy?: Enumerable<RewardLevelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RewardLevels
    **/
    _count?: true | RewardLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardLevelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardLevelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardLevelMaxAggregateInputType
  }

  export type GetRewardLevelAggregateType<T extends RewardLevelAggregateArgs> = {
        [P in keyof T & keyof AggregateRewardLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRewardLevel[P]>
      : GetScalarType<T[P], AggregateRewardLevel[P]>
  }




  export type RewardLevelGroupByArgs = {
    where?: RewardLevelWhereInput
    orderBy?: Enumerable<RewardLevelOrderByWithAggregationInput>
    by: RewardLevelScalarFieldEnum[]
    having?: RewardLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardLevelCountAggregateInputType | true
    _avg?: RewardLevelAvgAggregateInputType
    _sum?: RewardLevelSumAggregateInputType
    _min?: RewardLevelMinAggregateInputType
    _max?: RewardLevelMaxAggregateInputType
  }


  export type RewardLevelGroupByOutputType = {
    id: string
    orderNumber: number
    name: string
    unlockThreshold: number
    description: string | null
    _count: RewardLevelCountAggregateOutputType | null
    _avg: RewardLevelAvgAggregateOutputType | null
    _sum: RewardLevelSumAggregateOutputType | null
    _min: RewardLevelMinAggregateOutputType | null
    _max: RewardLevelMaxAggregateOutputType | null
  }

  type GetRewardLevelGroupByPayload<T extends RewardLevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RewardLevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardLevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardLevelGroupByOutputType[P]>
            : GetScalarType<T[P], RewardLevelGroupByOutputType[P]>
        }
      >
    >


  export type RewardLevelSelect = {
    id?: boolean
    orderNumber?: boolean
    name?: boolean
    unlockThreshold?: boolean
    description?: boolean
    boxRewardLevel?: boolean | RewardLevel$boxRewardLevelArgs
    _count?: boolean | RewardLevelCountOutputTypeArgs
  }


  export type RewardLevelInclude = {
    boxRewardLevel?: boolean | RewardLevel$boxRewardLevelArgs
    _count?: boolean | RewardLevelCountOutputTypeArgs
  }

  export type RewardLevelGetPayload<S extends boolean | null | undefined | RewardLevelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RewardLevel :
    S extends undefined ? never :
    S extends { include: any } & (RewardLevelArgs | RewardLevelFindManyArgs)
    ? RewardLevel  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'boxRewardLevel' ? Array < BoxRewardLevelGetPayload<S['include'][P]>>  :
        P extends '_count' ? RewardLevelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RewardLevelArgs | RewardLevelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'boxRewardLevel' ? Array < BoxRewardLevelGetPayload<S['select'][P]>>  :
        P extends '_count' ? RewardLevelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof RewardLevel ? RewardLevel[P] : never
  } 
      : RewardLevel


  type RewardLevelCountArgs = 
    Omit<RewardLevelFindManyArgs, 'select' | 'include'> & {
      select?: RewardLevelCountAggregateInputType | true
    }

  export interface RewardLevelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one RewardLevel that matches the filter.
     * @param {RewardLevelFindUniqueArgs} args - Arguments to find a RewardLevel
     * @example
     * // Get one RewardLevel
     * const rewardLevel = await prisma.rewardLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RewardLevelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RewardLevelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RewardLevel'> extends True ? Prisma__RewardLevelClient<RewardLevelGetPayload<T>> : Prisma__RewardLevelClient<RewardLevelGetPayload<T> | null, null>

    /**
     * Find one RewardLevel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RewardLevelFindUniqueOrThrowArgs} args - Arguments to find a RewardLevel
     * @example
     * // Get one RewardLevel
     * const rewardLevel = await prisma.rewardLevel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RewardLevelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RewardLevelFindUniqueOrThrowArgs>
    ): Prisma__RewardLevelClient<RewardLevelGetPayload<T>>

    /**
     * Find the first RewardLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardLevelFindFirstArgs} args - Arguments to find a RewardLevel
     * @example
     * // Get one RewardLevel
     * const rewardLevel = await prisma.rewardLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RewardLevelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RewardLevelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RewardLevel'> extends True ? Prisma__RewardLevelClient<RewardLevelGetPayload<T>> : Prisma__RewardLevelClient<RewardLevelGetPayload<T> | null, null>

    /**
     * Find the first RewardLevel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardLevelFindFirstOrThrowArgs} args - Arguments to find a RewardLevel
     * @example
     * // Get one RewardLevel
     * const rewardLevel = await prisma.rewardLevel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RewardLevelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RewardLevelFindFirstOrThrowArgs>
    ): Prisma__RewardLevelClient<RewardLevelGetPayload<T>>

    /**
     * Find zero or more RewardLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardLevelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RewardLevels
     * const rewardLevels = await prisma.rewardLevel.findMany()
     * 
     * // Get first 10 RewardLevels
     * const rewardLevels = await prisma.rewardLevel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardLevelWithIdOnly = await prisma.rewardLevel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RewardLevelFindManyArgs>(
      args?: SelectSubset<T, RewardLevelFindManyArgs>
    ): Prisma.PrismaPromise<Array<RewardLevelGetPayload<T>>>

    /**
     * Create a RewardLevel.
     * @param {RewardLevelCreateArgs} args - Arguments to create a RewardLevel.
     * @example
     * // Create one RewardLevel
     * const RewardLevel = await prisma.rewardLevel.create({
     *   data: {
     *     // ... data to create a RewardLevel
     *   }
     * })
     * 
    **/
    create<T extends RewardLevelCreateArgs>(
      args: SelectSubset<T, RewardLevelCreateArgs>
    ): Prisma__RewardLevelClient<RewardLevelGetPayload<T>>

    /**
     * Create many RewardLevels.
     *     @param {RewardLevelCreateManyArgs} args - Arguments to create many RewardLevels.
     *     @example
     *     // Create many RewardLevels
     *     const rewardLevel = await prisma.rewardLevel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RewardLevelCreateManyArgs>(
      args?: SelectSubset<T, RewardLevelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RewardLevel.
     * @param {RewardLevelDeleteArgs} args - Arguments to delete one RewardLevel.
     * @example
     * // Delete one RewardLevel
     * const RewardLevel = await prisma.rewardLevel.delete({
     *   where: {
     *     // ... filter to delete one RewardLevel
     *   }
     * })
     * 
    **/
    delete<T extends RewardLevelDeleteArgs>(
      args: SelectSubset<T, RewardLevelDeleteArgs>
    ): Prisma__RewardLevelClient<RewardLevelGetPayload<T>>

    /**
     * Update one RewardLevel.
     * @param {RewardLevelUpdateArgs} args - Arguments to update one RewardLevel.
     * @example
     * // Update one RewardLevel
     * const rewardLevel = await prisma.rewardLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RewardLevelUpdateArgs>(
      args: SelectSubset<T, RewardLevelUpdateArgs>
    ): Prisma__RewardLevelClient<RewardLevelGetPayload<T>>

    /**
     * Delete zero or more RewardLevels.
     * @param {RewardLevelDeleteManyArgs} args - Arguments to filter RewardLevels to delete.
     * @example
     * // Delete a few RewardLevels
     * const { count } = await prisma.rewardLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RewardLevelDeleteManyArgs>(
      args?: SelectSubset<T, RewardLevelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RewardLevels
     * const rewardLevel = await prisma.rewardLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RewardLevelUpdateManyArgs>(
      args: SelectSubset<T, RewardLevelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RewardLevel.
     * @param {RewardLevelUpsertArgs} args - Arguments to update or create a RewardLevel.
     * @example
     * // Update or create a RewardLevel
     * const rewardLevel = await prisma.rewardLevel.upsert({
     *   create: {
     *     // ... data to create a RewardLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RewardLevel we want to update
     *   }
     * })
    **/
    upsert<T extends RewardLevelUpsertArgs>(
      args: SelectSubset<T, RewardLevelUpsertArgs>
    ): Prisma__RewardLevelClient<RewardLevelGetPayload<T>>

    /**
     * Find zero or more RewardLevels that matches the filter.
     * @param {RewardLevelFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const rewardLevel = await prisma.rewardLevel.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: RewardLevelFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a RewardLevel.
     * @param {RewardLevelAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const rewardLevel = await prisma.rewardLevel.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: RewardLevelAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of RewardLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardLevelCountArgs} args - Arguments to filter RewardLevels to count.
     * @example
     * // Count the number of RewardLevels
     * const count = await prisma.rewardLevel.count({
     *   where: {
     *     // ... the filter for the RewardLevels we want to count
     *   }
     * })
    **/
    count<T extends RewardLevelCountArgs>(
      args?: Subset<T, RewardLevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RewardLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardLevelAggregateArgs>(args: Subset<T, RewardLevelAggregateArgs>): Prisma.PrismaPromise<GetRewardLevelAggregateType<T>>

    /**
     * Group by RewardLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardLevelGroupByArgs['orderBy'] }
        : { orderBy?: RewardLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for RewardLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RewardLevelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    boxRewardLevel<T extends RewardLevel$boxRewardLevelArgs= {}>(args?: Subset<T, RewardLevel$boxRewardLevelArgs>): Prisma.PrismaPromise<Array<BoxRewardLevelGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * RewardLevel base type for findUnique actions
   */
  export type RewardLevelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the RewardLevel
     */
    select?: RewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RewardLevelInclude | null
    /**
     * Filter, which RewardLevel to fetch.
     */
    where: RewardLevelWhereUniqueInput
  }

  /**
   * RewardLevel findUnique
   */
  export interface RewardLevelFindUniqueArgs extends RewardLevelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RewardLevel findUniqueOrThrow
   */
  export type RewardLevelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RewardLevel
     */
    select?: RewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RewardLevelInclude | null
    /**
     * Filter, which RewardLevel to fetch.
     */
    where: RewardLevelWhereUniqueInput
  }


  /**
   * RewardLevel base type for findFirst actions
   */
  export type RewardLevelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the RewardLevel
     */
    select?: RewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RewardLevelInclude | null
    /**
     * Filter, which RewardLevel to fetch.
     */
    where?: RewardLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardLevels to fetch.
     */
    orderBy?: Enumerable<RewardLevelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardLevels.
     */
    cursor?: RewardLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardLevels.
     */
    distinct?: Enumerable<RewardLevelScalarFieldEnum>
  }

  /**
   * RewardLevel findFirst
   */
  export interface RewardLevelFindFirstArgs extends RewardLevelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * RewardLevel findFirstOrThrow
   */
  export type RewardLevelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the RewardLevel
     */
    select?: RewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RewardLevelInclude | null
    /**
     * Filter, which RewardLevel to fetch.
     */
    where?: RewardLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardLevels to fetch.
     */
    orderBy?: Enumerable<RewardLevelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardLevels.
     */
    cursor?: RewardLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardLevels.
     */
    distinct?: Enumerable<RewardLevelScalarFieldEnum>
  }


  /**
   * RewardLevel findMany
   */
  export type RewardLevelFindManyArgs = {
    /**
     * Select specific fields to fetch from the RewardLevel
     */
    select?: RewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RewardLevelInclude | null
    /**
     * Filter, which RewardLevels to fetch.
     */
    where?: RewardLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardLevels to fetch.
     */
    orderBy?: Enumerable<RewardLevelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RewardLevels.
     */
    cursor?: RewardLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardLevels.
     */
    skip?: number
    distinct?: Enumerable<RewardLevelScalarFieldEnum>
  }


  /**
   * RewardLevel create
   */
  export type RewardLevelCreateArgs = {
    /**
     * Select specific fields to fetch from the RewardLevel
     */
    select?: RewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RewardLevelInclude | null
    /**
     * The data needed to create a RewardLevel.
     */
    data: XOR<RewardLevelCreateInput, RewardLevelUncheckedCreateInput>
  }


  /**
   * RewardLevel createMany
   */
  export type RewardLevelCreateManyArgs = {
    /**
     * The data used to create many RewardLevels.
     */
    data: Enumerable<RewardLevelCreateManyInput>
  }


  /**
   * RewardLevel update
   */
  export type RewardLevelUpdateArgs = {
    /**
     * Select specific fields to fetch from the RewardLevel
     */
    select?: RewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RewardLevelInclude | null
    /**
     * The data needed to update a RewardLevel.
     */
    data: XOR<RewardLevelUpdateInput, RewardLevelUncheckedUpdateInput>
    /**
     * Choose, which RewardLevel to update.
     */
    where: RewardLevelWhereUniqueInput
  }


  /**
   * RewardLevel updateMany
   */
  export type RewardLevelUpdateManyArgs = {
    /**
     * The data used to update RewardLevels.
     */
    data: XOR<RewardLevelUpdateManyMutationInput, RewardLevelUncheckedUpdateManyInput>
    /**
     * Filter which RewardLevels to update
     */
    where?: RewardLevelWhereInput
  }


  /**
   * RewardLevel upsert
   */
  export type RewardLevelUpsertArgs = {
    /**
     * Select specific fields to fetch from the RewardLevel
     */
    select?: RewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RewardLevelInclude | null
    /**
     * The filter to search for the RewardLevel to update in case it exists.
     */
    where: RewardLevelWhereUniqueInput
    /**
     * In case the RewardLevel found by the `where` argument doesn't exist, create a new RewardLevel with this data.
     */
    create: XOR<RewardLevelCreateInput, RewardLevelUncheckedCreateInput>
    /**
     * In case the RewardLevel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardLevelUpdateInput, RewardLevelUncheckedUpdateInput>
  }


  /**
   * RewardLevel delete
   */
  export type RewardLevelDeleteArgs = {
    /**
     * Select specific fields to fetch from the RewardLevel
     */
    select?: RewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RewardLevelInclude | null
    /**
     * Filter which RewardLevel to delete.
     */
    where: RewardLevelWhereUniqueInput
  }


  /**
   * RewardLevel deleteMany
   */
  export type RewardLevelDeleteManyArgs = {
    /**
     * Filter which RewardLevels to delete
     */
    where?: RewardLevelWhereInput
  }


  /**
   * RewardLevel findRaw
   */
  export type RewardLevelFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * RewardLevel aggregateRaw
   */
  export type RewardLevelAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * RewardLevel.boxRewardLevel
   */
  export type RewardLevel$boxRewardLevelArgs = {
    /**
     * Select specific fields to fetch from the BoxRewardLevel
     */
    select?: BoxRewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxRewardLevelInclude | null
    where?: BoxRewardLevelWhereInput
    orderBy?: Enumerable<BoxRewardLevelOrderByWithRelationInput>
    cursor?: BoxRewardLevelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BoxRewardLevelScalarFieldEnum>
  }


  /**
   * RewardLevel without action
   */
  export type RewardLevelArgs = {
    /**
     * Select specific fields to fetch from the RewardLevel
     */
    select?: RewardLevelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RewardLevelInclude | null
  }



  /**
   * Model BoxImage
   */


  export type AggregateBoxImage = {
    _count: BoxImageCountAggregateOutputType | null
    _min: BoxImageMinAggregateOutputType | null
    _max: BoxImageMaxAggregateOutputType | null
  }

  export type BoxImageMinAggregateOutputType = {
    id: string | null
    photoUrl: string | null
    status: EnumBoxImageStatus | null
    boxId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BoxImageMaxAggregateOutputType = {
    id: string | null
    photoUrl: string | null
    status: EnumBoxImageStatus | null
    boxId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BoxImageCountAggregateOutputType = {
    id: number
    photoUrl: number
    status: number
    boxId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BoxImageMinAggregateInputType = {
    id?: true
    photoUrl?: true
    status?: true
    boxId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BoxImageMaxAggregateInputType = {
    id?: true
    photoUrl?: true
    status?: true
    boxId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BoxImageCountAggregateInputType = {
    id?: true
    photoUrl?: true
    status?: true
    boxId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BoxImageAggregateArgs = {
    /**
     * Filter which BoxImage to aggregate.
     */
    where?: BoxImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoxImages to fetch.
     */
    orderBy?: Enumerable<BoxImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoxImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoxImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoxImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoxImages
    **/
    _count?: true | BoxImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoxImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoxImageMaxAggregateInputType
  }

  export type GetBoxImageAggregateType<T extends BoxImageAggregateArgs> = {
        [P in keyof T & keyof AggregateBoxImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoxImage[P]>
      : GetScalarType<T[P], AggregateBoxImage[P]>
  }




  export type BoxImageGroupByArgs = {
    where?: BoxImageWhereInput
    orderBy?: Enumerable<BoxImageOrderByWithAggregationInput>
    by: BoxImageScalarFieldEnum[]
    having?: BoxImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoxImageCountAggregateInputType | true
    _min?: BoxImageMinAggregateInputType
    _max?: BoxImageMaxAggregateInputType
  }


  export type BoxImageGroupByOutputType = {
    id: string
    photoUrl: string
    status: EnumBoxImageStatus
    boxId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: BoxImageCountAggregateOutputType | null
    _min: BoxImageMinAggregateOutputType | null
    _max: BoxImageMaxAggregateOutputType | null
  }

  type GetBoxImageGroupByPayload<T extends BoxImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BoxImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoxImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoxImageGroupByOutputType[P]>
            : GetScalarType<T[P], BoxImageGroupByOutputType[P]>
        }
      >
    >


  export type BoxImageSelect = {
    id?: boolean
    photoUrl?: boolean
    status?: boolean
    boxId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    box?: boolean | BoxArgs
  }


  export type BoxImageInclude = {
    box?: boolean | BoxArgs
  }

  export type BoxImageGetPayload<S extends boolean | null | undefined | BoxImageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BoxImage :
    S extends undefined ? never :
    S extends { include: any } & (BoxImageArgs | BoxImageFindManyArgs)
    ? BoxImage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'box' ? BoxGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BoxImageArgs | BoxImageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'box' ? BoxGetPayload<S['select'][P]> :  P extends keyof BoxImage ? BoxImage[P] : never
  } 
      : BoxImage


  type BoxImageCountArgs = 
    Omit<BoxImageFindManyArgs, 'select' | 'include'> & {
      select?: BoxImageCountAggregateInputType | true
    }

  export interface BoxImageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BoxImage that matches the filter.
     * @param {BoxImageFindUniqueArgs} args - Arguments to find a BoxImage
     * @example
     * // Get one BoxImage
     * const boxImage = await prisma.boxImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BoxImageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BoxImageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BoxImage'> extends True ? Prisma__BoxImageClient<BoxImageGetPayload<T>> : Prisma__BoxImageClient<BoxImageGetPayload<T> | null, null>

    /**
     * Find one BoxImage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BoxImageFindUniqueOrThrowArgs} args - Arguments to find a BoxImage
     * @example
     * // Get one BoxImage
     * const boxImage = await prisma.boxImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BoxImageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BoxImageFindUniqueOrThrowArgs>
    ): Prisma__BoxImageClient<BoxImageGetPayload<T>>

    /**
     * Find the first BoxImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxImageFindFirstArgs} args - Arguments to find a BoxImage
     * @example
     * // Get one BoxImage
     * const boxImage = await prisma.boxImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BoxImageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BoxImageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BoxImage'> extends True ? Prisma__BoxImageClient<BoxImageGetPayload<T>> : Prisma__BoxImageClient<BoxImageGetPayload<T> | null, null>

    /**
     * Find the first BoxImage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxImageFindFirstOrThrowArgs} args - Arguments to find a BoxImage
     * @example
     * // Get one BoxImage
     * const boxImage = await prisma.boxImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BoxImageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BoxImageFindFirstOrThrowArgs>
    ): Prisma__BoxImageClient<BoxImageGetPayload<T>>

    /**
     * Find zero or more BoxImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoxImages
     * const boxImages = await prisma.boxImage.findMany()
     * 
     * // Get first 10 BoxImages
     * const boxImages = await prisma.boxImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boxImageWithIdOnly = await prisma.boxImage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BoxImageFindManyArgs>(
      args?: SelectSubset<T, BoxImageFindManyArgs>
    ): Prisma.PrismaPromise<Array<BoxImageGetPayload<T>>>

    /**
     * Create a BoxImage.
     * @param {BoxImageCreateArgs} args - Arguments to create a BoxImage.
     * @example
     * // Create one BoxImage
     * const BoxImage = await prisma.boxImage.create({
     *   data: {
     *     // ... data to create a BoxImage
     *   }
     * })
     * 
    **/
    create<T extends BoxImageCreateArgs>(
      args: SelectSubset<T, BoxImageCreateArgs>
    ): Prisma__BoxImageClient<BoxImageGetPayload<T>>

    /**
     * Create many BoxImages.
     *     @param {BoxImageCreateManyArgs} args - Arguments to create many BoxImages.
     *     @example
     *     // Create many BoxImages
     *     const boxImage = await prisma.boxImage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BoxImageCreateManyArgs>(
      args?: SelectSubset<T, BoxImageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BoxImage.
     * @param {BoxImageDeleteArgs} args - Arguments to delete one BoxImage.
     * @example
     * // Delete one BoxImage
     * const BoxImage = await prisma.boxImage.delete({
     *   where: {
     *     // ... filter to delete one BoxImage
     *   }
     * })
     * 
    **/
    delete<T extends BoxImageDeleteArgs>(
      args: SelectSubset<T, BoxImageDeleteArgs>
    ): Prisma__BoxImageClient<BoxImageGetPayload<T>>

    /**
     * Update one BoxImage.
     * @param {BoxImageUpdateArgs} args - Arguments to update one BoxImage.
     * @example
     * // Update one BoxImage
     * const boxImage = await prisma.boxImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BoxImageUpdateArgs>(
      args: SelectSubset<T, BoxImageUpdateArgs>
    ): Prisma__BoxImageClient<BoxImageGetPayload<T>>

    /**
     * Delete zero or more BoxImages.
     * @param {BoxImageDeleteManyArgs} args - Arguments to filter BoxImages to delete.
     * @example
     * // Delete a few BoxImages
     * const { count } = await prisma.boxImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BoxImageDeleteManyArgs>(
      args?: SelectSubset<T, BoxImageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoxImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoxImages
     * const boxImage = await prisma.boxImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BoxImageUpdateManyArgs>(
      args: SelectSubset<T, BoxImageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BoxImage.
     * @param {BoxImageUpsertArgs} args - Arguments to update or create a BoxImage.
     * @example
     * // Update or create a BoxImage
     * const boxImage = await prisma.boxImage.upsert({
     *   create: {
     *     // ... data to create a BoxImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoxImage we want to update
     *   }
     * })
    **/
    upsert<T extends BoxImageUpsertArgs>(
      args: SelectSubset<T, BoxImageUpsertArgs>
    ): Prisma__BoxImageClient<BoxImageGetPayload<T>>

    /**
     * Find zero or more BoxImages that matches the filter.
     * @param {BoxImageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const boxImage = await prisma.boxImage.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: BoxImageFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a BoxImage.
     * @param {BoxImageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const boxImage = await prisma.boxImage.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: BoxImageAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of BoxImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxImageCountArgs} args - Arguments to filter BoxImages to count.
     * @example
     * // Count the number of BoxImages
     * const count = await prisma.boxImage.count({
     *   where: {
     *     // ... the filter for the BoxImages we want to count
     *   }
     * })
    **/
    count<T extends BoxImageCountArgs>(
      args?: Subset<T, BoxImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoxImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoxImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoxImageAggregateArgs>(args: Subset<T, BoxImageAggregateArgs>): Prisma.PrismaPromise<GetBoxImageAggregateType<T>>

    /**
     * Group by BoxImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoxImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoxImageGroupByArgs['orderBy'] }
        : { orderBy?: BoxImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoxImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoxImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BoxImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BoxImageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    box<T extends BoxArgs= {}>(args?: Subset<T, BoxArgs>): Prisma__BoxClient<BoxGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BoxImage base type for findUnique actions
   */
  export type BoxImageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BoxImage
     */
    select?: BoxImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxImageInclude | null
    /**
     * Filter, which BoxImage to fetch.
     */
    where: BoxImageWhereUniqueInput
  }

  /**
   * BoxImage findUnique
   */
  export interface BoxImageFindUniqueArgs extends BoxImageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoxImage findUniqueOrThrow
   */
  export type BoxImageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoxImage
     */
    select?: BoxImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxImageInclude | null
    /**
     * Filter, which BoxImage to fetch.
     */
    where: BoxImageWhereUniqueInput
  }


  /**
   * BoxImage base type for findFirst actions
   */
  export type BoxImageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BoxImage
     */
    select?: BoxImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxImageInclude | null
    /**
     * Filter, which BoxImage to fetch.
     */
    where?: BoxImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoxImages to fetch.
     */
    orderBy?: Enumerable<BoxImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoxImages.
     */
    cursor?: BoxImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoxImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoxImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoxImages.
     */
    distinct?: Enumerable<BoxImageScalarFieldEnum>
  }

  /**
   * BoxImage findFirst
   */
  export interface BoxImageFindFirstArgs extends BoxImageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoxImage findFirstOrThrow
   */
  export type BoxImageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoxImage
     */
    select?: BoxImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxImageInclude | null
    /**
     * Filter, which BoxImage to fetch.
     */
    where?: BoxImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoxImages to fetch.
     */
    orderBy?: Enumerable<BoxImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoxImages.
     */
    cursor?: BoxImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoxImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoxImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoxImages.
     */
    distinct?: Enumerable<BoxImageScalarFieldEnum>
  }


  /**
   * BoxImage findMany
   */
  export type BoxImageFindManyArgs = {
    /**
     * Select specific fields to fetch from the BoxImage
     */
    select?: BoxImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxImageInclude | null
    /**
     * Filter, which BoxImages to fetch.
     */
    where?: BoxImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoxImages to fetch.
     */
    orderBy?: Enumerable<BoxImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoxImages.
     */
    cursor?: BoxImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoxImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoxImages.
     */
    skip?: number
    distinct?: Enumerable<BoxImageScalarFieldEnum>
  }


  /**
   * BoxImage create
   */
  export type BoxImageCreateArgs = {
    /**
     * Select specific fields to fetch from the BoxImage
     */
    select?: BoxImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxImageInclude | null
    /**
     * The data needed to create a BoxImage.
     */
    data: XOR<BoxImageCreateInput, BoxImageUncheckedCreateInput>
  }


  /**
   * BoxImage createMany
   */
  export type BoxImageCreateManyArgs = {
    /**
     * The data used to create many BoxImages.
     */
    data: Enumerable<BoxImageCreateManyInput>
  }


  /**
   * BoxImage update
   */
  export type BoxImageUpdateArgs = {
    /**
     * Select specific fields to fetch from the BoxImage
     */
    select?: BoxImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxImageInclude | null
    /**
     * The data needed to update a BoxImage.
     */
    data: XOR<BoxImageUpdateInput, BoxImageUncheckedUpdateInput>
    /**
     * Choose, which BoxImage to update.
     */
    where: BoxImageWhereUniqueInput
  }


  /**
   * BoxImage updateMany
   */
  export type BoxImageUpdateManyArgs = {
    /**
     * The data used to update BoxImages.
     */
    data: XOR<BoxImageUpdateManyMutationInput, BoxImageUncheckedUpdateManyInput>
    /**
     * Filter which BoxImages to update
     */
    where?: BoxImageWhereInput
  }


  /**
   * BoxImage upsert
   */
  export type BoxImageUpsertArgs = {
    /**
     * Select specific fields to fetch from the BoxImage
     */
    select?: BoxImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxImageInclude | null
    /**
     * The filter to search for the BoxImage to update in case it exists.
     */
    where: BoxImageWhereUniqueInput
    /**
     * In case the BoxImage found by the `where` argument doesn't exist, create a new BoxImage with this data.
     */
    create: XOR<BoxImageCreateInput, BoxImageUncheckedCreateInput>
    /**
     * In case the BoxImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoxImageUpdateInput, BoxImageUncheckedUpdateInput>
  }


  /**
   * BoxImage delete
   */
  export type BoxImageDeleteArgs = {
    /**
     * Select specific fields to fetch from the BoxImage
     */
    select?: BoxImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxImageInclude | null
    /**
     * Filter which BoxImage to delete.
     */
    where: BoxImageWhereUniqueInput
  }


  /**
   * BoxImage deleteMany
   */
  export type BoxImageDeleteManyArgs = {
    /**
     * Filter which BoxImages to delete
     */
    where?: BoxImageWhereInput
  }


  /**
   * BoxImage findRaw
   */
  export type BoxImageFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * BoxImage aggregateRaw
   */
  export type BoxImageAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * BoxImage without action
   */
  export type BoxImageArgs = {
    /**
     * Select specific fields to fetch from the BoxImage
     */
    select?: BoxImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxImageInclude | null
  }



  /**
   * Model Provider
   */


  export type AggregateProvider = {
    _count: ProviderCountAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  export type ProviderMinAggregateOutputType = {
    id: string | null
    reference: string | null
    companyName: string | null
    address: string | null
    phone: string | null
    webSite: string | null
    logo: string | null
    isPinned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProviderMaxAggregateOutputType = {
    id: string | null
    reference: string | null
    companyName: string | null
    address: string | null
    phone: string | null
    webSite: string | null
    logo: string | null
    isPinned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProviderCountAggregateOutputType = {
    id: number
    reference: number
    companyName: number
    address: number
    phone: number
    webSite: number
    logo: number
    isPinned: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProviderMinAggregateInputType = {
    id?: true
    reference?: true
    companyName?: true
    address?: true
    phone?: true
    webSite?: true
    logo?: true
    isPinned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProviderMaxAggregateInputType = {
    id?: true
    reference?: true
    companyName?: true
    address?: true
    phone?: true
    webSite?: true
    logo?: true
    isPinned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProviderCountAggregateInputType = {
    id?: true
    reference?: true
    companyName?: true
    address?: true
    phone?: true
    webSite?: true
    logo?: true
    isPinned?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProviderAggregateArgs = {
    /**
     * Filter which Provider to aggregate.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: Enumerable<ProviderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Providers
    **/
    _count?: true | ProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderMaxAggregateInputType
  }

  export type GetProviderAggregateType<T extends ProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider[P]>
      : GetScalarType<T[P], AggregateProvider[P]>
  }




  export type ProviderGroupByArgs = {
    where?: ProviderWhereInput
    orderBy?: Enumerable<ProviderOrderByWithAggregationInput>
    by: ProviderScalarFieldEnum[]
    having?: ProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderCountAggregateInputType | true
    _min?: ProviderMinAggregateInputType
    _max?: ProviderMaxAggregateInputType
  }


  export type ProviderGroupByOutputType = {
    id: string
    reference: string
    companyName: string
    address: string | null
    phone: string | null
    webSite: string | null
    logo: string | null
    isPinned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: ProviderCountAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  type GetProviderGroupByPayload<T extends ProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderGroupByOutputType[P]>
        }
      >
    >


  export type ProviderSelect = {
    id?: boolean
    reference?: boolean
    companyName?: boolean
    address?: boolean
    phone?: boolean
    webSite?: boolean
    logo?: boolean
    isPinned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    article?: boolean | Provider$articleArgs
    _count?: boolean | ProviderCountOutputTypeArgs
  }


  export type ProviderInclude = {
    article?: boolean | Provider$articleArgs
    _count?: boolean | ProviderCountOutputTypeArgs
  }

  export type ProviderGetPayload<S extends boolean | null | undefined | ProviderArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Provider :
    S extends undefined ? never :
    S extends { include: any } & (ProviderArgs | ProviderFindManyArgs)
    ? Provider  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'article' ? Array < ArticleGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProviderCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ProviderArgs | ProviderFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'article' ? Array < ArticleGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProviderCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Provider ? Provider[P] : never
  } 
      : Provider


  type ProviderCountArgs = 
    Omit<ProviderFindManyArgs, 'select' | 'include'> & {
      select?: ProviderCountAggregateInputType | true
    }

  export interface ProviderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Provider that matches the filter.
     * @param {ProviderFindUniqueArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProviderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProviderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Provider'> extends True ? Prisma__ProviderClient<ProviderGetPayload<T>> : Prisma__ProviderClient<ProviderGetPayload<T> | null, null>

    /**
     * Find one Provider that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProviderFindUniqueOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProviderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ProviderFindUniqueOrThrowArgs>
    ): Prisma__ProviderClient<ProviderGetPayload<T>>

    /**
     * Find the first Provider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProviderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProviderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Provider'> extends True ? Prisma__ProviderClient<ProviderGetPayload<T>> : Prisma__ProviderClient<ProviderGetPayload<T> | null, null>

    /**
     * Find the first Provider that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProviderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProviderFindFirstOrThrowArgs>
    ): Prisma__ProviderClient<ProviderGetPayload<T>>

    /**
     * Find zero or more Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Providers
     * const providers = await prisma.provider.findMany()
     * 
     * // Get first 10 Providers
     * const providers = await prisma.provider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providerWithIdOnly = await prisma.provider.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProviderFindManyArgs>(
      args?: SelectSubset<T, ProviderFindManyArgs>
    ): Prisma.PrismaPromise<Array<ProviderGetPayload<T>>>

    /**
     * Create a Provider.
     * @param {ProviderCreateArgs} args - Arguments to create a Provider.
     * @example
     * // Create one Provider
     * const Provider = await prisma.provider.create({
     *   data: {
     *     // ... data to create a Provider
     *   }
     * })
     * 
    **/
    create<T extends ProviderCreateArgs>(
      args: SelectSubset<T, ProviderCreateArgs>
    ): Prisma__ProviderClient<ProviderGetPayload<T>>

    /**
     * Create many Providers.
     *     @param {ProviderCreateManyArgs} args - Arguments to create many Providers.
     *     @example
     *     // Create many Providers
     *     const provider = await prisma.provider.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProviderCreateManyArgs>(
      args?: SelectSubset<T, ProviderCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Provider.
     * @param {ProviderDeleteArgs} args - Arguments to delete one Provider.
     * @example
     * // Delete one Provider
     * const Provider = await prisma.provider.delete({
     *   where: {
     *     // ... filter to delete one Provider
     *   }
     * })
     * 
    **/
    delete<T extends ProviderDeleteArgs>(
      args: SelectSubset<T, ProviderDeleteArgs>
    ): Prisma__ProviderClient<ProviderGetPayload<T>>

    /**
     * Update one Provider.
     * @param {ProviderUpdateArgs} args - Arguments to update one Provider.
     * @example
     * // Update one Provider
     * const provider = await prisma.provider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProviderUpdateArgs>(
      args: SelectSubset<T, ProviderUpdateArgs>
    ): Prisma__ProviderClient<ProviderGetPayload<T>>

    /**
     * Delete zero or more Providers.
     * @param {ProviderDeleteManyArgs} args - Arguments to filter Providers to delete.
     * @example
     * // Delete a few Providers
     * const { count } = await prisma.provider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProviderDeleteManyArgs>(
      args?: SelectSubset<T, ProviderDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Providers
     * const provider = await prisma.provider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProviderUpdateManyArgs>(
      args: SelectSubset<T, ProviderUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Provider.
     * @param {ProviderUpsertArgs} args - Arguments to update or create a Provider.
     * @example
     * // Update or create a Provider
     * const provider = await prisma.provider.upsert({
     *   create: {
     *     // ... data to create a Provider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider we want to update
     *   }
     * })
    **/
    upsert<T extends ProviderUpsertArgs>(
      args: SelectSubset<T, ProviderUpsertArgs>
    ): Prisma__ProviderClient<ProviderGetPayload<T>>

    /**
     * Find zero or more Providers that matches the filter.
     * @param {ProviderFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const provider = await prisma.provider.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ProviderFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Provider.
     * @param {ProviderAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const provider = await prisma.provider.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ProviderAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCountArgs} args - Arguments to filter Providers to count.
     * @example
     * // Count the number of Providers
     * const count = await prisma.provider.count({
     *   where: {
     *     // ... the filter for the Providers we want to count
     *   }
     * })
    **/
    count<T extends ProviderCountArgs>(
      args?: Subset<T, ProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderAggregateArgs>(args: Subset<T, ProviderAggregateArgs>): Prisma.PrismaPromise<GetProviderAggregateType<T>>

    /**
     * Group by Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderGroupByArgs['orderBy'] }
        : { orderBy?: ProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Provider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProviderClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    article<T extends Provider$articleArgs= {}>(args?: Subset<T, Provider$articleArgs>): Prisma.PrismaPromise<Array<ArticleGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Provider base type for findUnique actions
   */
  export type ProviderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider findUnique
   */
  export interface ProviderFindUniqueArgs extends ProviderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Provider findUniqueOrThrow
   */
  export type ProviderFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }


  /**
   * Provider base type for findFirst actions
   */
  export type ProviderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: Enumerable<ProviderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: Enumerable<ProviderScalarFieldEnum>
  }

  /**
   * Provider findFirst
   */
  export interface ProviderFindFirstArgs extends ProviderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Provider findFirstOrThrow
   */
  export type ProviderFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: Enumerable<ProviderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: Enumerable<ProviderScalarFieldEnum>
  }


  /**
   * Provider findMany
   */
  export type ProviderFindManyArgs = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude | null
    /**
     * Filter, which Providers to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: Enumerable<ProviderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    distinct?: Enumerable<ProviderScalarFieldEnum>
  }


  /**
   * Provider create
   */
  export type ProviderCreateArgs = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude | null
    /**
     * The data needed to create a Provider.
     */
    data: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
  }


  /**
   * Provider createMany
   */
  export type ProviderCreateManyArgs = {
    /**
     * The data used to create many Providers.
     */
    data: Enumerable<ProviderCreateManyInput>
  }


  /**
   * Provider update
   */
  export type ProviderUpdateArgs = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude | null
    /**
     * The data needed to update a Provider.
     */
    data: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
    /**
     * Choose, which Provider to update.
     */
    where: ProviderWhereUniqueInput
  }


  /**
   * Provider updateMany
   */
  export type ProviderUpdateManyArgs = {
    /**
     * The data used to update Providers.
     */
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyInput>
    /**
     * Filter which Providers to update
     */
    where?: ProviderWhereInput
  }


  /**
   * Provider upsert
   */
  export type ProviderUpsertArgs = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude | null
    /**
     * The filter to search for the Provider to update in case it exists.
     */
    where: ProviderWhereUniqueInput
    /**
     * In case the Provider found by the `where` argument doesn't exist, create a new Provider with this data.
     */
    create: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
    /**
     * In case the Provider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
  }


  /**
   * Provider delete
   */
  export type ProviderDeleteArgs = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude | null
    /**
     * Filter which Provider to delete.
     */
    where: ProviderWhereUniqueInput
  }


  /**
   * Provider deleteMany
   */
  export type ProviderDeleteManyArgs = {
    /**
     * Filter which Providers to delete
     */
    where?: ProviderWhereInput
  }


  /**
   * Provider findRaw
   */
  export type ProviderFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Provider aggregateRaw
   */
  export type ProviderAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Provider.article
   */
  export type Provider$articleArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    where?: ArticleWhereInput
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ArticleScalarFieldEnum>
  }


  /**
   * Provider without action
   */
  export type ProviderArgs = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProviderInclude | null
  }



  /**
   * Model Category
   */


  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    reference: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    reference: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    reference: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    reference?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    reference?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    reference?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs = {
    where?: CategoryWhereInput
    orderBy?: Enumerable<CategoryOrderByWithAggregationInput>
    by: CategoryScalarFieldEnum[]
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }


  export type CategoryGroupByOutputType = {
    id: string
    reference: string
    name: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect = {
    id?: boolean
    reference?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subCategory?: boolean | Category$subCategoryArgs
    _count?: boolean | CategoryCountOutputTypeArgs
  }


  export type CategoryInclude = {
    subCategory?: boolean | Category$subCategoryArgs
    _count?: boolean | CategoryCountOutputTypeArgs
  }

  export type CategoryGetPayload<S extends boolean | null | undefined | CategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Category :
    S extends undefined ? never :
    S extends { include: any } & (CategoryArgs | CategoryFindManyArgs)
    ? Category  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'subCategory' ? Array < SubCategoryGetPayload<S['include'][P]>>  :
        P extends '_count' ? CategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CategoryArgs | CategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'subCategory' ? Array < SubCategoryGetPayload<S['select'][P]>>  :
        P extends '_count' ? CategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Category ? Category[P] : never
  } 
      : Category


  type CategoryCountArgs = 
    Omit<CategoryFindManyArgs, 'select' | 'include'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Category'> extends True ? Prisma__CategoryClient<CategoryGetPayload<T>> : Prisma__CategoryClient<CategoryGetPayload<T> | null, null>

    /**
     * Find one Category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CategoryFindUniqueOrThrowArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Category'> extends True ? Prisma__CategoryClient<CategoryGetPayload<T>> : Prisma__CategoryClient<CategoryGetPayload<T> | null, null>

    /**
     * Find the first Category that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CategoryFindFirstOrThrowArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryFindManyArgs>(
      args?: SelectSubset<T, CategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<CategoryGetPayload<T>>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends CategoryCreateArgs>(
      args: SelectSubset<T, CategoryCreateArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Create many Categories.
     *     @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryCreateManyArgs>(
      args?: SelectSubset<T, CategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends CategoryDeleteArgs>(
      args: SelectSubset<T, CategoryDeleteArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryUpdateArgs>(
      args: SelectSubset<T, CategoryUpdateArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryDeleteManyArgs>(
      args?: SelectSubset<T, CategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryUpdateManyArgs>(
      args: SelectSubset<T, CategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryUpsertArgs>(
      args: SelectSubset<T, CategoryUpsertArgs>
    ): Prisma__CategoryClient<CategoryGetPayload<T>>

    /**
     * Find zero or more Categories that matches the filter.
     * @param {CategoryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const category = await prisma.category.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: CategoryFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Category.
     * @param {CategoryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const category = await prisma.category.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: CategoryAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    subCategory<T extends Category$subCategoryArgs= {}>(args?: Subset<T, Category$subCategoryArgs>): Prisma.PrismaPromise<Array<SubCategoryGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Category base type for findUnique actions
   */
  export type CategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUnique
   */
  export interface CategoryFindUniqueArgs extends CategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category base type for findFirst actions
   */
  export type CategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }

  /**
   * Category findFirst
   */
  export interface CategoryFindFirstArgs extends CategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category findMany
   */
  export type CategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: Enumerable<CategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: Enumerable<CategoryScalarFieldEnum>
  }


  /**
   * Category create
   */
  export type CategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }


  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs = {
    /**
     * The data used to create many Categories.
     */
    data: Enumerable<CategoryCreateManyInput>
  }


  /**
   * Category update
   */
  export type CategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }


  /**
   * Category upsert
   */
  export type CategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }


  /**
   * Category delete
   */
  export type CategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }


  /**
   * Category findRaw
   */
  export type CategoryFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Category aggregateRaw
   */
  export type CategoryAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Category.subCategory
   */
  export type Category$subCategoryArgs = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryInclude | null
    where?: SubCategoryWhereInput
    orderBy?: Enumerable<SubCategoryOrderByWithRelationInput>
    cursor?: SubCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SubCategoryScalarFieldEnum>
  }


  /**
   * Category without action
   */
  export type CategoryArgs = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude | null
  }



  /**
   * Model SubCategory
   */


  export type AggregateSubCategory = {
    _count: SubCategoryCountAggregateOutputType | null
    _min: SubCategoryMinAggregateOutputType | null
    _max: SubCategoryMaxAggregateOutputType | null
  }

  export type SubCategoryMinAggregateOutputType = {
    id: string | null
    reference: string | null
    name: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubCategoryMaxAggregateOutputType = {
    id: string | null
    reference: string | null
    name: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubCategoryCountAggregateOutputType = {
    id: number
    reference: number
    name: number
    categoryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubCategoryMinAggregateInputType = {
    id?: true
    reference?: true
    name?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubCategoryMaxAggregateInputType = {
    id?: true
    reference?: true
    name?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubCategoryCountAggregateInputType = {
    id?: true
    reference?: true
    name?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubCategoryAggregateArgs = {
    /**
     * Filter which SubCategory to aggregate.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: Enumerable<SubCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubCategories
    **/
    _count?: true | SubCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubCategoryMaxAggregateInputType
  }

  export type GetSubCategoryAggregateType<T extends SubCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSubCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubCategory[P]>
      : GetScalarType<T[P], AggregateSubCategory[P]>
  }




  export type SubCategoryGroupByArgs = {
    where?: SubCategoryWhereInput
    orderBy?: Enumerable<SubCategoryOrderByWithAggregationInput>
    by: SubCategoryScalarFieldEnum[]
    having?: SubCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubCategoryCountAggregateInputType | true
    _min?: SubCategoryMinAggregateInputType
    _max?: SubCategoryMaxAggregateInputType
  }


  export type SubCategoryGroupByOutputType = {
    id: string
    reference: string
    name: string
    categoryId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: SubCategoryCountAggregateOutputType | null
    _min: SubCategoryMinAggregateOutputType | null
    _max: SubCategoryMaxAggregateOutputType | null
  }

  type GetSubCategoryGroupByPayload<T extends SubCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SubCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], SubCategoryGroupByOutputType[P]>
        }
      >
    >


  export type SubCategorySelect = {
    id?: boolean
    reference?: boolean
    name?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CategoryArgs
    article?: boolean | SubCategory$articleArgs
    _count?: boolean | SubCategoryCountOutputTypeArgs
  }


  export type SubCategoryInclude = {
    category?: boolean | CategoryArgs
    article?: boolean | SubCategory$articleArgs
    _count?: boolean | SubCategoryCountOutputTypeArgs
  }

  export type SubCategoryGetPayload<S extends boolean | null | undefined | SubCategoryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SubCategory :
    S extends undefined ? never :
    S extends { include: any } & (SubCategoryArgs | SubCategoryFindManyArgs)
    ? SubCategory  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'category' ? CategoryGetPayload<S['include'][P]> :
        P extends 'article' ? Array < ArticleGetPayload<S['include'][P]>>  :
        P extends '_count' ? SubCategoryCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SubCategoryArgs | SubCategoryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'category' ? CategoryGetPayload<S['select'][P]> :
        P extends 'article' ? Array < ArticleGetPayload<S['select'][P]>>  :
        P extends '_count' ? SubCategoryCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof SubCategory ? SubCategory[P] : never
  } 
      : SubCategory


  type SubCategoryCountArgs = 
    Omit<SubCategoryFindManyArgs, 'select' | 'include'> & {
      select?: SubCategoryCountAggregateInputType | true
    }

  export interface SubCategoryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SubCategory that matches the filter.
     * @param {SubCategoryFindUniqueArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubCategoryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubCategoryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SubCategory'> extends True ? Prisma__SubCategoryClient<SubCategoryGetPayload<T>> : Prisma__SubCategoryClient<SubCategoryGetPayload<T> | null, null>

    /**
     * Find one SubCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SubCategoryFindUniqueOrThrowArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubCategoryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SubCategoryFindUniqueOrThrowArgs>
    ): Prisma__SubCategoryClient<SubCategoryGetPayload<T>>

    /**
     * Find the first SubCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryFindFirstArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubCategoryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubCategoryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SubCategory'> extends True ? Prisma__SubCategoryClient<SubCategoryGetPayload<T>> : Prisma__SubCategoryClient<SubCategoryGetPayload<T> | null, null>

    /**
     * Find the first SubCategory that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryFindFirstOrThrowArgs} args - Arguments to find a SubCategory
     * @example
     * // Get one SubCategory
     * const subCategory = await prisma.subCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubCategoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubCategoryFindFirstOrThrowArgs>
    ): Prisma__SubCategoryClient<SubCategoryGetPayload<T>>

    /**
     * Find zero or more SubCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubCategories
     * const subCategories = await prisma.subCategory.findMany()
     * 
     * // Get first 10 SubCategories
     * const subCategories = await prisma.subCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subCategoryWithIdOnly = await prisma.subCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubCategoryFindManyArgs>(
      args?: SelectSubset<T, SubCategoryFindManyArgs>
    ): Prisma.PrismaPromise<Array<SubCategoryGetPayload<T>>>

    /**
     * Create a SubCategory.
     * @param {SubCategoryCreateArgs} args - Arguments to create a SubCategory.
     * @example
     * // Create one SubCategory
     * const SubCategory = await prisma.subCategory.create({
     *   data: {
     *     // ... data to create a SubCategory
     *   }
     * })
     * 
    **/
    create<T extends SubCategoryCreateArgs>(
      args: SelectSubset<T, SubCategoryCreateArgs>
    ): Prisma__SubCategoryClient<SubCategoryGetPayload<T>>

    /**
     * Create many SubCategories.
     *     @param {SubCategoryCreateManyArgs} args - Arguments to create many SubCategories.
     *     @example
     *     // Create many SubCategories
     *     const subCategory = await prisma.subCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubCategoryCreateManyArgs>(
      args?: SelectSubset<T, SubCategoryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SubCategory.
     * @param {SubCategoryDeleteArgs} args - Arguments to delete one SubCategory.
     * @example
     * // Delete one SubCategory
     * const SubCategory = await prisma.subCategory.delete({
     *   where: {
     *     // ... filter to delete one SubCategory
     *   }
     * })
     * 
    **/
    delete<T extends SubCategoryDeleteArgs>(
      args: SelectSubset<T, SubCategoryDeleteArgs>
    ): Prisma__SubCategoryClient<SubCategoryGetPayload<T>>

    /**
     * Update one SubCategory.
     * @param {SubCategoryUpdateArgs} args - Arguments to update one SubCategory.
     * @example
     * // Update one SubCategory
     * const subCategory = await prisma.subCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubCategoryUpdateArgs>(
      args: SelectSubset<T, SubCategoryUpdateArgs>
    ): Prisma__SubCategoryClient<SubCategoryGetPayload<T>>

    /**
     * Delete zero or more SubCategories.
     * @param {SubCategoryDeleteManyArgs} args - Arguments to filter SubCategories to delete.
     * @example
     * // Delete a few SubCategories
     * const { count } = await prisma.subCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubCategoryDeleteManyArgs>(
      args?: SelectSubset<T, SubCategoryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubCategories
     * const subCategory = await prisma.subCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubCategoryUpdateManyArgs>(
      args: SelectSubset<T, SubCategoryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubCategory.
     * @param {SubCategoryUpsertArgs} args - Arguments to update or create a SubCategory.
     * @example
     * // Update or create a SubCategory
     * const subCategory = await prisma.subCategory.upsert({
     *   create: {
     *     // ... data to create a SubCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubCategory we want to update
     *   }
     * })
    **/
    upsert<T extends SubCategoryUpsertArgs>(
      args: SelectSubset<T, SubCategoryUpsertArgs>
    ): Prisma__SubCategoryClient<SubCategoryGetPayload<T>>

    /**
     * Find zero or more SubCategories that matches the filter.
     * @param {SubCategoryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const subCategory = await prisma.subCategory.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: SubCategoryFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SubCategory.
     * @param {SubCategoryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const subCategory = await prisma.subCategory.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: SubCategoryAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of SubCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryCountArgs} args - Arguments to filter SubCategories to count.
     * @example
     * // Count the number of SubCategories
     * const count = await prisma.subCategory.count({
     *   where: {
     *     // ... the filter for the SubCategories we want to count
     *   }
     * })
    **/
    count<T extends SubCategoryCountArgs>(
      args?: Subset<T, SubCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubCategoryAggregateArgs>(args: Subset<T, SubCategoryAggregateArgs>): Prisma.PrismaPromise<GetSubCategoryAggregateType<T>>

    /**
     * Group by SubCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubCategoryGroupByArgs['orderBy'] }
        : { orderBy?: SubCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SubCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubCategoryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category<T extends CategoryArgs= {}>(args?: Subset<T, CategoryArgs>): Prisma__CategoryClient<CategoryGetPayload<T> | Null>;

    article<T extends SubCategory$articleArgs= {}>(args?: Subset<T, SubCategory$articleArgs>): Prisma.PrismaPromise<Array<ArticleGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SubCategory base type for findUnique actions
   */
  export type SubCategoryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryInclude | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where: SubCategoryWhereUniqueInput
  }

  /**
   * SubCategory findUnique
   */
  export interface SubCategoryFindUniqueArgs extends SubCategoryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubCategory findUniqueOrThrow
   */
  export type SubCategoryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryInclude | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where: SubCategoryWhereUniqueInput
  }


  /**
   * SubCategory base type for findFirst actions
   */
  export type SubCategoryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryInclude | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: Enumerable<SubCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubCategories.
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubCategories.
     */
    distinct?: Enumerable<SubCategoryScalarFieldEnum>
  }

  /**
   * SubCategory findFirst
   */
  export interface SubCategoryFindFirstArgs extends SubCategoryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubCategory findFirstOrThrow
   */
  export type SubCategoryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryInclude | null
    /**
     * Filter, which SubCategory to fetch.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: Enumerable<SubCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubCategories.
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubCategories.
     */
    distinct?: Enumerable<SubCategoryScalarFieldEnum>
  }


  /**
   * SubCategory findMany
   */
  export type SubCategoryFindManyArgs = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryInclude | null
    /**
     * Filter, which SubCategories to fetch.
     */
    where?: SubCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubCategories to fetch.
     */
    orderBy?: Enumerable<SubCategoryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubCategories.
     */
    cursor?: SubCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubCategories.
     */
    skip?: number
    distinct?: Enumerable<SubCategoryScalarFieldEnum>
  }


  /**
   * SubCategory create
   */
  export type SubCategoryCreateArgs = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryInclude | null
    /**
     * The data needed to create a SubCategory.
     */
    data: XOR<SubCategoryCreateInput, SubCategoryUncheckedCreateInput>
  }


  /**
   * SubCategory createMany
   */
  export type SubCategoryCreateManyArgs = {
    /**
     * The data used to create many SubCategories.
     */
    data: Enumerable<SubCategoryCreateManyInput>
  }


  /**
   * SubCategory update
   */
  export type SubCategoryUpdateArgs = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryInclude | null
    /**
     * The data needed to update a SubCategory.
     */
    data: XOR<SubCategoryUpdateInput, SubCategoryUncheckedUpdateInput>
    /**
     * Choose, which SubCategory to update.
     */
    where: SubCategoryWhereUniqueInput
  }


  /**
   * SubCategory updateMany
   */
  export type SubCategoryUpdateManyArgs = {
    /**
     * The data used to update SubCategories.
     */
    data: XOR<SubCategoryUpdateManyMutationInput, SubCategoryUncheckedUpdateManyInput>
    /**
     * Filter which SubCategories to update
     */
    where?: SubCategoryWhereInput
  }


  /**
   * SubCategory upsert
   */
  export type SubCategoryUpsertArgs = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryInclude | null
    /**
     * The filter to search for the SubCategory to update in case it exists.
     */
    where: SubCategoryWhereUniqueInput
    /**
     * In case the SubCategory found by the `where` argument doesn't exist, create a new SubCategory with this data.
     */
    create: XOR<SubCategoryCreateInput, SubCategoryUncheckedCreateInput>
    /**
     * In case the SubCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubCategoryUpdateInput, SubCategoryUncheckedUpdateInput>
  }


  /**
   * SubCategory delete
   */
  export type SubCategoryDeleteArgs = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryInclude | null
    /**
     * Filter which SubCategory to delete.
     */
    where: SubCategoryWhereUniqueInput
  }


  /**
   * SubCategory deleteMany
   */
  export type SubCategoryDeleteManyArgs = {
    /**
     * Filter which SubCategories to delete
     */
    where?: SubCategoryWhereInput
  }


  /**
   * SubCategory findRaw
   */
  export type SubCategoryFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * SubCategory aggregateRaw
   */
  export type SubCategoryAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * SubCategory.article
   */
  export type SubCategory$articleArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    where?: ArticleWhereInput
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ArticleScalarFieldEnum>
  }


  /**
   * SubCategory without action
   */
  export type SubCategoryArgs = {
    /**
     * Select specific fields to fetch from the SubCategory
     */
    select?: SubCategorySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubCategoryInclude | null
  }



  /**
   * Model UnitySize
   */


  export type AggregateUnitySize = {
    _count: UnitySizeCountAggregateOutputType | null
    _min: UnitySizeMinAggregateOutputType | null
    _max: UnitySizeMaxAggregateOutputType | null
  }

  export type UnitySizeMinAggregateOutputType = {
    id: string | null
    name: string | null
    abbreviation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitySizeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    abbreviation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitySizeCountAggregateOutputType = {
    id: number
    name: number
    abbreviation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitySizeMinAggregateInputType = {
    id?: true
    name?: true
    abbreviation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitySizeMaxAggregateInputType = {
    id?: true
    name?: true
    abbreviation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitySizeCountAggregateInputType = {
    id?: true
    name?: true
    abbreviation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitySizeAggregateArgs = {
    /**
     * Filter which UnitySize to aggregate.
     */
    where?: UnitySizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitySizes to fetch.
     */
    orderBy?: Enumerable<UnitySizeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitySizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitySizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitySizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UnitySizes
    **/
    _count?: true | UnitySizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitySizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitySizeMaxAggregateInputType
  }

  export type GetUnitySizeAggregateType<T extends UnitySizeAggregateArgs> = {
        [P in keyof T & keyof AggregateUnitySize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnitySize[P]>
      : GetScalarType<T[P], AggregateUnitySize[P]>
  }




  export type UnitySizeGroupByArgs = {
    where?: UnitySizeWhereInput
    orderBy?: Enumerable<UnitySizeOrderByWithAggregationInput>
    by: UnitySizeScalarFieldEnum[]
    having?: UnitySizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitySizeCountAggregateInputType | true
    _min?: UnitySizeMinAggregateInputType
    _max?: UnitySizeMaxAggregateInputType
  }


  export type UnitySizeGroupByOutputType = {
    id: string
    name: string
    abbreviation: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: UnitySizeCountAggregateOutputType | null
    _min: UnitySizeMinAggregateOutputType | null
    _max: UnitySizeMaxAggregateOutputType | null
  }

  type GetUnitySizeGroupByPayload<T extends UnitySizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UnitySizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitySizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitySizeGroupByOutputType[P]>
            : GetScalarType<T[P], UnitySizeGroupByOutputType[P]>
        }
      >
    >


  export type UnitySizeSelect = {
    id?: boolean
    name?: boolean
    abbreviation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    article?: boolean | UnitySize$articleArgs
    _count?: boolean | UnitySizeCountOutputTypeArgs
  }


  export type UnitySizeInclude = {
    article?: boolean | UnitySize$articleArgs
    _count?: boolean | UnitySizeCountOutputTypeArgs
  }

  export type UnitySizeGetPayload<S extends boolean | null | undefined | UnitySizeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UnitySize :
    S extends undefined ? never :
    S extends { include: any } & (UnitySizeArgs | UnitySizeFindManyArgs)
    ? UnitySize  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'article' ? Array < ArticleGetPayload<S['include'][P]>>  :
        P extends '_count' ? UnitySizeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UnitySizeArgs | UnitySizeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'article' ? Array < ArticleGetPayload<S['select'][P]>>  :
        P extends '_count' ? UnitySizeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof UnitySize ? UnitySize[P] : never
  } 
      : UnitySize


  type UnitySizeCountArgs = 
    Omit<UnitySizeFindManyArgs, 'select' | 'include'> & {
      select?: UnitySizeCountAggregateInputType | true
    }

  export interface UnitySizeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UnitySize that matches the filter.
     * @param {UnitySizeFindUniqueArgs} args - Arguments to find a UnitySize
     * @example
     * // Get one UnitySize
     * const unitySize = await prisma.unitySize.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UnitySizeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UnitySizeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UnitySize'> extends True ? Prisma__UnitySizeClient<UnitySizeGetPayload<T>> : Prisma__UnitySizeClient<UnitySizeGetPayload<T> | null, null>

    /**
     * Find one UnitySize that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UnitySizeFindUniqueOrThrowArgs} args - Arguments to find a UnitySize
     * @example
     * // Get one UnitySize
     * const unitySize = await prisma.unitySize.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UnitySizeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UnitySizeFindUniqueOrThrowArgs>
    ): Prisma__UnitySizeClient<UnitySizeGetPayload<T>>

    /**
     * Find the first UnitySize that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitySizeFindFirstArgs} args - Arguments to find a UnitySize
     * @example
     * // Get one UnitySize
     * const unitySize = await prisma.unitySize.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UnitySizeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UnitySizeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UnitySize'> extends True ? Prisma__UnitySizeClient<UnitySizeGetPayload<T>> : Prisma__UnitySizeClient<UnitySizeGetPayload<T> | null, null>

    /**
     * Find the first UnitySize that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitySizeFindFirstOrThrowArgs} args - Arguments to find a UnitySize
     * @example
     * // Get one UnitySize
     * const unitySize = await prisma.unitySize.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UnitySizeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UnitySizeFindFirstOrThrowArgs>
    ): Prisma__UnitySizeClient<UnitySizeGetPayload<T>>

    /**
     * Find zero or more UnitySizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitySizeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UnitySizes
     * const unitySizes = await prisma.unitySize.findMany()
     * 
     * // Get first 10 UnitySizes
     * const unitySizes = await prisma.unitySize.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitySizeWithIdOnly = await prisma.unitySize.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UnitySizeFindManyArgs>(
      args?: SelectSubset<T, UnitySizeFindManyArgs>
    ): Prisma.PrismaPromise<Array<UnitySizeGetPayload<T>>>

    /**
     * Create a UnitySize.
     * @param {UnitySizeCreateArgs} args - Arguments to create a UnitySize.
     * @example
     * // Create one UnitySize
     * const UnitySize = await prisma.unitySize.create({
     *   data: {
     *     // ... data to create a UnitySize
     *   }
     * })
     * 
    **/
    create<T extends UnitySizeCreateArgs>(
      args: SelectSubset<T, UnitySizeCreateArgs>
    ): Prisma__UnitySizeClient<UnitySizeGetPayload<T>>

    /**
     * Create many UnitySizes.
     *     @param {UnitySizeCreateManyArgs} args - Arguments to create many UnitySizes.
     *     @example
     *     // Create many UnitySizes
     *     const unitySize = await prisma.unitySize.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UnitySizeCreateManyArgs>(
      args?: SelectSubset<T, UnitySizeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UnitySize.
     * @param {UnitySizeDeleteArgs} args - Arguments to delete one UnitySize.
     * @example
     * // Delete one UnitySize
     * const UnitySize = await prisma.unitySize.delete({
     *   where: {
     *     // ... filter to delete one UnitySize
     *   }
     * })
     * 
    **/
    delete<T extends UnitySizeDeleteArgs>(
      args: SelectSubset<T, UnitySizeDeleteArgs>
    ): Prisma__UnitySizeClient<UnitySizeGetPayload<T>>

    /**
     * Update one UnitySize.
     * @param {UnitySizeUpdateArgs} args - Arguments to update one UnitySize.
     * @example
     * // Update one UnitySize
     * const unitySize = await prisma.unitySize.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UnitySizeUpdateArgs>(
      args: SelectSubset<T, UnitySizeUpdateArgs>
    ): Prisma__UnitySizeClient<UnitySizeGetPayload<T>>

    /**
     * Delete zero or more UnitySizes.
     * @param {UnitySizeDeleteManyArgs} args - Arguments to filter UnitySizes to delete.
     * @example
     * // Delete a few UnitySizes
     * const { count } = await prisma.unitySize.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UnitySizeDeleteManyArgs>(
      args?: SelectSubset<T, UnitySizeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UnitySizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitySizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UnitySizes
     * const unitySize = await prisma.unitySize.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UnitySizeUpdateManyArgs>(
      args: SelectSubset<T, UnitySizeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UnitySize.
     * @param {UnitySizeUpsertArgs} args - Arguments to update or create a UnitySize.
     * @example
     * // Update or create a UnitySize
     * const unitySize = await prisma.unitySize.upsert({
     *   create: {
     *     // ... data to create a UnitySize
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UnitySize we want to update
     *   }
     * })
    **/
    upsert<T extends UnitySizeUpsertArgs>(
      args: SelectSubset<T, UnitySizeUpsertArgs>
    ): Prisma__UnitySizeClient<UnitySizeGetPayload<T>>

    /**
     * Find zero or more UnitySizes that matches the filter.
     * @param {UnitySizeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const unitySize = await prisma.unitySize.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: UnitySizeFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UnitySize.
     * @param {UnitySizeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const unitySize = await prisma.unitySize.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: UnitySizeAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of UnitySizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitySizeCountArgs} args - Arguments to filter UnitySizes to count.
     * @example
     * // Count the number of UnitySizes
     * const count = await prisma.unitySize.count({
     *   where: {
     *     // ... the filter for the UnitySizes we want to count
     *   }
     * })
    **/
    count<T extends UnitySizeCountArgs>(
      args?: Subset<T, UnitySizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitySizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UnitySize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitySizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitySizeAggregateArgs>(args: Subset<T, UnitySizeAggregateArgs>): Prisma.PrismaPromise<GetUnitySizeAggregateType<T>>

    /**
     * Group by UnitySize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitySizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitySizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitySizeGroupByArgs['orderBy'] }
        : { orderBy?: UnitySizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitySizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitySizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UnitySize.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UnitySizeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    article<T extends UnitySize$articleArgs= {}>(args?: Subset<T, UnitySize$articleArgs>): Prisma.PrismaPromise<Array<ArticleGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UnitySize base type for findUnique actions
   */
  export type UnitySizeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UnitySize
     */
    select?: UnitySizeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitySizeInclude | null
    /**
     * Filter, which UnitySize to fetch.
     */
    where: UnitySizeWhereUniqueInput
  }

  /**
   * UnitySize findUnique
   */
  export interface UnitySizeFindUniqueArgs extends UnitySizeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UnitySize findUniqueOrThrow
   */
  export type UnitySizeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UnitySize
     */
    select?: UnitySizeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitySizeInclude | null
    /**
     * Filter, which UnitySize to fetch.
     */
    where: UnitySizeWhereUniqueInput
  }


  /**
   * UnitySize base type for findFirst actions
   */
  export type UnitySizeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UnitySize
     */
    select?: UnitySizeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitySizeInclude | null
    /**
     * Filter, which UnitySize to fetch.
     */
    where?: UnitySizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitySizes to fetch.
     */
    orderBy?: Enumerable<UnitySizeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitySizes.
     */
    cursor?: UnitySizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitySizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitySizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitySizes.
     */
    distinct?: Enumerable<UnitySizeScalarFieldEnum>
  }

  /**
   * UnitySize findFirst
   */
  export interface UnitySizeFindFirstArgs extends UnitySizeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UnitySize findFirstOrThrow
   */
  export type UnitySizeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UnitySize
     */
    select?: UnitySizeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitySizeInclude | null
    /**
     * Filter, which UnitySize to fetch.
     */
    where?: UnitySizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitySizes to fetch.
     */
    orderBy?: Enumerable<UnitySizeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UnitySizes.
     */
    cursor?: UnitySizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitySizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitySizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UnitySizes.
     */
    distinct?: Enumerable<UnitySizeScalarFieldEnum>
  }


  /**
   * UnitySize findMany
   */
  export type UnitySizeFindManyArgs = {
    /**
     * Select specific fields to fetch from the UnitySize
     */
    select?: UnitySizeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitySizeInclude | null
    /**
     * Filter, which UnitySizes to fetch.
     */
    where?: UnitySizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UnitySizes to fetch.
     */
    orderBy?: Enumerable<UnitySizeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UnitySizes.
     */
    cursor?: UnitySizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UnitySizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UnitySizes.
     */
    skip?: number
    distinct?: Enumerable<UnitySizeScalarFieldEnum>
  }


  /**
   * UnitySize create
   */
  export type UnitySizeCreateArgs = {
    /**
     * Select specific fields to fetch from the UnitySize
     */
    select?: UnitySizeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitySizeInclude | null
    /**
     * The data needed to create a UnitySize.
     */
    data: XOR<UnitySizeCreateInput, UnitySizeUncheckedCreateInput>
  }


  /**
   * UnitySize createMany
   */
  export type UnitySizeCreateManyArgs = {
    /**
     * The data used to create many UnitySizes.
     */
    data: Enumerable<UnitySizeCreateManyInput>
  }


  /**
   * UnitySize update
   */
  export type UnitySizeUpdateArgs = {
    /**
     * Select specific fields to fetch from the UnitySize
     */
    select?: UnitySizeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitySizeInclude | null
    /**
     * The data needed to update a UnitySize.
     */
    data: XOR<UnitySizeUpdateInput, UnitySizeUncheckedUpdateInput>
    /**
     * Choose, which UnitySize to update.
     */
    where: UnitySizeWhereUniqueInput
  }


  /**
   * UnitySize updateMany
   */
  export type UnitySizeUpdateManyArgs = {
    /**
     * The data used to update UnitySizes.
     */
    data: XOR<UnitySizeUpdateManyMutationInput, UnitySizeUncheckedUpdateManyInput>
    /**
     * Filter which UnitySizes to update
     */
    where?: UnitySizeWhereInput
  }


  /**
   * UnitySize upsert
   */
  export type UnitySizeUpsertArgs = {
    /**
     * Select specific fields to fetch from the UnitySize
     */
    select?: UnitySizeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitySizeInclude | null
    /**
     * The filter to search for the UnitySize to update in case it exists.
     */
    where: UnitySizeWhereUniqueInput
    /**
     * In case the UnitySize found by the `where` argument doesn't exist, create a new UnitySize with this data.
     */
    create: XOR<UnitySizeCreateInput, UnitySizeUncheckedCreateInput>
    /**
     * In case the UnitySize was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitySizeUpdateInput, UnitySizeUncheckedUpdateInput>
  }


  /**
   * UnitySize delete
   */
  export type UnitySizeDeleteArgs = {
    /**
     * Select specific fields to fetch from the UnitySize
     */
    select?: UnitySizeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitySizeInclude | null
    /**
     * Filter which UnitySize to delete.
     */
    where: UnitySizeWhereUniqueInput
  }


  /**
   * UnitySize deleteMany
   */
  export type UnitySizeDeleteManyArgs = {
    /**
     * Filter which UnitySizes to delete
     */
    where?: UnitySizeWhereInput
  }


  /**
   * UnitySize findRaw
   */
  export type UnitySizeFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * UnitySize aggregateRaw
   */
  export type UnitySizeAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * UnitySize.article
   */
  export type UnitySize$articleArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    where?: ArticleWhereInput
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ArticleScalarFieldEnum>
  }


  /**
   * UnitySize without action
   */
  export type UnitySizeArgs = {
    /**
     * Select specific fields to fetch from the UnitySize
     */
    select?: UnitySizeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitySizeInclude | null
  }



  /**
   * Model Article
   */


  export type AggregateArticle = {
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  export type ArticleAvgAggregateOutputType = {
    winningChance: number | null
  }

  export type ArticleSumAggregateOutputType = {
    winningChance: number | null
  }

  export type ArticleMinAggregateOutputType = {
    id: string | null
    reference: string | null
    designation: string | null
    type: EnumTypeMode | null
    size: string | null
    color: string | null
    productUrl: string | null
    observation: string | null
    winningChance: number | null
    providerId: string | null
    unitySizeId: string | null
    subCategoryId: string | null
    boxId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArticleMaxAggregateOutputType = {
    id: string | null
    reference: string | null
    designation: string | null
    type: EnumTypeMode | null
    size: string | null
    color: string | null
    productUrl: string | null
    observation: string | null
    winningChance: number | null
    providerId: string | null
    unitySizeId: string | null
    subCategoryId: string | null
    boxId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArticleCountAggregateOutputType = {
    id: number
    reference: number
    designation: number
    type: number
    size: number
    color: number
    productUrl: number
    observation: number
    winningChance: number
    providerId: number
    unitySizeId: number
    subCategoryId: number
    boxId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ArticleAvgAggregateInputType = {
    winningChance?: true
  }

  export type ArticleSumAggregateInputType = {
    winningChance?: true
  }

  export type ArticleMinAggregateInputType = {
    id?: true
    reference?: true
    designation?: true
    type?: true
    size?: true
    color?: true
    productUrl?: true
    observation?: true
    winningChance?: true
    providerId?: true
    unitySizeId?: true
    subCategoryId?: true
    boxId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArticleMaxAggregateInputType = {
    id?: true
    reference?: true
    designation?: true
    type?: true
    size?: true
    color?: true
    productUrl?: true
    observation?: true
    winningChance?: true
    providerId?: true
    unitySizeId?: true
    subCategoryId?: true
    boxId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArticleCountAggregateInputType = {
    id?: true
    reference?: true
    designation?: true
    type?: true
    size?: true
    color?: true
    productUrl?: true
    observation?: true
    winningChance?: true
    providerId?: true
    unitySizeId?: true
    subCategoryId?: true
    boxId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ArticleAggregateArgs = {
    /**
     * Filter which Article to aggregate.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Articles
    **/
    _count?: true | ArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleMaxAggregateInputType
  }

  export type GetArticleAggregateType<T extends ArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticle[P]>
      : GetScalarType<T[P], AggregateArticle[P]>
  }




  export type ArticleGroupByArgs = {
    where?: ArticleWhereInput
    orderBy?: Enumerable<ArticleOrderByWithAggregationInput>
    by: ArticleScalarFieldEnum[]
    having?: ArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleCountAggregateInputType | true
    _avg?: ArticleAvgAggregateInputType
    _sum?: ArticleSumAggregateInputType
    _min?: ArticleMinAggregateInputType
    _max?: ArticleMaxAggregateInputType
  }


  export type ArticleGroupByOutputType = {
    id: string
    reference: string
    designation: string
    type: EnumTypeMode | null
    size: string | null
    color: string | null
    productUrl: string | null
    observation: string | null
    winningChance: number | null
    providerId: string | null
    unitySizeId: string | null
    subCategoryId: string
    boxId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  type GetArticleGroupByPayload<T extends ArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleGroupByOutputType[P]>
        }
      >
    >


  export type ArticleSelect = {
    id?: boolean
    reference?: boolean
    designation?: boolean
    type?: boolean
    size?: boolean
    color?: boolean
    productUrl?: boolean
    observation?: boolean
    winningChance?: boolean
    providerId?: boolean
    unitySizeId?: boolean
    subCategoryId?: boolean
    boxId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | ProviderArgs
    unitySize?: boolean | UnitySizeArgs
    subCategory?: boolean | SubCategoryArgs
    box?: boolean | BoxArgs
    articlePhoto?: boolean | Article$articlePhotoArgs
    post?: boolean | Article$postArgs
    price?: boolean | PriceArgs
    boxArticle?: boolean | Article$boxArticleArgs
    game?: boolean | Article$gameArgs
    _count?: boolean | ArticleCountOutputTypeArgs
  }


  export type ArticleInclude = {
    provider?: boolean | ProviderArgs
    unitySize?: boolean | UnitySizeArgs
    subCategory?: boolean | SubCategoryArgs
    box?: boolean | BoxArgs
    articlePhoto?: boolean | Article$articlePhotoArgs
    post?: boolean | Article$postArgs
    price?: boolean | PriceArgs
    boxArticle?: boolean | Article$boxArticleArgs
    game?: boolean | Article$gameArgs
    _count?: boolean | ArticleCountOutputTypeArgs
  }

  export type ArticleGetPayload<S extends boolean | null | undefined | ArticleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Article :
    S extends undefined ? never :
    S extends { include: any } & (ArticleArgs | ArticleFindManyArgs)
    ? Article  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'provider' ? ProviderGetPayload<S['include'][P]> | null :
        P extends 'unitySize' ? UnitySizeGetPayload<S['include'][P]> | null :
        P extends 'subCategory' ? SubCategoryGetPayload<S['include'][P]> | null :
        P extends 'box' ? BoxGetPayload<S['include'][P]> | null :
        P extends 'articlePhoto' ? Array < ArticlePhotoGetPayload<S['include'][P]>>  :
        P extends 'post' ? Array < PostGetPayload<S['include'][P]>>  :
        P extends 'price' ? PriceGetPayload<S['include'][P]> | null :
        P extends 'boxArticle' ? Array < BoxArticleGetPayload<S['include'][P]>>  :
        P extends 'game' ? Array < GameGetPayload<S['include'][P]>>  :
        P extends '_count' ? ArticleCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ArticleArgs | ArticleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'provider' ? ProviderGetPayload<S['select'][P]> | null :
        P extends 'unitySize' ? UnitySizeGetPayload<S['select'][P]> | null :
        P extends 'subCategory' ? SubCategoryGetPayload<S['select'][P]> | null :
        P extends 'box' ? BoxGetPayload<S['select'][P]> | null :
        P extends 'articlePhoto' ? Array < ArticlePhotoGetPayload<S['select'][P]>>  :
        P extends 'post' ? Array < PostGetPayload<S['select'][P]>>  :
        P extends 'price' ? PriceGetPayload<S['select'][P]> | null :
        P extends 'boxArticle' ? Array < BoxArticleGetPayload<S['select'][P]>>  :
        P extends 'game' ? Array < GameGetPayload<S['select'][P]>>  :
        P extends '_count' ? ArticleCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Article ? Article[P] : never
  } 
      : Article


  type ArticleCountArgs = 
    Omit<ArticleFindManyArgs, 'select' | 'include'> & {
      select?: ArticleCountAggregateInputType | true
    }

  export interface ArticleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Article that matches the filter.
     * @param {ArticleFindUniqueArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ArticleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ArticleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Article'> extends True ? Prisma__ArticleClient<ArticleGetPayload<T>> : Prisma__ArticleClient<ArticleGetPayload<T> | null, null>

    /**
     * Find one Article that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ArticleFindUniqueOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ArticleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ArticleFindUniqueOrThrowArgs>
    ): Prisma__ArticleClient<ArticleGetPayload<T>>

    /**
     * Find the first Article that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ArticleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ArticleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Article'> extends True ? Prisma__ArticleClient<ArticleGetPayload<T>> : Prisma__ArticleClient<ArticleGetPayload<T> | null, null>

    /**
     * Find the first Article that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ArticleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ArticleFindFirstOrThrowArgs>
    ): Prisma__ArticleClient<ArticleGetPayload<T>>

    /**
     * Find zero or more Articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Articles
     * const articles = await prisma.article.findMany()
     * 
     * // Get first 10 Articles
     * const articles = await prisma.article.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articleWithIdOnly = await prisma.article.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ArticleFindManyArgs>(
      args?: SelectSubset<T, ArticleFindManyArgs>
    ): Prisma.PrismaPromise<Array<ArticleGetPayload<T>>>

    /**
     * Create a Article.
     * @param {ArticleCreateArgs} args - Arguments to create a Article.
     * @example
     * // Create one Article
     * const Article = await prisma.article.create({
     *   data: {
     *     // ... data to create a Article
     *   }
     * })
     * 
    **/
    create<T extends ArticleCreateArgs>(
      args: SelectSubset<T, ArticleCreateArgs>
    ): Prisma__ArticleClient<ArticleGetPayload<T>>

    /**
     * Create many Articles.
     *     @param {ArticleCreateManyArgs} args - Arguments to create many Articles.
     *     @example
     *     // Create many Articles
     *     const article = await prisma.article.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ArticleCreateManyArgs>(
      args?: SelectSubset<T, ArticleCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Article.
     * @param {ArticleDeleteArgs} args - Arguments to delete one Article.
     * @example
     * // Delete one Article
     * const Article = await prisma.article.delete({
     *   where: {
     *     // ... filter to delete one Article
     *   }
     * })
     * 
    **/
    delete<T extends ArticleDeleteArgs>(
      args: SelectSubset<T, ArticleDeleteArgs>
    ): Prisma__ArticleClient<ArticleGetPayload<T>>

    /**
     * Update one Article.
     * @param {ArticleUpdateArgs} args - Arguments to update one Article.
     * @example
     * // Update one Article
     * const article = await prisma.article.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ArticleUpdateArgs>(
      args: SelectSubset<T, ArticleUpdateArgs>
    ): Prisma__ArticleClient<ArticleGetPayload<T>>

    /**
     * Delete zero or more Articles.
     * @param {ArticleDeleteManyArgs} args - Arguments to filter Articles to delete.
     * @example
     * // Delete a few Articles
     * const { count } = await prisma.article.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ArticleDeleteManyArgs>(
      args?: SelectSubset<T, ArticleDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Articles
     * const article = await prisma.article.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ArticleUpdateManyArgs>(
      args: SelectSubset<T, ArticleUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Article.
     * @param {ArticleUpsertArgs} args - Arguments to update or create a Article.
     * @example
     * // Update or create a Article
     * const article = await prisma.article.upsert({
     *   create: {
     *     // ... data to create a Article
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Article we want to update
     *   }
     * })
    **/
    upsert<T extends ArticleUpsertArgs>(
      args: SelectSubset<T, ArticleUpsertArgs>
    ): Prisma__ArticleClient<ArticleGetPayload<T>>

    /**
     * Find zero or more Articles that matches the filter.
     * @param {ArticleFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const article = await prisma.article.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ArticleFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Article.
     * @param {ArticleAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const article = await prisma.article.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ArticleAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCountArgs} args - Arguments to filter Articles to count.
     * @example
     * // Count the number of Articles
     * const count = await prisma.article.count({
     *   where: {
     *     // ... the filter for the Articles we want to count
     *   }
     * })
    **/
    count<T extends ArticleCountArgs>(
      args?: Subset<T, ArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleAggregateArgs>(args: Subset<T, ArticleAggregateArgs>): Prisma.PrismaPromise<GetArticleAggregateType<T>>

    /**
     * Group by Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleGroupByArgs['orderBy'] }
        : { orderBy?: ArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Article.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ArticleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    provider<T extends ProviderArgs= {}>(args?: Subset<T, ProviderArgs>): Prisma__ProviderClient<ProviderGetPayload<T> | Null>;

    unitySize<T extends UnitySizeArgs= {}>(args?: Subset<T, UnitySizeArgs>): Prisma__UnitySizeClient<UnitySizeGetPayload<T> | Null>;

    subCategory<T extends SubCategoryArgs= {}>(args?: Subset<T, SubCategoryArgs>): Prisma__SubCategoryClient<SubCategoryGetPayload<T> | Null>;

    box<T extends BoxArgs= {}>(args?: Subset<T, BoxArgs>): Prisma__BoxClient<BoxGetPayload<T> | Null>;

    articlePhoto<T extends Article$articlePhotoArgs= {}>(args?: Subset<T, Article$articlePhotoArgs>): Prisma.PrismaPromise<Array<ArticlePhotoGetPayload<T>>| Null>;

    post<T extends Article$postArgs= {}>(args?: Subset<T, Article$postArgs>): Prisma.PrismaPromise<Array<PostGetPayload<T>>| Null>;

    price<T extends PriceArgs= {}>(args?: Subset<T, PriceArgs>): Prisma__PriceClient<PriceGetPayload<T> | Null>;

    boxArticle<T extends Article$boxArticleArgs= {}>(args?: Subset<T, Article$boxArticleArgs>): Prisma.PrismaPromise<Array<BoxArticleGetPayload<T>>| Null>;

    game<T extends Article$gameArgs= {}>(args?: Subset<T, Article$gameArgs>): Prisma.PrismaPromise<Array<GameGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Article base type for findUnique actions
   */
  export type ArticleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article findUnique
   */
  export interface ArticleFindUniqueArgs extends ArticleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Article findUniqueOrThrow
   */
  export type ArticleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }


  /**
   * Article base type for findFirst actions
   */
  export type ArticleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: Enumerable<ArticleScalarFieldEnum>
  }

  /**
   * Article findFirst
   */
  export interface ArticleFindFirstArgs extends ArticleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Article findFirstOrThrow
   */
  export type ArticleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: Enumerable<ArticleScalarFieldEnum>
  }


  /**
   * Article findMany
   */
  export type ArticleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    /**
     * Filter, which Articles to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    distinct?: Enumerable<ArticleScalarFieldEnum>
  }


  /**
   * Article create
   */
  export type ArticleCreateArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    /**
     * The data needed to create a Article.
     */
    data: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
  }


  /**
   * Article createMany
   */
  export type ArticleCreateManyArgs = {
    /**
     * The data used to create many Articles.
     */
    data: Enumerable<ArticleCreateManyInput>
  }


  /**
   * Article update
   */
  export type ArticleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    /**
     * The data needed to update a Article.
     */
    data: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
    /**
     * Choose, which Article to update.
     */
    where: ArticleWhereUniqueInput
  }


  /**
   * Article updateMany
   */
  export type ArticleUpdateManyArgs = {
    /**
     * The data used to update Articles.
     */
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyInput>
    /**
     * Filter which Articles to update
     */
    where?: ArticleWhereInput
  }


  /**
   * Article upsert
   */
  export type ArticleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    /**
     * The filter to search for the Article to update in case it exists.
     */
    where: ArticleWhereUniqueInput
    /**
     * In case the Article found by the `where` argument doesn't exist, create a new Article with this data.
     */
    create: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
    /**
     * In case the Article was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
  }


  /**
   * Article delete
   */
  export type ArticleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
    /**
     * Filter which Article to delete.
     */
    where: ArticleWhereUniqueInput
  }


  /**
   * Article deleteMany
   */
  export type ArticleDeleteManyArgs = {
    /**
     * Filter which Articles to delete
     */
    where?: ArticleWhereInput
  }


  /**
   * Article findRaw
   */
  export type ArticleFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Article aggregateRaw
   */
  export type ArticleAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Article.articlePhoto
   */
  export type Article$articlePhotoArgs = {
    /**
     * Select specific fields to fetch from the ArticlePhoto
     */
    select?: ArticlePhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticlePhotoInclude | null
    where?: ArticlePhotoWhereInput
    orderBy?: Enumerable<ArticlePhotoOrderByWithRelationInput>
    cursor?: ArticlePhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ArticlePhotoScalarFieldEnum>
  }


  /**
   * Article.post
   */
  export type Article$postArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    where?: PostWhereInput
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * Article.boxArticle
   */
  export type Article$boxArticleArgs = {
    /**
     * Select specific fields to fetch from the BoxArticle
     */
    select?: BoxArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxArticleInclude | null
    where?: BoxArticleWhereInput
    orderBy?: Enumerable<BoxArticleOrderByWithRelationInput>
    cursor?: BoxArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BoxArticleScalarFieldEnum>
  }


  /**
   * Article.game
   */
  export type Article$gameArgs = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude | null
    where?: GameWhereInput
    orderBy?: Enumerable<GameOrderByWithRelationInput>
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<GameScalarFieldEnum>
  }


  /**
   * Article without action
   */
  export type ArticleArgs = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude | null
  }



  /**
   * Model BoxArticle
   */


  export type AggregateBoxArticle = {
    _count: BoxArticleCountAggregateOutputType | null
    _avg: BoxArticleAvgAggregateOutputType | null
    _sum: BoxArticleSumAggregateOutputType | null
    _min: BoxArticleMinAggregateOutputType | null
    _max: BoxArticleMaxAggregateOutputType | null
  }

  export type BoxArticleAvgAggregateOutputType = {
    winningChance: number | null
  }

  export type BoxArticleSumAggregateOutputType = {
    winningChance: number | null
  }

  export type BoxArticleMinAggregateOutputType = {
    id: string | null
    winningChance: number | null
    boxId: string | null
    articleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BoxArticleMaxAggregateOutputType = {
    id: string | null
    winningChance: number | null
    boxId: string | null
    articleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BoxArticleCountAggregateOutputType = {
    id: number
    winningChance: number
    boxId: number
    articleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BoxArticleAvgAggregateInputType = {
    winningChance?: true
  }

  export type BoxArticleSumAggregateInputType = {
    winningChance?: true
  }

  export type BoxArticleMinAggregateInputType = {
    id?: true
    winningChance?: true
    boxId?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BoxArticleMaxAggregateInputType = {
    id?: true
    winningChance?: true
    boxId?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BoxArticleCountAggregateInputType = {
    id?: true
    winningChance?: true
    boxId?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BoxArticleAggregateArgs = {
    /**
     * Filter which BoxArticle to aggregate.
     */
    where?: BoxArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoxArticles to fetch.
     */
    orderBy?: Enumerable<BoxArticleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoxArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoxArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoxArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoxArticles
    **/
    _count?: true | BoxArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BoxArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BoxArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoxArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoxArticleMaxAggregateInputType
  }

  export type GetBoxArticleAggregateType<T extends BoxArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateBoxArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoxArticle[P]>
      : GetScalarType<T[P], AggregateBoxArticle[P]>
  }




  export type BoxArticleGroupByArgs = {
    where?: BoxArticleWhereInput
    orderBy?: Enumerable<BoxArticleOrderByWithAggregationInput>
    by: BoxArticleScalarFieldEnum[]
    having?: BoxArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoxArticleCountAggregateInputType | true
    _avg?: BoxArticleAvgAggregateInputType
    _sum?: BoxArticleSumAggregateInputType
    _min?: BoxArticleMinAggregateInputType
    _max?: BoxArticleMaxAggregateInputType
  }


  export type BoxArticleGroupByOutputType = {
    id: string
    winningChance: number
    boxId: string
    articleId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: BoxArticleCountAggregateOutputType | null
    _avg: BoxArticleAvgAggregateOutputType | null
    _sum: BoxArticleSumAggregateOutputType | null
    _min: BoxArticleMinAggregateOutputType | null
    _max: BoxArticleMaxAggregateOutputType | null
  }

  type GetBoxArticleGroupByPayload<T extends BoxArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BoxArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoxArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoxArticleGroupByOutputType[P]>
            : GetScalarType<T[P], BoxArticleGroupByOutputType[P]>
        }
      >
    >


  export type BoxArticleSelect = {
    id?: boolean
    winningChance?: boolean
    boxId?: boolean
    articleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    box?: boolean | BoxArgs
    article?: boolean | ArticleArgs
  }


  export type BoxArticleInclude = {
    box?: boolean | BoxArgs
    article?: boolean | ArticleArgs
  }

  export type BoxArticleGetPayload<S extends boolean | null | undefined | BoxArticleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BoxArticle :
    S extends undefined ? never :
    S extends { include: any } & (BoxArticleArgs | BoxArticleFindManyArgs)
    ? BoxArticle  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'box' ? BoxGetPayload<S['include'][P]> :
        P extends 'article' ? ArticleGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BoxArticleArgs | BoxArticleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'box' ? BoxGetPayload<S['select'][P]> :
        P extends 'article' ? ArticleGetPayload<S['select'][P]> :  P extends keyof BoxArticle ? BoxArticle[P] : never
  } 
      : BoxArticle


  type BoxArticleCountArgs = 
    Omit<BoxArticleFindManyArgs, 'select' | 'include'> & {
      select?: BoxArticleCountAggregateInputType | true
    }

  export interface BoxArticleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BoxArticle that matches the filter.
     * @param {BoxArticleFindUniqueArgs} args - Arguments to find a BoxArticle
     * @example
     * // Get one BoxArticle
     * const boxArticle = await prisma.boxArticle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BoxArticleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BoxArticleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BoxArticle'> extends True ? Prisma__BoxArticleClient<BoxArticleGetPayload<T>> : Prisma__BoxArticleClient<BoxArticleGetPayload<T> | null, null>

    /**
     * Find one BoxArticle that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BoxArticleFindUniqueOrThrowArgs} args - Arguments to find a BoxArticle
     * @example
     * // Get one BoxArticle
     * const boxArticle = await prisma.boxArticle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BoxArticleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BoxArticleFindUniqueOrThrowArgs>
    ): Prisma__BoxArticleClient<BoxArticleGetPayload<T>>

    /**
     * Find the first BoxArticle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxArticleFindFirstArgs} args - Arguments to find a BoxArticle
     * @example
     * // Get one BoxArticle
     * const boxArticle = await prisma.boxArticle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BoxArticleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BoxArticleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BoxArticle'> extends True ? Prisma__BoxArticleClient<BoxArticleGetPayload<T>> : Prisma__BoxArticleClient<BoxArticleGetPayload<T> | null, null>

    /**
     * Find the first BoxArticle that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxArticleFindFirstOrThrowArgs} args - Arguments to find a BoxArticle
     * @example
     * // Get one BoxArticle
     * const boxArticle = await prisma.boxArticle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BoxArticleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BoxArticleFindFirstOrThrowArgs>
    ): Prisma__BoxArticleClient<BoxArticleGetPayload<T>>

    /**
     * Find zero or more BoxArticles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxArticleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoxArticles
     * const boxArticles = await prisma.boxArticle.findMany()
     * 
     * // Get first 10 BoxArticles
     * const boxArticles = await prisma.boxArticle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boxArticleWithIdOnly = await prisma.boxArticle.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BoxArticleFindManyArgs>(
      args?: SelectSubset<T, BoxArticleFindManyArgs>
    ): Prisma.PrismaPromise<Array<BoxArticleGetPayload<T>>>

    /**
     * Create a BoxArticle.
     * @param {BoxArticleCreateArgs} args - Arguments to create a BoxArticle.
     * @example
     * // Create one BoxArticle
     * const BoxArticle = await prisma.boxArticle.create({
     *   data: {
     *     // ... data to create a BoxArticle
     *   }
     * })
     * 
    **/
    create<T extends BoxArticleCreateArgs>(
      args: SelectSubset<T, BoxArticleCreateArgs>
    ): Prisma__BoxArticleClient<BoxArticleGetPayload<T>>

    /**
     * Create many BoxArticles.
     *     @param {BoxArticleCreateManyArgs} args - Arguments to create many BoxArticles.
     *     @example
     *     // Create many BoxArticles
     *     const boxArticle = await prisma.boxArticle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BoxArticleCreateManyArgs>(
      args?: SelectSubset<T, BoxArticleCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BoxArticle.
     * @param {BoxArticleDeleteArgs} args - Arguments to delete one BoxArticle.
     * @example
     * // Delete one BoxArticle
     * const BoxArticle = await prisma.boxArticle.delete({
     *   where: {
     *     // ... filter to delete one BoxArticle
     *   }
     * })
     * 
    **/
    delete<T extends BoxArticleDeleteArgs>(
      args: SelectSubset<T, BoxArticleDeleteArgs>
    ): Prisma__BoxArticleClient<BoxArticleGetPayload<T>>

    /**
     * Update one BoxArticle.
     * @param {BoxArticleUpdateArgs} args - Arguments to update one BoxArticle.
     * @example
     * // Update one BoxArticle
     * const boxArticle = await prisma.boxArticle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BoxArticleUpdateArgs>(
      args: SelectSubset<T, BoxArticleUpdateArgs>
    ): Prisma__BoxArticleClient<BoxArticleGetPayload<T>>

    /**
     * Delete zero or more BoxArticles.
     * @param {BoxArticleDeleteManyArgs} args - Arguments to filter BoxArticles to delete.
     * @example
     * // Delete a few BoxArticles
     * const { count } = await prisma.boxArticle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BoxArticleDeleteManyArgs>(
      args?: SelectSubset<T, BoxArticleDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoxArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoxArticles
     * const boxArticle = await prisma.boxArticle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BoxArticleUpdateManyArgs>(
      args: SelectSubset<T, BoxArticleUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BoxArticle.
     * @param {BoxArticleUpsertArgs} args - Arguments to update or create a BoxArticle.
     * @example
     * // Update or create a BoxArticle
     * const boxArticle = await prisma.boxArticle.upsert({
     *   create: {
     *     // ... data to create a BoxArticle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoxArticle we want to update
     *   }
     * })
    **/
    upsert<T extends BoxArticleUpsertArgs>(
      args: SelectSubset<T, BoxArticleUpsertArgs>
    ): Prisma__BoxArticleClient<BoxArticleGetPayload<T>>

    /**
     * Find zero or more BoxArticles that matches the filter.
     * @param {BoxArticleFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const boxArticle = await prisma.boxArticle.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: BoxArticleFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a BoxArticle.
     * @param {BoxArticleAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const boxArticle = await prisma.boxArticle.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: BoxArticleAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of BoxArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxArticleCountArgs} args - Arguments to filter BoxArticles to count.
     * @example
     * // Count the number of BoxArticles
     * const count = await prisma.boxArticle.count({
     *   where: {
     *     // ... the filter for the BoxArticles we want to count
     *   }
     * })
    **/
    count<T extends BoxArticleCountArgs>(
      args?: Subset<T, BoxArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoxArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoxArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoxArticleAggregateArgs>(args: Subset<T, BoxArticleAggregateArgs>): Prisma.PrismaPromise<GetBoxArticleAggregateType<T>>

    /**
     * Group by BoxArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoxArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoxArticleGroupByArgs['orderBy'] }
        : { orderBy?: BoxArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoxArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoxArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BoxArticle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BoxArticleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    box<T extends BoxArgs= {}>(args?: Subset<T, BoxArgs>): Prisma__BoxClient<BoxGetPayload<T> | Null>;

    article<T extends ArticleArgs= {}>(args?: Subset<T, ArticleArgs>): Prisma__ArticleClient<ArticleGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BoxArticle base type for findUnique actions
   */
  export type BoxArticleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BoxArticle
     */
    select?: BoxArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxArticleInclude | null
    /**
     * Filter, which BoxArticle to fetch.
     */
    where: BoxArticleWhereUniqueInput
  }

  /**
   * BoxArticle findUnique
   */
  export interface BoxArticleFindUniqueArgs extends BoxArticleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoxArticle findUniqueOrThrow
   */
  export type BoxArticleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoxArticle
     */
    select?: BoxArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxArticleInclude | null
    /**
     * Filter, which BoxArticle to fetch.
     */
    where: BoxArticleWhereUniqueInput
  }


  /**
   * BoxArticle base type for findFirst actions
   */
  export type BoxArticleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BoxArticle
     */
    select?: BoxArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxArticleInclude | null
    /**
     * Filter, which BoxArticle to fetch.
     */
    where?: BoxArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoxArticles to fetch.
     */
    orderBy?: Enumerable<BoxArticleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoxArticles.
     */
    cursor?: BoxArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoxArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoxArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoxArticles.
     */
    distinct?: Enumerable<BoxArticleScalarFieldEnum>
  }

  /**
   * BoxArticle findFirst
   */
  export interface BoxArticleFindFirstArgs extends BoxArticleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoxArticle findFirstOrThrow
   */
  export type BoxArticleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoxArticle
     */
    select?: BoxArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxArticleInclude | null
    /**
     * Filter, which BoxArticle to fetch.
     */
    where?: BoxArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoxArticles to fetch.
     */
    orderBy?: Enumerable<BoxArticleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoxArticles.
     */
    cursor?: BoxArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoxArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoxArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoxArticles.
     */
    distinct?: Enumerable<BoxArticleScalarFieldEnum>
  }


  /**
   * BoxArticle findMany
   */
  export type BoxArticleFindManyArgs = {
    /**
     * Select specific fields to fetch from the BoxArticle
     */
    select?: BoxArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxArticleInclude | null
    /**
     * Filter, which BoxArticles to fetch.
     */
    where?: BoxArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoxArticles to fetch.
     */
    orderBy?: Enumerable<BoxArticleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoxArticles.
     */
    cursor?: BoxArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoxArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoxArticles.
     */
    skip?: number
    distinct?: Enumerable<BoxArticleScalarFieldEnum>
  }


  /**
   * BoxArticle create
   */
  export type BoxArticleCreateArgs = {
    /**
     * Select specific fields to fetch from the BoxArticle
     */
    select?: BoxArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxArticleInclude | null
    /**
     * The data needed to create a BoxArticle.
     */
    data: XOR<BoxArticleCreateInput, BoxArticleUncheckedCreateInput>
  }


  /**
   * BoxArticle createMany
   */
  export type BoxArticleCreateManyArgs = {
    /**
     * The data used to create many BoxArticles.
     */
    data: Enumerable<BoxArticleCreateManyInput>
  }


  /**
   * BoxArticle update
   */
  export type BoxArticleUpdateArgs = {
    /**
     * Select specific fields to fetch from the BoxArticle
     */
    select?: BoxArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxArticleInclude | null
    /**
     * The data needed to update a BoxArticle.
     */
    data: XOR<BoxArticleUpdateInput, BoxArticleUncheckedUpdateInput>
    /**
     * Choose, which BoxArticle to update.
     */
    where: BoxArticleWhereUniqueInput
  }


  /**
   * BoxArticle updateMany
   */
  export type BoxArticleUpdateManyArgs = {
    /**
     * The data used to update BoxArticles.
     */
    data: XOR<BoxArticleUpdateManyMutationInput, BoxArticleUncheckedUpdateManyInput>
    /**
     * Filter which BoxArticles to update
     */
    where?: BoxArticleWhereInput
  }


  /**
   * BoxArticle upsert
   */
  export type BoxArticleUpsertArgs = {
    /**
     * Select specific fields to fetch from the BoxArticle
     */
    select?: BoxArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxArticleInclude | null
    /**
     * The filter to search for the BoxArticle to update in case it exists.
     */
    where: BoxArticleWhereUniqueInput
    /**
     * In case the BoxArticle found by the `where` argument doesn't exist, create a new BoxArticle with this data.
     */
    create: XOR<BoxArticleCreateInput, BoxArticleUncheckedCreateInput>
    /**
     * In case the BoxArticle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoxArticleUpdateInput, BoxArticleUncheckedUpdateInput>
  }


  /**
   * BoxArticle delete
   */
  export type BoxArticleDeleteArgs = {
    /**
     * Select specific fields to fetch from the BoxArticle
     */
    select?: BoxArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxArticleInclude | null
    /**
     * Filter which BoxArticle to delete.
     */
    where: BoxArticleWhereUniqueInput
  }


  /**
   * BoxArticle deleteMany
   */
  export type BoxArticleDeleteManyArgs = {
    /**
     * Filter which BoxArticles to delete
     */
    where?: BoxArticleWhereInput
  }


  /**
   * BoxArticle findRaw
   */
  export type BoxArticleFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * BoxArticle aggregateRaw
   */
  export type BoxArticleAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * BoxArticle without action
   */
  export type BoxArticleArgs = {
    /**
     * Select specific fields to fetch from the BoxArticle
     */
    select?: BoxArticleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxArticleInclude | null
  }



  /**
   * Model ArticlePhoto
   */


  export type AggregateArticlePhoto = {
    _count: ArticlePhotoCountAggregateOutputType | null
    _min: ArticlePhotoMinAggregateOutputType | null
    _max: ArticlePhotoMaxAggregateOutputType | null
  }

  export type ArticlePhotoMinAggregateOutputType = {
    id: string | null
    photoUrl: string | null
    status: ArticlePhotoStatus | null
    articleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArticlePhotoMaxAggregateOutputType = {
    id: string | null
    photoUrl: string | null
    status: ArticlePhotoStatus | null
    articleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArticlePhotoCountAggregateOutputType = {
    id: number
    photoUrl: number
    status: number
    articleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ArticlePhotoMinAggregateInputType = {
    id?: true
    photoUrl?: true
    status?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArticlePhotoMaxAggregateInputType = {
    id?: true
    photoUrl?: true
    status?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArticlePhotoCountAggregateInputType = {
    id?: true
    photoUrl?: true
    status?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ArticlePhotoAggregateArgs = {
    /**
     * Filter which ArticlePhoto to aggregate.
     */
    where?: ArticlePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticlePhotos to fetch.
     */
    orderBy?: Enumerable<ArticlePhotoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticlePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticlePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticlePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArticlePhotos
    **/
    _count?: true | ArticlePhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticlePhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticlePhotoMaxAggregateInputType
  }

  export type GetArticlePhotoAggregateType<T extends ArticlePhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateArticlePhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticlePhoto[P]>
      : GetScalarType<T[P], AggregateArticlePhoto[P]>
  }




  export type ArticlePhotoGroupByArgs = {
    where?: ArticlePhotoWhereInput
    orderBy?: Enumerable<ArticlePhotoOrderByWithAggregationInput>
    by: ArticlePhotoScalarFieldEnum[]
    having?: ArticlePhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticlePhotoCountAggregateInputType | true
    _min?: ArticlePhotoMinAggregateInputType
    _max?: ArticlePhotoMaxAggregateInputType
  }


  export type ArticlePhotoGroupByOutputType = {
    id: string
    photoUrl: string
    status: ArticlePhotoStatus | null
    articleId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: ArticlePhotoCountAggregateOutputType | null
    _min: ArticlePhotoMinAggregateOutputType | null
    _max: ArticlePhotoMaxAggregateOutputType | null
  }

  type GetArticlePhotoGroupByPayload<T extends ArticlePhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ArticlePhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticlePhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticlePhotoGroupByOutputType[P]>
            : GetScalarType<T[P], ArticlePhotoGroupByOutputType[P]>
        }
      >
    >


  export type ArticlePhotoSelect = {
    id?: boolean
    photoUrl?: boolean
    status?: boolean
    articleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    article?: boolean | ArticleArgs
  }


  export type ArticlePhotoInclude = {
    article?: boolean | ArticleArgs
  }

  export type ArticlePhotoGetPayload<S extends boolean | null | undefined | ArticlePhotoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ArticlePhoto :
    S extends undefined ? never :
    S extends { include: any } & (ArticlePhotoArgs | ArticlePhotoFindManyArgs)
    ? ArticlePhoto  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'article' ? ArticleGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ArticlePhotoArgs | ArticlePhotoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'article' ? ArticleGetPayload<S['select'][P]> :  P extends keyof ArticlePhoto ? ArticlePhoto[P] : never
  } 
      : ArticlePhoto


  type ArticlePhotoCountArgs = 
    Omit<ArticlePhotoFindManyArgs, 'select' | 'include'> & {
      select?: ArticlePhotoCountAggregateInputType | true
    }

  export interface ArticlePhotoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ArticlePhoto that matches the filter.
     * @param {ArticlePhotoFindUniqueArgs} args - Arguments to find a ArticlePhoto
     * @example
     * // Get one ArticlePhoto
     * const articlePhoto = await prisma.articlePhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ArticlePhotoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ArticlePhotoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ArticlePhoto'> extends True ? Prisma__ArticlePhotoClient<ArticlePhotoGetPayload<T>> : Prisma__ArticlePhotoClient<ArticlePhotoGetPayload<T> | null, null>

    /**
     * Find one ArticlePhoto that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ArticlePhotoFindUniqueOrThrowArgs} args - Arguments to find a ArticlePhoto
     * @example
     * // Get one ArticlePhoto
     * const articlePhoto = await prisma.articlePhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ArticlePhotoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ArticlePhotoFindUniqueOrThrowArgs>
    ): Prisma__ArticlePhotoClient<ArticlePhotoGetPayload<T>>

    /**
     * Find the first ArticlePhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticlePhotoFindFirstArgs} args - Arguments to find a ArticlePhoto
     * @example
     * // Get one ArticlePhoto
     * const articlePhoto = await prisma.articlePhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ArticlePhotoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ArticlePhotoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ArticlePhoto'> extends True ? Prisma__ArticlePhotoClient<ArticlePhotoGetPayload<T>> : Prisma__ArticlePhotoClient<ArticlePhotoGetPayload<T> | null, null>

    /**
     * Find the first ArticlePhoto that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticlePhotoFindFirstOrThrowArgs} args - Arguments to find a ArticlePhoto
     * @example
     * // Get one ArticlePhoto
     * const articlePhoto = await prisma.articlePhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ArticlePhotoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ArticlePhotoFindFirstOrThrowArgs>
    ): Prisma__ArticlePhotoClient<ArticlePhotoGetPayload<T>>

    /**
     * Find zero or more ArticlePhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticlePhotoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArticlePhotos
     * const articlePhotos = await prisma.articlePhoto.findMany()
     * 
     * // Get first 10 ArticlePhotos
     * const articlePhotos = await prisma.articlePhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articlePhotoWithIdOnly = await prisma.articlePhoto.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ArticlePhotoFindManyArgs>(
      args?: SelectSubset<T, ArticlePhotoFindManyArgs>
    ): Prisma.PrismaPromise<Array<ArticlePhotoGetPayload<T>>>

    /**
     * Create a ArticlePhoto.
     * @param {ArticlePhotoCreateArgs} args - Arguments to create a ArticlePhoto.
     * @example
     * // Create one ArticlePhoto
     * const ArticlePhoto = await prisma.articlePhoto.create({
     *   data: {
     *     // ... data to create a ArticlePhoto
     *   }
     * })
     * 
    **/
    create<T extends ArticlePhotoCreateArgs>(
      args: SelectSubset<T, ArticlePhotoCreateArgs>
    ): Prisma__ArticlePhotoClient<ArticlePhotoGetPayload<T>>

    /**
     * Create many ArticlePhotos.
     *     @param {ArticlePhotoCreateManyArgs} args - Arguments to create many ArticlePhotos.
     *     @example
     *     // Create many ArticlePhotos
     *     const articlePhoto = await prisma.articlePhoto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ArticlePhotoCreateManyArgs>(
      args?: SelectSubset<T, ArticlePhotoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ArticlePhoto.
     * @param {ArticlePhotoDeleteArgs} args - Arguments to delete one ArticlePhoto.
     * @example
     * // Delete one ArticlePhoto
     * const ArticlePhoto = await prisma.articlePhoto.delete({
     *   where: {
     *     // ... filter to delete one ArticlePhoto
     *   }
     * })
     * 
    **/
    delete<T extends ArticlePhotoDeleteArgs>(
      args: SelectSubset<T, ArticlePhotoDeleteArgs>
    ): Prisma__ArticlePhotoClient<ArticlePhotoGetPayload<T>>

    /**
     * Update one ArticlePhoto.
     * @param {ArticlePhotoUpdateArgs} args - Arguments to update one ArticlePhoto.
     * @example
     * // Update one ArticlePhoto
     * const articlePhoto = await prisma.articlePhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ArticlePhotoUpdateArgs>(
      args: SelectSubset<T, ArticlePhotoUpdateArgs>
    ): Prisma__ArticlePhotoClient<ArticlePhotoGetPayload<T>>

    /**
     * Delete zero or more ArticlePhotos.
     * @param {ArticlePhotoDeleteManyArgs} args - Arguments to filter ArticlePhotos to delete.
     * @example
     * // Delete a few ArticlePhotos
     * const { count } = await prisma.articlePhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ArticlePhotoDeleteManyArgs>(
      args?: SelectSubset<T, ArticlePhotoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArticlePhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticlePhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArticlePhotos
     * const articlePhoto = await prisma.articlePhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ArticlePhotoUpdateManyArgs>(
      args: SelectSubset<T, ArticlePhotoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ArticlePhoto.
     * @param {ArticlePhotoUpsertArgs} args - Arguments to update or create a ArticlePhoto.
     * @example
     * // Update or create a ArticlePhoto
     * const articlePhoto = await prisma.articlePhoto.upsert({
     *   create: {
     *     // ... data to create a ArticlePhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArticlePhoto we want to update
     *   }
     * })
    **/
    upsert<T extends ArticlePhotoUpsertArgs>(
      args: SelectSubset<T, ArticlePhotoUpsertArgs>
    ): Prisma__ArticlePhotoClient<ArticlePhotoGetPayload<T>>

    /**
     * Find zero or more ArticlePhotos that matches the filter.
     * @param {ArticlePhotoFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const articlePhoto = await prisma.articlePhoto.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ArticlePhotoFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ArticlePhoto.
     * @param {ArticlePhotoAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const articlePhoto = await prisma.articlePhoto.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ArticlePhotoAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of ArticlePhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticlePhotoCountArgs} args - Arguments to filter ArticlePhotos to count.
     * @example
     * // Count the number of ArticlePhotos
     * const count = await prisma.articlePhoto.count({
     *   where: {
     *     // ... the filter for the ArticlePhotos we want to count
     *   }
     * })
    **/
    count<T extends ArticlePhotoCountArgs>(
      args?: Subset<T, ArticlePhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticlePhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArticlePhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticlePhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticlePhotoAggregateArgs>(args: Subset<T, ArticlePhotoAggregateArgs>): Prisma.PrismaPromise<GetArticlePhotoAggregateType<T>>

    /**
     * Group by ArticlePhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticlePhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticlePhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticlePhotoGroupByArgs['orderBy'] }
        : { orderBy?: ArticlePhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticlePhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticlePhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ArticlePhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ArticlePhotoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    article<T extends ArticleArgs= {}>(args?: Subset<T, ArticleArgs>): Prisma__ArticleClient<ArticleGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ArticlePhoto base type for findUnique actions
   */
  export type ArticlePhotoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ArticlePhoto
     */
    select?: ArticlePhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticlePhotoInclude | null
    /**
     * Filter, which ArticlePhoto to fetch.
     */
    where: ArticlePhotoWhereUniqueInput
  }

  /**
   * ArticlePhoto findUnique
   */
  export interface ArticlePhotoFindUniqueArgs extends ArticlePhotoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ArticlePhoto findUniqueOrThrow
   */
  export type ArticlePhotoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ArticlePhoto
     */
    select?: ArticlePhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticlePhotoInclude | null
    /**
     * Filter, which ArticlePhoto to fetch.
     */
    where: ArticlePhotoWhereUniqueInput
  }


  /**
   * ArticlePhoto base type for findFirst actions
   */
  export type ArticlePhotoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ArticlePhoto
     */
    select?: ArticlePhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticlePhotoInclude | null
    /**
     * Filter, which ArticlePhoto to fetch.
     */
    where?: ArticlePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticlePhotos to fetch.
     */
    orderBy?: Enumerable<ArticlePhotoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticlePhotos.
     */
    cursor?: ArticlePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticlePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticlePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticlePhotos.
     */
    distinct?: Enumerable<ArticlePhotoScalarFieldEnum>
  }

  /**
   * ArticlePhoto findFirst
   */
  export interface ArticlePhotoFindFirstArgs extends ArticlePhotoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ArticlePhoto findFirstOrThrow
   */
  export type ArticlePhotoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ArticlePhoto
     */
    select?: ArticlePhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticlePhotoInclude | null
    /**
     * Filter, which ArticlePhoto to fetch.
     */
    where?: ArticlePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticlePhotos to fetch.
     */
    orderBy?: Enumerable<ArticlePhotoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticlePhotos.
     */
    cursor?: ArticlePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticlePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticlePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticlePhotos.
     */
    distinct?: Enumerable<ArticlePhotoScalarFieldEnum>
  }


  /**
   * ArticlePhoto findMany
   */
  export type ArticlePhotoFindManyArgs = {
    /**
     * Select specific fields to fetch from the ArticlePhoto
     */
    select?: ArticlePhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticlePhotoInclude | null
    /**
     * Filter, which ArticlePhotos to fetch.
     */
    where?: ArticlePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticlePhotos to fetch.
     */
    orderBy?: Enumerable<ArticlePhotoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArticlePhotos.
     */
    cursor?: ArticlePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticlePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticlePhotos.
     */
    skip?: number
    distinct?: Enumerable<ArticlePhotoScalarFieldEnum>
  }


  /**
   * ArticlePhoto create
   */
  export type ArticlePhotoCreateArgs = {
    /**
     * Select specific fields to fetch from the ArticlePhoto
     */
    select?: ArticlePhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticlePhotoInclude | null
    /**
     * The data needed to create a ArticlePhoto.
     */
    data: XOR<ArticlePhotoCreateInput, ArticlePhotoUncheckedCreateInput>
  }


  /**
   * ArticlePhoto createMany
   */
  export type ArticlePhotoCreateManyArgs = {
    /**
     * The data used to create many ArticlePhotos.
     */
    data: Enumerable<ArticlePhotoCreateManyInput>
  }


  /**
   * ArticlePhoto update
   */
  export type ArticlePhotoUpdateArgs = {
    /**
     * Select specific fields to fetch from the ArticlePhoto
     */
    select?: ArticlePhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticlePhotoInclude | null
    /**
     * The data needed to update a ArticlePhoto.
     */
    data: XOR<ArticlePhotoUpdateInput, ArticlePhotoUncheckedUpdateInput>
    /**
     * Choose, which ArticlePhoto to update.
     */
    where: ArticlePhotoWhereUniqueInput
  }


  /**
   * ArticlePhoto updateMany
   */
  export type ArticlePhotoUpdateManyArgs = {
    /**
     * The data used to update ArticlePhotos.
     */
    data: XOR<ArticlePhotoUpdateManyMutationInput, ArticlePhotoUncheckedUpdateManyInput>
    /**
     * Filter which ArticlePhotos to update
     */
    where?: ArticlePhotoWhereInput
  }


  /**
   * ArticlePhoto upsert
   */
  export type ArticlePhotoUpsertArgs = {
    /**
     * Select specific fields to fetch from the ArticlePhoto
     */
    select?: ArticlePhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticlePhotoInclude | null
    /**
     * The filter to search for the ArticlePhoto to update in case it exists.
     */
    where: ArticlePhotoWhereUniqueInput
    /**
     * In case the ArticlePhoto found by the `where` argument doesn't exist, create a new ArticlePhoto with this data.
     */
    create: XOR<ArticlePhotoCreateInput, ArticlePhotoUncheckedCreateInput>
    /**
     * In case the ArticlePhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticlePhotoUpdateInput, ArticlePhotoUncheckedUpdateInput>
  }


  /**
   * ArticlePhoto delete
   */
  export type ArticlePhotoDeleteArgs = {
    /**
     * Select specific fields to fetch from the ArticlePhoto
     */
    select?: ArticlePhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticlePhotoInclude | null
    /**
     * Filter which ArticlePhoto to delete.
     */
    where: ArticlePhotoWhereUniqueInput
  }


  /**
   * ArticlePhoto deleteMany
   */
  export type ArticlePhotoDeleteManyArgs = {
    /**
     * Filter which ArticlePhotos to delete
     */
    where?: ArticlePhotoWhereInput
  }


  /**
   * ArticlePhoto findRaw
   */
  export type ArticlePhotoFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * ArticlePhoto aggregateRaw
   */
  export type ArticlePhotoAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * ArticlePhoto without action
   */
  export type ArticlePhotoArgs = {
    /**
     * Select specific fields to fetch from the ArticlePhoto
     */
    select?: ArticlePhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticlePhotoInclude | null
  }



  /**
   * Model Post
   */


  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    postUrl: string | null
    articleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    postUrl: string | null
    articleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    title: number
    content: number
    postUrl: number
    articleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    postUrl?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    postUrl?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    postUrl?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostAggregateArgs = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs = {
    where?: PostWhereInput
    orderBy?: Enumerable<PostOrderByWithAggregationInput>
    by: PostScalarFieldEnum[]
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }


  export type PostGroupByOutputType = {
    id: string
    title: string
    content: string
    postUrl: string
    articleId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect = {
    id?: boolean
    title?: boolean
    content?: boolean
    postUrl?: boolean
    articleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    article?: boolean | ArticleArgs
  }


  export type PostInclude = {
    article?: boolean | ArticleArgs
  }

  export type PostGetPayload<S extends boolean | null | undefined | PostArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Post :
    S extends undefined ? never :
    S extends { include: any } & (PostArgs | PostFindManyArgs)
    ? Post  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'article' ? ArticleGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PostArgs | PostFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'article' ? ArticleGetPayload<S['select'][P]> :  P extends keyof Post ? Post[P] : never
  } 
      : Post


  type PostCountArgs = 
    Omit<PostFindManyArgs, 'select' | 'include'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Post'> extends True ? Prisma__PostClient<PostGetPayload<T>> : Prisma__PostClient<PostGetPayload<T> | null, null>

    /**
     * Find one Post that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PostFindUniqueOrThrowArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Post'> extends True ? Prisma__PostClient<PostGetPayload<T>> : Prisma__PostClient<PostGetPayload<T> | null, null>

    /**
     * Find the first Post that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PostFindFirstOrThrowArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostFindManyArgs>(
      args?: SelectSubset<T, PostFindManyArgs>
    ): Prisma.PrismaPromise<Array<PostGetPayload<T>>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
    **/
    create<T extends PostCreateArgs>(
      args: SelectSubset<T, PostCreateArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Create many Posts.
     *     @param {PostCreateManyArgs} args - Arguments to create many Posts.
     *     @example
     *     // Create many Posts
     *     const post = await prisma.post.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostCreateManyArgs>(
      args?: SelectSubset<T, PostCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
    **/
    delete<T extends PostDeleteArgs>(
      args: SelectSubset<T, PostDeleteArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostUpdateArgs>(
      args: SelectSubset<T, PostUpdateArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostDeleteManyArgs>(
      args?: SelectSubset<T, PostDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostUpdateManyArgs>(
      args: SelectSubset<T, PostUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
    **/
    upsert<T extends PostUpsertArgs>(
      args: SelectSubset<T, PostUpsertArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Find zero or more Posts that matches the filter.
     * @param {PostFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const post = await prisma.post.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: PostFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Post.
     * @param {PostAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const post = await prisma.post.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: PostAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PostClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    article<T extends ArticleArgs= {}>(args?: Subset<T, ArticleArgs>): Prisma__ArticleClient<ArticleGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Post base type for findUnique actions
   */
  export type PostFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUnique
   */
  export interface PostFindUniqueArgs extends PostFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post base type for findFirst actions
   */
  export type PostFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: Enumerable<PostScalarFieldEnum>
  }

  /**
   * Post findFirst
   */
  export interface PostFindFirstArgs extends PostFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * Post findMany
   */
  export type PostFindManyArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * Post create
   */
  export type PostCreateArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }


  /**
   * Post createMany
   */
  export type PostCreateManyArgs = {
    /**
     * The data used to create many Posts.
     */
    data: Enumerable<PostCreateManyInput>
  }


  /**
   * Post update
   */
  export type PostUpdateArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
  }


  /**
   * Post upsert
   */
  export type PostUpsertArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }


  /**
   * Post delete
   */
  export type PostDeleteArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
  }


  /**
   * Post findRaw
   */
  export type PostFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Post aggregateRaw
   */
  export type PostAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Post without action
   */
  export type PostArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
  }



  /**
   * Model Price
   */


  export type AggregatePrice = {
    _count: PriceCountAggregateOutputType | null
    _avg: PriceAvgAggregateOutputType | null
    _sum: PriceSumAggregateOutputType | null
    _min: PriceMinAggregateOutputType | null
    _max: PriceMaxAggregateOutputType | null
  }

  export type PriceAvgAggregateOutputType = {
    currentPrice: number | null
    oldPrice: number | null
    rate: number | null
    reduction: number | null
    sellingPrice: number | null
  }

  export type PriceSumAggregateOutputType = {
    currentPrice: number | null
    oldPrice: number | null
    rate: number | null
    reduction: number | null
    sellingPrice: number | null
  }

  export type PriceMinAggregateOutputType = {
    id: string | null
    reference: string | null
    currentPrice: number | null
    oldPrice: number | null
    rate: number | null
    reduction: number | null
    sellingPrice: number | null
    articleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PriceMaxAggregateOutputType = {
    id: string | null
    reference: string | null
    currentPrice: number | null
    oldPrice: number | null
    rate: number | null
    reduction: number | null
    sellingPrice: number | null
    articleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PriceCountAggregateOutputType = {
    id: number
    reference: number
    currentPrice: number
    oldPrice: number
    rate: number
    reduction: number
    sellingPrice: number
    articleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PriceAvgAggregateInputType = {
    currentPrice?: true
    oldPrice?: true
    rate?: true
    reduction?: true
    sellingPrice?: true
  }

  export type PriceSumAggregateInputType = {
    currentPrice?: true
    oldPrice?: true
    rate?: true
    reduction?: true
    sellingPrice?: true
  }

  export type PriceMinAggregateInputType = {
    id?: true
    reference?: true
    currentPrice?: true
    oldPrice?: true
    rate?: true
    reduction?: true
    sellingPrice?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PriceMaxAggregateInputType = {
    id?: true
    reference?: true
    currentPrice?: true
    oldPrice?: true
    rate?: true
    reduction?: true
    sellingPrice?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PriceCountAggregateInputType = {
    id?: true
    reference?: true
    currentPrice?: true
    oldPrice?: true
    rate?: true
    reduction?: true
    sellingPrice?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PriceAggregateArgs = {
    /**
     * Filter which Price to aggregate.
     */
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: Enumerable<PriceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prices
    **/
    _count?: true | PriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceMaxAggregateInputType
  }

  export type GetPriceAggregateType<T extends PriceAggregateArgs> = {
        [P in keyof T & keyof AggregatePrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrice[P]>
      : GetScalarType<T[P], AggregatePrice[P]>
  }




  export type PriceGroupByArgs = {
    where?: PriceWhereInput
    orderBy?: Enumerable<PriceOrderByWithAggregationInput>
    by: PriceScalarFieldEnum[]
    having?: PriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceCountAggregateInputType | true
    _avg?: PriceAvgAggregateInputType
    _sum?: PriceSumAggregateInputType
    _min?: PriceMinAggregateInputType
    _max?: PriceMaxAggregateInputType
  }


  export type PriceGroupByOutputType = {
    id: string
    reference: string | null
    currentPrice: number
    oldPrice: number | null
    rate: number | null
    reduction: number | null
    sellingPrice: number | null
    articleId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: PriceCountAggregateOutputType | null
    _avg: PriceAvgAggregateOutputType | null
    _sum: PriceSumAggregateOutputType | null
    _min: PriceMinAggregateOutputType | null
    _max: PriceMaxAggregateOutputType | null
  }

  type GetPriceGroupByPayload<T extends PriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceGroupByOutputType[P]>
            : GetScalarType<T[P], PriceGroupByOutputType[P]>
        }
      >
    >


  export type PriceSelect = {
    id?: boolean
    reference?: boolean
    currentPrice?: boolean
    oldPrice?: boolean
    rate?: boolean
    reduction?: boolean
    sellingPrice?: boolean
    articleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    article?: boolean | ArticleArgs
  }


  export type PriceInclude = {
    article?: boolean | ArticleArgs
  }

  export type PriceGetPayload<S extends boolean | null | undefined | PriceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Price :
    S extends undefined ? never :
    S extends { include: any } & (PriceArgs | PriceFindManyArgs)
    ? Price  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'article' ? ArticleGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PriceArgs | PriceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'article' ? ArticleGetPayload<S['select'][P]> :  P extends keyof Price ? Price[P] : never
  } 
      : Price


  type PriceCountArgs = 
    Omit<PriceFindManyArgs, 'select' | 'include'> & {
      select?: PriceCountAggregateInputType | true
    }

  export interface PriceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Price that matches the filter.
     * @param {PriceFindUniqueArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PriceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PriceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Price'> extends True ? Prisma__PriceClient<PriceGetPayload<T>> : Prisma__PriceClient<PriceGetPayload<T> | null, null>

    /**
     * Find one Price that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PriceFindUniqueOrThrowArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PriceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PriceFindUniqueOrThrowArgs>
    ): Prisma__PriceClient<PriceGetPayload<T>>

    /**
     * Find the first Price that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceFindFirstArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PriceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PriceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Price'> extends True ? Prisma__PriceClient<PriceGetPayload<T>> : Prisma__PriceClient<PriceGetPayload<T> | null, null>

    /**
     * Find the first Price that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceFindFirstOrThrowArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PriceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PriceFindFirstOrThrowArgs>
    ): Prisma__PriceClient<PriceGetPayload<T>>

    /**
     * Find zero or more Prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prices
     * const prices = await prisma.price.findMany()
     * 
     * // Get first 10 Prices
     * const prices = await prisma.price.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceWithIdOnly = await prisma.price.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PriceFindManyArgs>(
      args?: SelectSubset<T, PriceFindManyArgs>
    ): Prisma.PrismaPromise<Array<PriceGetPayload<T>>>

    /**
     * Create a Price.
     * @param {PriceCreateArgs} args - Arguments to create a Price.
     * @example
     * // Create one Price
     * const Price = await prisma.price.create({
     *   data: {
     *     // ... data to create a Price
     *   }
     * })
     * 
    **/
    create<T extends PriceCreateArgs>(
      args: SelectSubset<T, PriceCreateArgs>
    ): Prisma__PriceClient<PriceGetPayload<T>>

    /**
     * Create many Prices.
     *     @param {PriceCreateManyArgs} args - Arguments to create many Prices.
     *     @example
     *     // Create many Prices
     *     const price = await prisma.price.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PriceCreateManyArgs>(
      args?: SelectSubset<T, PriceCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Price.
     * @param {PriceDeleteArgs} args - Arguments to delete one Price.
     * @example
     * // Delete one Price
     * const Price = await prisma.price.delete({
     *   where: {
     *     // ... filter to delete one Price
     *   }
     * })
     * 
    **/
    delete<T extends PriceDeleteArgs>(
      args: SelectSubset<T, PriceDeleteArgs>
    ): Prisma__PriceClient<PriceGetPayload<T>>

    /**
     * Update one Price.
     * @param {PriceUpdateArgs} args - Arguments to update one Price.
     * @example
     * // Update one Price
     * const price = await prisma.price.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PriceUpdateArgs>(
      args: SelectSubset<T, PriceUpdateArgs>
    ): Prisma__PriceClient<PriceGetPayload<T>>

    /**
     * Delete zero or more Prices.
     * @param {PriceDeleteManyArgs} args - Arguments to filter Prices to delete.
     * @example
     * // Delete a few Prices
     * const { count } = await prisma.price.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PriceDeleteManyArgs>(
      args?: SelectSubset<T, PriceDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prices
     * const price = await prisma.price.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PriceUpdateManyArgs>(
      args: SelectSubset<T, PriceUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Price.
     * @param {PriceUpsertArgs} args - Arguments to update or create a Price.
     * @example
     * // Update or create a Price
     * const price = await prisma.price.upsert({
     *   create: {
     *     // ... data to create a Price
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Price we want to update
     *   }
     * })
    **/
    upsert<T extends PriceUpsertArgs>(
      args: SelectSubset<T, PriceUpsertArgs>
    ): Prisma__PriceClient<PriceGetPayload<T>>

    /**
     * Find zero or more Prices that matches the filter.
     * @param {PriceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const price = await prisma.price.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: PriceFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Price.
     * @param {PriceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const price = await prisma.price.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: PriceAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceCountArgs} args - Arguments to filter Prices to count.
     * @example
     * // Count the number of Prices
     * const count = await prisma.price.count({
     *   where: {
     *     // ... the filter for the Prices we want to count
     *   }
     * })
    **/
    count<T extends PriceCountArgs>(
      args?: Subset<T, PriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceAggregateArgs>(args: Subset<T, PriceAggregateArgs>): Prisma.PrismaPromise<GetPriceAggregateType<T>>

    /**
     * Group by Price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceGroupByArgs['orderBy'] }
        : { orderBy?: PriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Price.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PriceClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    article<T extends ArticleArgs= {}>(args?: Subset<T, ArticleArgs>): Prisma__ArticleClient<ArticleGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Price base type for findUnique actions
   */
  export type PriceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceInclude | null
    /**
     * Filter, which Price to fetch.
     */
    where: PriceWhereUniqueInput
  }

  /**
   * Price findUnique
   */
  export interface PriceFindUniqueArgs extends PriceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Price findUniqueOrThrow
   */
  export type PriceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceInclude | null
    /**
     * Filter, which Price to fetch.
     */
    where: PriceWhereUniqueInput
  }


  /**
   * Price base type for findFirst actions
   */
  export type PriceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceInclude | null
    /**
     * Filter, which Price to fetch.
     */
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: Enumerable<PriceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prices.
     */
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prices.
     */
    distinct?: Enumerable<PriceScalarFieldEnum>
  }

  /**
   * Price findFirst
   */
  export interface PriceFindFirstArgs extends PriceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Price findFirstOrThrow
   */
  export type PriceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceInclude | null
    /**
     * Filter, which Price to fetch.
     */
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: Enumerable<PriceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prices.
     */
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prices.
     */
    distinct?: Enumerable<PriceScalarFieldEnum>
  }


  /**
   * Price findMany
   */
  export type PriceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceInclude | null
    /**
     * Filter, which Prices to fetch.
     */
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: Enumerable<PriceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prices.
     */
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    distinct?: Enumerable<PriceScalarFieldEnum>
  }


  /**
   * Price create
   */
  export type PriceCreateArgs = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceInclude | null
    /**
     * The data needed to create a Price.
     */
    data: XOR<PriceCreateInput, PriceUncheckedCreateInput>
  }


  /**
   * Price createMany
   */
  export type PriceCreateManyArgs = {
    /**
     * The data used to create many Prices.
     */
    data: Enumerable<PriceCreateManyInput>
  }


  /**
   * Price update
   */
  export type PriceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceInclude | null
    /**
     * The data needed to update a Price.
     */
    data: XOR<PriceUpdateInput, PriceUncheckedUpdateInput>
    /**
     * Choose, which Price to update.
     */
    where: PriceWhereUniqueInput
  }


  /**
   * Price updateMany
   */
  export type PriceUpdateManyArgs = {
    /**
     * The data used to update Prices.
     */
    data: XOR<PriceUpdateManyMutationInput, PriceUncheckedUpdateManyInput>
    /**
     * Filter which Prices to update
     */
    where?: PriceWhereInput
  }


  /**
   * Price upsert
   */
  export type PriceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceInclude | null
    /**
     * The filter to search for the Price to update in case it exists.
     */
    where: PriceWhereUniqueInput
    /**
     * In case the Price found by the `where` argument doesn't exist, create a new Price with this data.
     */
    create: XOR<PriceCreateInput, PriceUncheckedCreateInput>
    /**
     * In case the Price was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceUpdateInput, PriceUncheckedUpdateInput>
  }


  /**
   * Price delete
   */
  export type PriceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceInclude | null
    /**
     * Filter which Price to delete.
     */
    where: PriceWhereUniqueInput
  }


  /**
   * Price deleteMany
   */
  export type PriceDeleteManyArgs = {
    /**
     * Filter which Prices to delete
     */
    where?: PriceWhereInput
  }


  /**
   * Price findRaw
   */
  export type PriceFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Price aggregateRaw
   */
  export type PriceAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Price without action
   */
  export type PriceArgs = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PriceInclude | null
  }



  /**
   * Model Order
   */


  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    status: EnumOrderStatus | null
    followedLink: string | null
    orderNumber: string | null
    shoppingCartId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    status: EnumOrderStatus | null
    followedLink: string | null
    orderNumber: string | null
    shoppingCartId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    status: number
    followedLink: number
    orderNumber: number
    shoppingCartId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderMinAggregateInputType = {
    id?: true
    status?: true
    followedLink?: true
    orderNumber?: true
    shoppingCartId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    status?: true
    followedLink?: true
    orderNumber?: true
    shoppingCartId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    status?: true
    followedLink?: true
    orderNumber?: true
    shoppingCartId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs = {
    where?: OrderWhereInput
    orderBy?: Enumerable<OrderOrderByWithAggregationInput>
    by: OrderScalarFieldEnum[]
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }


  export type OrderGroupByOutputType = {
    id: string
    status: EnumOrderStatus
    followedLink: string | null
    orderNumber: string | null
    shoppingCartId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: OrderCountAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect = {
    id?: boolean
    status?: boolean
    followedLink?: boolean
    orderNumber?: boolean
    shoppingCartId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shoppingCart?: boolean | ShoppingCartArgs
  }


  export type OrderInclude = {
    shoppingCart?: boolean | ShoppingCartArgs
  }

  export type OrderGetPayload<S extends boolean | null | undefined | OrderArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Order :
    S extends undefined ? never :
    S extends { include: any } & (OrderArgs | OrderFindManyArgs)
    ? Order  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'shoppingCart' ? ShoppingCartGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (OrderArgs | OrderFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'shoppingCart' ? ShoppingCartGetPayload<S['select'][P]> :  P extends keyof Order ? Order[P] : never
  } 
      : Order


  type OrderCountArgs = 
    Omit<OrderFindManyArgs, 'select' | 'include'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OrderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Order'> extends True ? Prisma__OrderClient<OrderGetPayload<T>> : Prisma__OrderClient<OrderGetPayload<T> | null, null>

    /**
     * Find one Order that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OrderFindUniqueOrThrowArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OrderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Order'> extends True ? Prisma__OrderClient<OrderGetPayload<T>> : Prisma__OrderClient<OrderGetPayload<T> | null, null>

    /**
     * Find the first Order that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OrderFindFirstOrThrowArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrderFindManyArgs>(
      args?: SelectSubset<T, OrderFindManyArgs>
    ): Prisma.PrismaPromise<Array<OrderGetPayload<T>>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends OrderCreateArgs>(
      args: SelectSubset<T, OrderCreateArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Create many Orders.
     *     @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrderCreateManyArgs>(
      args?: SelectSubset<T, OrderCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends OrderDeleteArgs>(
      args: SelectSubset<T, OrderDeleteArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrderUpdateArgs>(
      args: SelectSubset<T, OrderUpdateArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrderDeleteManyArgs>(
      args?: SelectSubset<T, OrderDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrderUpdateManyArgs>(
      args: SelectSubset<T, OrderUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends OrderUpsertArgs>(
      args: SelectSubset<T, OrderUpsertArgs>
    ): Prisma__OrderClient<OrderGetPayload<T>>

    /**
     * Find zero or more Orders that matches the filter.
     * @param {OrderFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const order = await prisma.order.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: OrderFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Order.
     * @param {OrderAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const order = await prisma.order.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: OrderAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OrderClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    shoppingCart<T extends ShoppingCartArgs= {}>(args?: Subset<T, ShoppingCartArgs>): Prisma__ShoppingCartClient<ShoppingCartGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Order base type for findUnique actions
   */
  export type OrderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUnique
   */
  export interface OrderFindUniqueArgs extends OrderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order base type for findFirst actions
   */
  export type OrderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: Enumerable<OrderScalarFieldEnum>
  }

  /**
   * Order findFirst
   */
  export interface OrderFindFirstArgs extends OrderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order findMany
   */
  export type OrderFindManyArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: Enumerable<OrderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: Enumerable<OrderScalarFieldEnum>
  }


  /**
   * Order create
   */
  export type OrderCreateArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }


  /**
   * Order createMany
   */
  export type OrderCreateManyArgs = {
    /**
     * The data used to create many Orders.
     */
    data: Enumerable<OrderCreateManyInput>
  }


  /**
   * Order update
   */
  export type OrderUpdateArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }


  /**
   * Order upsert
   */
  export type OrderUpsertArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }


  /**
   * Order delete
   */
  export type OrderDeleteArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }


  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }


  /**
   * Order findRaw
   */
  export type OrderFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Order aggregateRaw
   */
  export type OrderAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Order without action
   */
  export type OrderArgs = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrderInclude | null
  }



  /**
   * Model ShoppingCart
   */


  export type AggregateShoppingCart = {
    _count: ShoppingCartCountAggregateOutputType | null
    _min: ShoppingCartMinAggregateOutputType | null
    _max: ShoppingCartMaxAggregateOutputType | null
  }

  export type ShoppingCartMinAggregateOutputType = {
    id: string | null
    winningDate: Date | null
    isClaimed: boolean | null
    gameId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShoppingCartMaxAggregateOutputType = {
    id: string | null
    winningDate: Date | null
    isClaimed: boolean | null
    gameId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShoppingCartCountAggregateOutputType = {
    id: number
    winningDate: number
    isClaimed: number
    gameId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShoppingCartMinAggregateInputType = {
    id?: true
    winningDate?: true
    isClaimed?: true
    gameId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShoppingCartMaxAggregateInputType = {
    id?: true
    winningDate?: true
    isClaimed?: true
    gameId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShoppingCartCountAggregateInputType = {
    id?: true
    winningDate?: true
    isClaimed?: true
    gameId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShoppingCartAggregateArgs = {
    /**
     * Filter which ShoppingCart to aggregate.
     */
    where?: ShoppingCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingCarts to fetch.
     */
    orderBy?: Enumerable<ShoppingCartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShoppingCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingCarts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingCarts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShoppingCarts
    **/
    _count?: true | ShoppingCartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShoppingCartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShoppingCartMaxAggregateInputType
  }

  export type GetShoppingCartAggregateType<T extends ShoppingCartAggregateArgs> = {
        [P in keyof T & keyof AggregateShoppingCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShoppingCart[P]>
      : GetScalarType<T[P], AggregateShoppingCart[P]>
  }




  export type ShoppingCartGroupByArgs = {
    where?: ShoppingCartWhereInput
    orderBy?: Enumerable<ShoppingCartOrderByWithAggregationInput>
    by: ShoppingCartScalarFieldEnum[]
    having?: ShoppingCartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShoppingCartCountAggregateInputType | true
    _min?: ShoppingCartMinAggregateInputType
    _max?: ShoppingCartMaxAggregateInputType
  }


  export type ShoppingCartGroupByOutputType = {
    id: string
    winningDate: Date
    isClaimed: boolean | null
    gameId: string
    userId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: ShoppingCartCountAggregateOutputType | null
    _min: ShoppingCartMinAggregateOutputType | null
    _max: ShoppingCartMaxAggregateOutputType | null
  }

  type GetShoppingCartGroupByPayload<T extends ShoppingCartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ShoppingCartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShoppingCartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShoppingCartGroupByOutputType[P]>
            : GetScalarType<T[P], ShoppingCartGroupByOutputType[P]>
        }
      >
    >


  export type ShoppingCartSelect = {
    id?: boolean
    winningDate?: boolean
    isClaimed?: boolean
    gameId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    game?: boolean | GameArgs
    user?: boolean | UserArgs
    transaction?: boolean | ShoppingCart$transactionArgs
    order?: boolean | OrderArgs
    _count?: boolean | ShoppingCartCountOutputTypeArgs
  }


  export type ShoppingCartInclude = {
    game?: boolean | GameArgs
    user?: boolean | UserArgs
    transaction?: boolean | ShoppingCart$transactionArgs
    order?: boolean | OrderArgs
    _count?: boolean | ShoppingCartCountOutputTypeArgs
  }

  export type ShoppingCartGetPayload<S extends boolean | null | undefined | ShoppingCartArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ShoppingCart :
    S extends undefined ? never :
    S extends { include: any } & (ShoppingCartArgs | ShoppingCartFindManyArgs)
    ? ShoppingCart  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'game' ? GameGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'transaction' ? Array < TransactionGetPayload<S['include'][P]>>  :
        P extends 'order' ? OrderGetPayload<S['include'][P]> | null :
        P extends '_count' ? ShoppingCartCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ShoppingCartArgs | ShoppingCartFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'game' ? GameGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'transaction' ? Array < TransactionGetPayload<S['select'][P]>>  :
        P extends 'order' ? OrderGetPayload<S['select'][P]> | null :
        P extends '_count' ? ShoppingCartCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ShoppingCart ? ShoppingCart[P] : never
  } 
      : ShoppingCart


  type ShoppingCartCountArgs = 
    Omit<ShoppingCartFindManyArgs, 'select' | 'include'> & {
      select?: ShoppingCartCountAggregateInputType | true
    }

  export interface ShoppingCartDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ShoppingCart that matches the filter.
     * @param {ShoppingCartFindUniqueArgs} args - Arguments to find a ShoppingCart
     * @example
     * // Get one ShoppingCart
     * const shoppingCart = await prisma.shoppingCart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShoppingCartFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ShoppingCartFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ShoppingCart'> extends True ? Prisma__ShoppingCartClient<ShoppingCartGetPayload<T>> : Prisma__ShoppingCartClient<ShoppingCartGetPayload<T> | null, null>

    /**
     * Find one ShoppingCart that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ShoppingCartFindUniqueOrThrowArgs} args - Arguments to find a ShoppingCart
     * @example
     * // Get one ShoppingCart
     * const shoppingCart = await prisma.shoppingCart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ShoppingCartFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ShoppingCartFindUniqueOrThrowArgs>
    ): Prisma__ShoppingCartClient<ShoppingCartGetPayload<T>>

    /**
     * Find the first ShoppingCart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartFindFirstArgs} args - Arguments to find a ShoppingCart
     * @example
     * // Get one ShoppingCart
     * const shoppingCart = await prisma.shoppingCart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShoppingCartFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ShoppingCartFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ShoppingCart'> extends True ? Prisma__ShoppingCartClient<ShoppingCartGetPayload<T>> : Prisma__ShoppingCartClient<ShoppingCartGetPayload<T> | null, null>

    /**
     * Find the first ShoppingCart that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartFindFirstOrThrowArgs} args - Arguments to find a ShoppingCart
     * @example
     * // Get one ShoppingCart
     * const shoppingCart = await prisma.shoppingCart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ShoppingCartFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ShoppingCartFindFirstOrThrowArgs>
    ): Prisma__ShoppingCartClient<ShoppingCartGetPayload<T>>

    /**
     * Find zero or more ShoppingCarts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShoppingCarts
     * const shoppingCarts = await prisma.shoppingCart.findMany()
     * 
     * // Get first 10 ShoppingCarts
     * const shoppingCarts = await prisma.shoppingCart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shoppingCartWithIdOnly = await prisma.shoppingCart.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShoppingCartFindManyArgs>(
      args?: SelectSubset<T, ShoppingCartFindManyArgs>
    ): Prisma.PrismaPromise<Array<ShoppingCartGetPayload<T>>>

    /**
     * Create a ShoppingCart.
     * @param {ShoppingCartCreateArgs} args - Arguments to create a ShoppingCart.
     * @example
     * // Create one ShoppingCart
     * const ShoppingCart = await prisma.shoppingCart.create({
     *   data: {
     *     // ... data to create a ShoppingCart
     *   }
     * })
     * 
    **/
    create<T extends ShoppingCartCreateArgs>(
      args: SelectSubset<T, ShoppingCartCreateArgs>
    ): Prisma__ShoppingCartClient<ShoppingCartGetPayload<T>>

    /**
     * Create many ShoppingCarts.
     *     @param {ShoppingCartCreateManyArgs} args - Arguments to create many ShoppingCarts.
     *     @example
     *     // Create many ShoppingCarts
     *     const shoppingCart = await prisma.shoppingCart.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ShoppingCartCreateManyArgs>(
      args?: SelectSubset<T, ShoppingCartCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ShoppingCart.
     * @param {ShoppingCartDeleteArgs} args - Arguments to delete one ShoppingCart.
     * @example
     * // Delete one ShoppingCart
     * const ShoppingCart = await prisma.shoppingCart.delete({
     *   where: {
     *     // ... filter to delete one ShoppingCart
     *   }
     * })
     * 
    **/
    delete<T extends ShoppingCartDeleteArgs>(
      args: SelectSubset<T, ShoppingCartDeleteArgs>
    ): Prisma__ShoppingCartClient<ShoppingCartGetPayload<T>>

    /**
     * Update one ShoppingCart.
     * @param {ShoppingCartUpdateArgs} args - Arguments to update one ShoppingCart.
     * @example
     * // Update one ShoppingCart
     * const shoppingCart = await prisma.shoppingCart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShoppingCartUpdateArgs>(
      args: SelectSubset<T, ShoppingCartUpdateArgs>
    ): Prisma__ShoppingCartClient<ShoppingCartGetPayload<T>>

    /**
     * Delete zero or more ShoppingCarts.
     * @param {ShoppingCartDeleteManyArgs} args - Arguments to filter ShoppingCarts to delete.
     * @example
     * // Delete a few ShoppingCarts
     * const { count } = await prisma.shoppingCart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShoppingCartDeleteManyArgs>(
      args?: SelectSubset<T, ShoppingCartDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShoppingCarts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShoppingCarts
     * const shoppingCart = await prisma.shoppingCart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShoppingCartUpdateManyArgs>(
      args: SelectSubset<T, ShoppingCartUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShoppingCart.
     * @param {ShoppingCartUpsertArgs} args - Arguments to update or create a ShoppingCart.
     * @example
     * // Update or create a ShoppingCart
     * const shoppingCart = await prisma.shoppingCart.upsert({
     *   create: {
     *     // ... data to create a ShoppingCart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShoppingCart we want to update
     *   }
     * })
    **/
    upsert<T extends ShoppingCartUpsertArgs>(
      args: SelectSubset<T, ShoppingCartUpsertArgs>
    ): Prisma__ShoppingCartClient<ShoppingCartGetPayload<T>>

    /**
     * Find zero or more ShoppingCarts that matches the filter.
     * @param {ShoppingCartFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const shoppingCart = await prisma.shoppingCart.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ShoppingCartFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ShoppingCart.
     * @param {ShoppingCartAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const shoppingCart = await prisma.shoppingCart.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ShoppingCartAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of ShoppingCarts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartCountArgs} args - Arguments to filter ShoppingCarts to count.
     * @example
     * // Count the number of ShoppingCarts
     * const count = await prisma.shoppingCart.count({
     *   where: {
     *     // ... the filter for the ShoppingCarts we want to count
     *   }
     * })
    **/
    count<T extends ShoppingCartCountArgs>(
      args?: Subset<T, ShoppingCartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShoppingCartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShoppingCart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShoppingCartAggregateArgs>(args: Subset<T, ShoppingCartAggregateArgs>): Prisma.PrismaPromise<GetShoppingCartAggregateType<T>>

    /**
     * Group by ShoppingCart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShoppingCartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShoppingCartGroupByArgs['orderBy'] }
        : { orderBy?: ShoppingCartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShoppingCartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShoppingCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ShoppingCart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ShoppingCartClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    game<T extends GameArgs= {}>(args?: Subset<T, GameArgs>): Prisma__GameClient<GameGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    transaction<T extends ShoppingCart$transactionArgs= {}>(args?: Subset<T, ShoppingCart$transactionArgs>): Prisma.PrismaPromise<Array<TransactionGetPayload<T>>| Null>;

    order<T extends OrderArgs= {}>(args?: Subset<T, OrderArgs>): Prisma__OrderClient<OrderGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ShoppingCart base type for findUnique actions
   */
  export type ShoppingCartFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoppingCartInclude | null
    /**
     * Filter, which ShoppingCart to fetch.
     */
    where: ShoppingCartWhereUniqueInput
  }

  /**
   * ShoppingCart findUnique
   */
  export interface ShoppingCartFindUniqueArgs extends ShoppingCartFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ShoppingCart findUniqueOrThrow
   */
  export type ShoppingCartFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoppingCartInclude | null
    /**
     * Filter, which ShoppingCart to fetch.
     */
    where: ShoppingCartWhereUniqueInput
  }


  /**
   * ShoppingCart base type for findFirst actions
   */
  export type ShoppingCartFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoppingCartInclude | null
    /**
     * Filter, which ShoppingCart to fetch.
     */
    where?: ShoppingCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingCarts to fetch.
     */
    orderBy?: Enumerable<ShoppingCartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShoppingCarts.
     */
    cursor?: ShoppingCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingCarts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingCarts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShoppingCarts.
     */
    distinct?: Enumerable<ShoppingCartScalarFieldEnum>
  }

  /**
   * ShoppingCart findFirst
   */
  export interface ShoppingCartFindFirstArgs extends ShoppingCartFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ShoppingCart findFirstOrThrow
   */
  export type ShoppingCartFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoppingCartInclude | null
    /**
     * Filter, which ShoppingCart to fetch.
     */
    where?: ShoppingCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingCarts to fetch.
     */
    orderBy?: Enumerable<ShoppingCartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShoppingCarts.
     */
    cursor?: ShoppingCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingCarts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingCarts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShoppingCarts.
     */
    distinct?: Enumerable<ShoppingCartScalarFieldEnum>
  }


  /**
   * ShoppingCart findMany
   */
  export type ShoppingCartFindManyArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoppingCartInclude | null
    /**
     * Filter, which ShoppingCarts to fetch.
     */
    where?: ShoppingCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingCarts to fetch.
     */
    orderBy?: Enumerable<ShoppingCartOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShoppingCarts.
     */
    cursor?: ShoppingCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingCarts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingCarts.
     */
    skip?: number
    distinct?: Enumerable<ShoppingCartScalarFieldEnum>
  }


  /**
   * ShoppingCart create
   */
  export type ShoppingCartCreateArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoppingCartInclude | null
    /**
     * The data needed to create a ShoppingCart.
     */
    data: XOR<ShoppingCartCreateInput, ShoppingCartUncheckedCreateInput>
  }


  /**
   * ShoppingCart createMany
   */
  export type ShoppingCartCreateManyArgs = {
    /**
     * The data used to create many ShoppingCarts.
     */
    data: Enumerable<ShoppingCartCreateManyInput>
  }


  /**
   * ShoppingCart update
   */
  export type ShoppingCartUpdateArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoppingCartInclude | null
    /**
     * The data needed to update a ShoppingCart.
     */
    data: XOR<ShoppingCartUpdateInput, ShoppingCartUncheckedUpdateInput>
    /**
     * Choose, which ShoppingCart to update.
     */
    where: ShoppingCartWhereUniqueInput
  }


  /**
   * ShoppingCart updateMany
   */
  export type ShoppingCartUpdateManyArgs = {
    /**
     * The data used to update ShoppingCarts.
     */
    data: XOR<ShoppingCartUpdateManyMutationInput, ShoppingCartUncheckedUpdateManyInput>
    /**
     * Filter which ShoppingCarts to update
     */
    where?: ShoppingCartWhereInput
  }


  /**
   * ShoppingCart upsert
   */
  export type ShoppingCartUpsertArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoppingCartInclude | null
    /**
     * The filter to search for the ShoppingCart to update in case it exists.
     */
    where: ShoppingCartWhereUniqueInput
    /**
     * In case the ShoppingCart found by the `where` argument doesn't exist, create a new ShoppingCart with this data.
     */
    create: XOR<ShoppingCartCreateInput, ShoppingCartUncheckedCreateInput>
    /**
     * In case the ShoppingCart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShoppingCartUpdateInput, ShoppingCartUncheckedUpdateInput>
  }


  /**
   * ShoppingCart delete
   */
  export type ShoppingCartDeleteArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoppingCartInclude | null
    /**
     * Filter which ShoppingCart to delete.
     */
    where: ShoppingCartWhereUniqueInput
  }


  /**
   * ShoppingCart deleteMany
   */
  export type ShoppingCartDeleteManyArgs = {
    /**
     * Filter which ShoppingCarts to delete
     */
    where?: ShoppingCartWhereInput
  }


  /**
   * ShoppingCart findRaw
   */
  export type ShoppingCartFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * ShoppingCart aggregateRaw
   */
  export type ShoppingCartAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * ShoppingCart.transaction
   */
  export type ShoppingCart$transactionArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude | null
    where?: TransactionWhereInput
    orderBy?: Enumerable<TransactionOrderByWithRelationInput>
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * ShoppingCart without action
   */
  export type ShoppingCartArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
     */
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ShoppingCartInclude | null
  }



  /**
   * Model Transaction
   */


  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    type: EnumTypeTransaction | null
    date: Date | null
    amount: number | null
    status: EnumStatusTransaction | null
    boxId: string | null
    walletId: string | null
    offerId: string | null
    shoppingCartId: string | null
    bankId: string | null
    gameId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    type: EnumTypeTransaction | null
    date: Date | null
    amount: number | null
    status: EnumStatusTransaction | null
    boxId: string | null
    walletId: string | null
    offerId: string | null
    shoppingCartId: string | null
    bankId: string | null
    gameId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    type: number
    date: number
    amount: number
    status: number
    boxId: number
    walletId: number
    offerId: number
    shoppingCartId: number
    bankId: number
    gameId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    type?: true
    date?: true
    amount?: true
    status?: true
    boxId?: true
    walletId?: true
    offerId?: true
    shoppingCartId?: true
    bankId?: true
    gameId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    type?: true
    date?: true
    amount?: true
    status?: true
    boxId?: true
    walletId?: true
    offerId?: true
    shoppingCartId?: true
    bankId?: true
    gameId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    type?: true
    date?: true
    amount?: true
    status?: true
    boxId?: true
    walletId?: true
    offerId?: true
    shoppingCartId?: true
    bankId?: true
    gameId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: Enumerable<TransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs = {
    where?: TransactionWhereInput
    orderBy?: Enumerable<TransactionOrderByWithAggregationInput>
    by: TransactionScalarFieldEnum[]
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }


  export type TransactionGroupByOutputType = {
    id: string
    type: EnumTypeTransaction
    date: Date
    amount: number
    status: EnumStatusTransaction
    boxId: string | null
    walletId: string
    offerId: string | null
    shoppingCartId: string | null
    bankId: string | null
    gameId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect = {
    id?: boolean
    type?: boolean
    date?: boolean
    amount?: boolean
    status?: boolean
    boxId?: boolean
    walletId?: boolean
    offerId?: boolean
    shoppingCartId?: boolean
    bankId?: boolean
    gameId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    box?: boolean | BoxArgs
    wallet?: boolean | WalletArgs
    offer?: boolean | OfferArgs
    shoppingCart?: boolean | ShoppingCartArgs
    bank?: boolean | BankArgs
    game?: boolean | GameArgs
  }


  export type TransactionInclude = {
    box?: boolean | BoxArgs
    wallet?: boolean | WalletArgs
    offer?: boolean | OfferArgs
    shoppingCart?: boolean | ShoppingCartArgs
    bank?: boolean | BankArgs
    game?: boolean | GameArgs
  }

  export type TransactionGetPayload<S extends boolean | null | undefined | TransactionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Transaction :
    S extends undefined ? never :
    S extends { include: any } & (TransactionArgs | TransactionFindManyArgs)
    ? Transaction  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'box' ? BoxGetPayload<S['include'][P]> | null :
        P extends 'wallet' ? WalletGetPayload<S['include'][P]> :
        P extends 'offer' ? OfferGetPayload<S['include'][P]> | null :
        P extends 'shoppingCart' ? ShoppingCartGetPayload<S['include'][P]> | null :
        P extends 'bank' ? BankGetPayload<S['include'][P]> | null :
        P extends 'game' ? GameGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (TransactionArgs | TransactionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'box' ? BoxGetPayload<S['select'][P]> | null :
        P extends 'wallet' ? WalletGetPayload<S['select'][P]> :
        P extends 'offer' ? OfferGetPayload<S['select'][P]> | null :
        P extends 'shoppingCart' ? ShoppingCartGetPayload<S['select'][P]> | null :
        P extends 'bank' ? BankGetPayload<S['select'][P]> | null :
        P extends 'game' ? GameGetPayload<S['select'][P]> | null :  P extends keyof Transaction ? Transaction[P] : never
  } 
      : Transaction


  type TransactionCountArgs = 
    Omit<TransactionFindManyArgs, 'select' | 'include'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TransactionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TransactionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Transaction'> extends True ? Prisma__TransactionClient<TransactionGetPayload<T>> : Prisma__TransactionClient<TransactionGetPayload<T> | null, null>

    /**
     * Find one Transaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TransactionFindUniqueOrThrowArgs>
    ): Prisma__TransactionClient<TransactionGetPayload<T>>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TransactionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TransactionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Transaction'> extends True ? Prisma__TransactionClient<TransactionGetPayload<T>> : Prisma__TransactionClient<TransactionGetPayload<T> | null, null>

    /**
     * Find the first Transaction that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TransactionFindFirstOrThrowArgs>
    ): Prisma__TransactionClient<TransactionGetPayload<T>>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TransactionFindManyArgs>(
      args?: SelectSubset<T, TransactionFindManyArgs>
    ): Prisma.PrismaPromise<Array<TransactionGetPayload<T>>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
    **/
    create<T extends TransactionCreateArgs>(
      args: SelectSubset<T, TransactionCreateArgs>
    ): Prisma__TransactionClient<TransactionGetPayload<T>>

    /**
     * Create many Transactions.
     *     @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     *     @example
     *     // Create many Transactions
     *     const transaction = await prisma.transaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TransactionCreateManyArgs>(
      args?: SelectSubset<T, TransactionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
    **/
    delete<T extends TransactionDeleteArgs>(
      args: SelectSubset<T, TransactionDeleteArgs>
    ): Prisma__TransactionClient<TransactionGetPayload<T>>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TransactionUpdateArgs>(
      args: SelectSubset<T, TransactionUpdateArgs>
    ): Prisma__TransactionClient<TransactionGetPayload<T>>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TransactionDeleteManyArgs>(
      args?: SelectSubset<T, TransactionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TransactionUpdateManyArgs>(
      args: SelectSubset<T, TransactionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
    **/
    upsert<T extends TransactionUpsertArgs>(
      args: SelectSubset<T, TransactionUpsertArgs>
    ): Prisma__TransactionClient<TransactionGetPayload<T>>

    /**
     * Find zero or more Transactions that matches the filter.
     * @param {TransactionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const transaction = await prisma.transaction.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TransactionFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Transaction.
     * @param {TransactionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const transaction = await prisma.transaction.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TransactionAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TransactionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    box<T extends BoxArgs= {}>(args?: Subset<T, BoxArgs>): Prisma__BoxClient<BoxGetPayload<T> | Null>;

    wallet<T extends WalletArgs= {}>(args?: Subset<T, WalletArgs>): Prisma__WalletClient<WalletGetPayload<T> | Null>;

    offer<T extends OfferArgs= {}>(args?: Subset<T, OfferArgs>): Prisma__OfferClient<OfferGetPayload<T> | Null>;

    shoppingCart<T extends ShoppingCartArgs= {}>(args?: Subset<T, ShoppingCartArgs>): Prisma__ShoppingCartClient<ShoppingCartGetPayload<T> | Null>;

    bank<T extends BankArgs= {}>(args?: Subset<T, BankArgs>): Prisma__BankClient<BankGetPayload<T> | Null>;

    game<T extends GameArgs= {}>(args?: Subset<T, GameArgs>): Prisma__GameClient<GameGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Transaction base type for findUnique actions
   */
  export type TransactionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUnique
   */
  export interface TransactionFindUniqueArgs extends TransactionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction base type for findFirst actions
   */
  export type TransactionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: Enumerable<TransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }

  /**
   * Transaction findFirst
   */
  export interface TransactionFindFirstArgs extends TransactionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: Enumerable<TransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: Enumerable<TransactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * Transaction create
   */
  export type TransactionCreateArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }


  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs = {
    /**
     * The data used to create many Transactions.
     */
    data: Enumerable<TransactionCreateManyInput>
  }


  /**
   * Transaction update
   */
  export type TransactionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }


  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }


  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }


  /**
   * Transaction findRaw
   */
  export type TransactionFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Transaction aggregateRaw
   */
  export type TransactionAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Transaction without action
   */
  export type TransactionArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude | null
  }



  /**
   * Model Bank
   */


  export type AggregateBank = {
    _count: BankCountAggregateOutputType | null
    _min: BankMinAggregateOutputType | null
    _max: BankMaxAggregateOutputType | null
  }

  export type BankMinAggregateOutputType = {
    id: string | null
    accountNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankMaxAggregateOutputType = {
    id: string | null
    accountNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankCountAggregateOutputType = {
    id: number
    accountNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankMinAggregateInputType = {
    id?: true
    accountNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankMaxAggregateInputType = {
    id?: true
    accountNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankCountAggregateInputType = {
    id?: true
    accountNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankAggregateArgs = {
    /**
     * Filter which Bank to aggregate.
     */
    where?: BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banks to fetch.
     */
    orderBy?: Enumerable<BankOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Banks
    **/
    _count?: true | BankCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankMaxAggregateInputType
  }

  export type GetBankAggregateType<T extends BankAggregateArgs> = {
        [P in keyof T & keyof AggregateBank]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBank[P]>
      : GetScalarType<T[P], AggregateBank[P]>
  }




  export type BankGroupByArgs = {
    where?: BankWhereInput
    orderBy?: Enumerable<BankOrderByWithAggregationInput>
    by: BankScalarFieldEnum[]
    having?: BankScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankCountAggregateInputType | true
    _min?: BankMinAggregateInputType
    _max?: BankMaxAggregateInputType
  }


  export type BankGroupByOutputType = {
    id: string
    accountNumber: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: BankCountAggregateOutputType | null
    _min: BankMinAggregateOutputType | null
    _max: BankMaxAggregateOutputType | null
  }

  type GetBankGroupByPayload<T extends BankGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BankGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankGroupByOutputType[P]>
            : GetScalarType<T[P], BankGroupByOutputType[P]>
        }
      >
    >


  export type BankSelect = {
    id?: boolean
    accountNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | Bank$transactionArgs
    _count?: boolean | BankCountOutputTypeArgs
  }


  export type BankInclude = {
    transaction?: boolean | Bank$transactionArgs
    _count?: boolean | BankCountOutputTypeArgs
  }

  export type BankGetPayload<S extends boolean | null | undefined | BankArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Bank :
    S extends undefined ? never :
    S extends { include: any } & (BankArgs | BankFindManyArgs)
    ? Bank  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'transaction' ? Array < TransactionGetPayload<S['include'][P]>>  :
        P extends '_count' ? BankCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (BankArgs | BankFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'transaction' ? Array < TransactionGetPayload<S['select'][P]>>  :
        P extends '_count' ? BankCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Bank ? Bank[P] : never
  } 
      : Bank


  type BankCountArgs = 
    Omit<BankFindManyArgs, 'select' | 'include'> & {
      select?: BankCountAggregateInputType | true
    }

  export interface BankDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Bank that matches the filter.
     * @param {BankFindUniqueArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BankFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BankFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Bank'> extends True ? Prisma__BankClient<BankGetPayload<T>> : Prisma__BankClient<BankGetPayload<T> | null, null>

    /**
     * Find one Bank that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BankFindUniqueOrThrowArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BankFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BankFindUniqueOrThrowArgs>
    ): Prisma__BankClient<BankGetPayload<T>>

    /**
     * Find the first Bank that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFindFirstArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BankFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BankFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Bank'> extends True ? Prisma__BankClient<BankGetPayload<T>> : Prisma__BankClient<BankGetPayload<T> | null, null>

    /**
     * Find the first Bank that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFindFirstOrThrowArgs} args - Arguments to find a Bank
     * @example
     * // Get one Bank
     * const bank = await prisma.bank.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BankFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BankFindFirstOrThrowArgs>
    ): Prisma__BankClient<BankGetPayload<T>>

    /**
     * Find zero or more Banks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banks
     * const banks = await prisma.bank.findMany()
     * 
     * // Get first 10 Banks
     * const banks = await prisma.bank.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankWithIdOnly = await prisma.bank.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BankFindManyArgs>(
      args?: SelectSubset<T, BankFindManyArgs>
    ): Prisma.PrismaPromise<Array<BankGetPayload<T>>>

    /**
     * Create a Bank.
     * @param {BankCreateArgs} args - Arguments to create a Bank.
     * @example
     * // Create one Bank
     * const Bank = await prisma.bank.create({
     *   data: {
     *     // ... data to create a Bank
     *   }
     * })
     * 
    **/
    create<T extends BankCreateArgs>(
      args: SelectSubset<T, BankCreateArgs>
    ): Prisma__BankClient<BankGetPayload<T>>

    /**
     * Create many Banks.
     *     @param {BankCreateManyArgs} args - Arguments to create many Banks.
     *     @example
     *     // Create many Banks
     *     const bank = await prisma.bank.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BankCreateManyArgs>(
      args?: SelectSubset<T, BankCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bank.
     * @param {BankDeleteArgs} args - Arguments to delete one Bank.
     * @example
     * // Delete one Bank
     * const Bank = await prisma.bank.delete({
     *   where: {
     *     // ... filter to delete one Bank
     *   }
     * })
     * 
    **/
    delete<T extends BankDeleteArgs>(
      args: SelectSubset<T, BankDeleteArgs>
    ): Prisma__BankClient<BankGetPayload<T>>

    /**
     * Update one Bank.
     * @param {BankUpdateArgs} args - Arguments to update one Bank.
     * @example
     * // Update one Bank
     * const bank = await prisma.bank.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BankUpdateArgs>(
      args: SelectSubset<T, BankUpdateArgs>
    ): Prisma__BankClient<BankGetPayload<T>>

    /**
     * Delete zero or more Banks.
     * @param {BankDeleteManyArgs} args - Arguments to filter Banks to delete.
     * @example
     * // Delete a few Banks
     * const { count } = await prisma.bank.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BankDeleteManyArgs>(
      args?: SelectSubset<T, BankDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banks
     * const bank = await prisma.bank.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BankUpdateManyArgs>(
      args: SelectSubset<T, BankUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bank.
     * @param {BankUpsertArgs} args - Arguments to update or create a Bank.
     * @example
     * // Update or create a Bank
     * const bank = await prisma.bank.upsert({
     *   create: {
     *     // ... data to create a Bank
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bank we want to update
     *   }
     * })
    **/
    upsert<T extends BankUpsertArgs>(
      args: SelectSubset<T, BankUpsertArgs>
    ): Prisma__BankClient<BankGetPayload<T>>

    /**
     * Find zero or more Banks that matches the filter.
     * @param {BankFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const bank = await prisma.bank.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: BankFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Bank.
     * @param {BankAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const bank = await prisma.bank.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: BankAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Banks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankCountArgs} args - Arguments to filter Banks to count.
     * @example
     * // Count the number of Banks
     * const count = await prisma.bank.count({
     *   where: {
     *     // ... the filter for the Banks we want to count
     *   }
     * })
    **/
    count<T extends BankCountArgs>(
      args?: Subset<T, BankCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankAggregateArgs>(args: Subset<T, BankAggregateArgs>): Prisma.PrismaPromise<GetBankAggregateType<T>>

    /**
     * Group by Bank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankGroupByArgs['orderBy'] }
        : { orderBy?: BankGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Bank.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BankClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    transaction<T extends Bank$transactionArgs= {}>(args?: Subset<T, Bank$transactionArgs>): Prisma.PrismaPromise<Array<TransactionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Bank base type for findUnique actions
   */
  export type BankFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankInclude | null
    /**
     * Filter, which Bank to fetch.
     */
    where: BankWhereUniqueInput
  }

  /**
   * Bank findUnique
   */
  export interface BankFindUniqueArgs extends BankFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Bank findUniqueOrThrow
   */
  export type BankFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankInclude | null
    /**
     * Filter, which Bank to fetch.
     */
    where: BankWhereUniqueInput
  }


  /**
   * Bank base type for findFirst actions
   */
  export type BankFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankInclude | null
    /**
     * Filter, which Bank to fetch.
     */
    where?: BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banks to fetch.
     */
    orderBy?: Enumerable<BankOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banks.
     */
    cursor?: BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banks.
     */
    distinct?: Enumerable<BankScalarFieldEnum>
  }

  /**
   * Bank findFirst
   */
  export interface BankFindFirstArgs extends BankFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Bank findFirstOrThrow
   */
  export type BankFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankInclude | null
    /**
     * Filter, which Bank to fetch.
     */
    where?: BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banks to fetch.
     */
    orderBy?: Enumerable<BankOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Banks.
     */
    cursor?: BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Banks.
     */
    distinct?: Enumerable<BankScalarFieldEnum>
  }


  /**
   * Bank findMany
   */
  export type BankFindManyArgs = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankInclude | null
    /**
     * Filter, which Banks to fetch.
     */
    where?: BankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Banks to fetch.
     */
    orderBy?: Enumerable<BankOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Banks.
     */
    cursor?: BankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Banks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Banks.
     */
    skip?: number
    distinct?: Enumerable<BankScalarFieldEnum>
  }


  /**
   * Bank create
   */
  export type BankCreateArgs = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankInclude | null
    /**
     * The data needed to create a Bank.
     */
    data: XOR<BankCreateInput, BankUncheckedCreateInput>
  }


  /**
   * Bank createMany
   */
  export type BankCreateManyArgs = {
    /**
     * The data used to create many Banks.
     */
    data: Enumerable<BankCreateManyInput>
  }


  /**
   * Bank update
   */
  export type BankUpdateArgs = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankInclude | null
    /**
     * The data needed to update a Bank.
     */
    data: XOR<BankUpdateInput, BankUncheckedUpdateInput>
    /**
     * Choose, which Bank to update.
     */
    where: BankWhereUniqueInput
  }


  /**
   * Bank updateMany
   */
  export type BankUpdateManyArgs = {
    /**
     * The data used to update Banks.
     */
    data: XOR<BankUpdateManyMutationInput, BankUncheckedUpdateManyInput>
    /**
     * Filter which Banks to update
     */
    where?: BankWhereInput
  }


  /**
   * Bank upsert
   */
  export type BankUpsertArgs = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankInclude | null
    /**
     * The filter to search for the Bank to update in case it exists.
     */
    where: BankWhereUniqueInput
    /**
     * In case the Bank found by the `where` argument doesn't exist, create a new Bank with this data.
     */
    create: XOR<BankCreateInput, BankUncheckedCreateInput>
    /**
     * In case the Bank was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankUpdateInput, BankUncheckedUpdateInput>
  }


  /**
   * Bank delete
   */
  export type BankDeleteArgs = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankInclude | null
    /**
     * Filter which Bank to delete.
     */
    where: BankWhereUniqueInput
  }


  /**
   * Bank deleteMany
   */
  export type BankDeleteManyArgs = {
    /**
     * Filter which Banks to delete
     */
    where?: BankWhereInput
  }


  /**
   * Bank findRaw
   */
  export type BankFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Bank aggregateRaw
   */
  export type BankAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Bank.transaction
   */
  export type Bank$transactionArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude | null
    where?: TransactionWhereInput
    orderBy?: Enumerable<TransactionOrderByWithRelationInput>
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * Bank without action
   */
  export type BankArgs = {
    /**
     * Select specific fields to fetch from the Bank
     */
    select?: BankSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BankInclude | null
  }



  /**
   * Model UserBox
   */


  export type AggregateUserBox = {
    _count: UserBoxCountAggregateOutputType | null
    _avg: UserBoxAvgAggregateOutputType | null
    _sum: UserBoxSumAggregateOutputType | null
    _min: UserBoxMinAggregateOutputType | null
    _max: UserBoxMaxAggregateOutputType | null
  }

  export type UserBoxAvgAggregateOutputType = {
    dayNumber: number | null
    orderNumber: number | null
    unlockThreshold: number | null
    lot: number | null
  }

  export type UserBoxSumAggregateOutputType = {
    dayNumber: number | null
    orderNumber: number | null
    unlockThreshold: number | null
    lot: number | null
  }

  export type UserBoxMinAggregateOutputType = {
    id: string | null
    type: EnumUserBoxType | null
    duration: Date | null
    dayNumber: number | null
    isPlayed: boolean | null
    isLocked: boolean | null
    playedDate: Date | null
    activationDate: Date | null
    deactivationDate: Date | null
    orderNumber: number | null
    name: string | null
    unlockThreshold: number | null
    description: string | null
    userId: string | null
    boxId: string | null
    lot: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserBoxMaxAggregateOutputType = {
    id: string | null
    type: EnumUserBoxType | null
    duration: Date | null
    dayNumber: number | null
    isPlayed: boolean | null
    isLocked: boolean | null
    playedDate: Date | null
    activationDate: Date | null
    deactivationDate: Date | null
    orderNumber: number | null
    name: string | null
    unlockThreshold: number | null
    description: string | null
    userId: string | null
    boxId: string | null
    lot: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserBoxCountAggregateOutputType = {
    id: number
    type: number
    duration: number
    dayNumber: number
    isPlayed: number
    isLocked: number
    playedDate: number
    activationDate: number
    deactivationDate: number
    orderNumber: number
    name: number
    unlockThreshold: number
    description: number
    userId: number
    boxId: number
    lot: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserBoxAvgAggregateInputType = {
    dayNumber?: true
    orderNumber?: true
    unlockThreshold?: true
    lot?: true
  }

  export type UserBoxSumAggregateInputType = {
    dayNumber?: true
    orderNumber?: true
    unlockThreshold?: true
    lot?: true
  }

  export type UserBoxMinAggregateInputType = {
    id?: true
    type?: true
    duration?: true
    dayNumber?: true
    isPlayed?: true
    isLocked?: true
    playedDate?: true
    activationDate?: true
    deactivationDate?: true
    orderNumber?: true
    name?: true
    unlockThreshold?: true
    description?: true
    userId?: true
    boxId?: true
    lot?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserBoxMaxAggregateInputType = {
    id?: true
    type?: true
    duration?: true
    dayNumber?: true
    isPlayed?: true
    isLocked?: true
    playedDate?: true
    activationDate?: true
    deactivationDate?: true
    orderNumber?: true
    name?: true
    unlockThreshold?: true
    description?: true
    userId?: true
    boxId?: true
    lot?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserBoxCountAggregateInputType = {
    id?: true
    type?: true
    duration?: true
    dayNumber?: true
    isPlayed?: true
    isLocked?: true
    playedDate?: true
    activationDate?: true
    deactivationDate?: true
    orderNumber?: true
    name?: true
    unlockThreshold?: true
    description?: true
    userId?: true
    boxId?: true
    lot?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserBoxAggregateArgs = {
    /**
     * Filter which UserBox to aggregate.
     */
    where?: UserBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBoxes to fetch.
     */
    orderBy?: Enumerable<UserBoxOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBoxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBoxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBoxes
    **/
    _count?: true | UserBoxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserBoxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserBoxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBoxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBoxMaxAggregateInputType
  }

  export type GetUserBoxAggregateType<T extends UserBoxAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBox]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBox[P]>
      : GetScalarType<T[P], AggregateUserBox[P]>
  }




  export type UserBoxGroupByArgs = {
    where?: UserBoxWhereInput
    orderBy?: Enumerable<UserBoxOrderByWithAggregationInput>
    by: UserBoxScalarFieldEnum[]
    having?: UserBoxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBoxCountAggregateInputType | true
    _avg?: UserBoxAvgAggregateInputType
    _sum?: UserBoxSumAggregateInputType
    _min?: UserBoxMinAggregateInputType
    _max?: UserBoxMaxAggregateInputType
  }


  export type UserBoxGroupByOutputType = {
    id: string
    type: EnumUserBoxType
    duration: Date | null
    dayNumber: number | null
    isPlayed: boolean | null
    isLocked: boolean | null
    playedDate: Date | null
    activationDate: Date | null
    deactivationDate: Date | null
    orderNumber: number | null
    name: string | null
    unlockThreshold: number | null
    description: string | null
    userId: string
    boxId: string
    lot: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: UserBoxCountAggregateOutputType | null
    _avg: UserBoxAvgAggregateOutputType | null
    _sum: UserBoxSumAggregateOutputType | null
    _min: UserBoxMinAggregateOutputType | null
    _max: UserBoxMaxAggregateOutputType | null
  }

  type GetUserBoxGroupByPayload<T extends UserBoxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserBoxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBoxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBoxGroupByOutputType[P]>
            : GetScalarType<T[P], UserBoxGroupByOutputType[P]>
        }
      >
    >


  export type UserBoxSelect = {
    id?: boolean
    type?: boolean
    duration?: boolean
    dayNumber?: boolean
    isPlayed?: boolean
    isLocked?: boolean
    playedDate?: boolean
    activationDate?: boolean
    deactivationDate?: boolean
    orderNumber?: boolean
    name?: boolean
    unlockThreshold?: boolean
    description?: boolean
    userId?: boolean
    boxId?: boolean
    lot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
    box?: boolean | BoxArgs
    game?: boolean | UserBox$gameArgs
    _count?: boolean | UserBoxCountOutputTypeArgs
  }


  export type UserBoxInclude = {
    user?: boolean | UserArgs
    box?: boolean | BoxArgs
    game?: boolean | UserBox$gameArgs
    _count?: boolean | UserBoxCountOutputTypeArgs
  }

  export type UserBoxGetPayload<S extends boolean | null | undefined | UserBoxArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserBox :
    S extends undefined ? never :
    S extends { include: any } & (UserBoxArgs | UserBoxFindManyArgs)
    ? UserBox  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'box' ? BoxGetPayload<S['include'][P]> :
        P extends 'game' ? Array < GameGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserBoxCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserBoxArgs | UserBoxFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'box' ? BoxGetPayload<S['select'][P]> :
        P extends 'game' ? Array < GameGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserBoxCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof UserBox ? UserBox[P] : never
  } 
      : UserBox


  type UserBoxCountArgs = 
    Omit<UserBoxFindManyArgs, 'select' | 'include'> & {
      select?: UserBoxCountAggregateInputType | true
    }

  export interface UserBoxDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserBox that matches the filter.
     * @param {UserBoxFindUniqueArgs} args - Arguments to find a UserBox
     * @example
     * // Get one UserBox
     * const userBox = await prisma.userBox.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserBoxFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserBoxFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserBox'> extends True ? Prisma__UserBoxClient<UserBoxGetPayload<T>> : Prisma__UserBoxClient<UserBoxGetPayload<T> | null, null>

    /**
     * Find one UserBox that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserBoxFindUniqueOrThrowArgs} args - Arguments to find a UserBox
     * @example
     * // Get one UserBox
     * const userBox = await prisma.userBox.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserBoxFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserBoxFindUniqueOrThrowArgs>
    ): Prisma__UserBoxClient<UserBoxGetPayload<T>>

    /**
     * Find the first UserBox that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBoxFindFirstArgs} args - Arguments to find a UserBox
     * @example
     * // Get one UserBox
     * const userBox = await prisma.userBox.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserBoxFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserBoxFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserBox'> extends True ? Prisma__UserBoxClient<UserBoxGetPayload<T>> : Prisma__UserBoxClient<UserBoxGetPayload<T> | null, null>

    /**
     * Find the first UserBox that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBoxFindFirstOrThrowArgs} args - Arguments to find a UserBox
     * @example
     * // Get one UserBox
     * const userBox = await prisma.userBox.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserBoxFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserBoxFindFirstOrThrowArgs>
    ): Prisma__UserBoxClient<UserBoxGetPayload<T>>

    /**
     * Find zero or more UserBoxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBoxFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBoxes
     * const userBoxes = await prisma.userBox.findMany()
     * 
     * // Get first 10 UserBoxes
     * const userBoxes = await prisma.userBox.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBoxWithIdOnly = await prisma.userBox.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserBoxFindManyArgs>(
      args?: SelectSubset<T, UserBoxFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserBoxGetPayload<T>>>

    /**
     * Create a UserBox.
     * @param {UserBoxCreateArgs} args - Arguments to create a UserBox.
     * @example
     * // Create one UserBox
     * const UserBox = await prisma.userBox.create({
     *   data: {
     *     // ... data to create a UserBox
     *   }
     * })
     * 
    **/
    create<T extends UserBoxCreateArgs>(
      args: SelectSubset<T, UserBoxCreateArgs>
    ): Prisma__UserBoxClient<UserBoxGetPayload<T>>

    /**
     * Create many UserBoxes.
     *     @param {UserBoxCreateManyArgs} args - Arguments to create many UserBoxes.
     *     @example
     *     // Create many UserBoxes
     *     const userBox = await prisma.userBox.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserBoxCreateManyArgs>(
      args?: SelectSubset<T, UserBoxCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserBox.
     * @param {UserBoxDeleteArgs} args - Arguments to delete one UserBox.
     * @example
     * // Delete one UserBox
     * const UserBox = await prisma.userBox.delete({
     *   where: {
     *     // ... filter to delete one UserBox
     *   }
     * })
     * 
    **/
    delete<T extends UserBoxDeleteArgs>(
      args: SelectSubset<T, UserBoxDeleteArgs>
    ): Prisma__UserBoxClient<UserBoxGetPayload<T>>

    /**
     * Update one UserBox.
     * @param {UserBoxUpdateArgs} args - Arguments to update one UserBox.
     * @example
     * // Update one UserBox
     * const userBox = await prisma.userBox.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserBoxUpdateArgs>(
      args: SelectSubset<T, UserBoxUpdateArgs>
    ): Prisma__UserBoxClient<UserBoxGetPayload<T>>

    /**
     * Delete zero or more UserBoxes.
     * @param {UserBoxDeleteManyArgs} args - Arguments to filter UserBoxes to delete.
     * @example
     * // Delete a few UserBoxes
     * const { count } = await prisma.userBox.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserBoxDeleteManyArgs>(
      args?: SelectSubset<T, UserBoxDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBoxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBoxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBoxes
     * const userBox = await prisma.userBox.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserBoxUpdateManyArgs>(
      args: SelectSubset<T, UserBoxUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserBox.
     * @param {UserBoxUpsertArgs} args - Arguments to update or create a UserBox.
     * @example
     * // Update or create a UserBox
     * const userBox = await prisma.userBox.upsert({
     *   create: {
     *     // ... data to create a UserBox
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBox we want to update
     *   }
     * })
    **/
    upsert<T extends UserBoxUpsertArgs>(
      args: SelectSubset<T, UserBoxUpsertArgs>
    ): Prisma__UserBoxClient<UserBoxGetPayload<T>>

    /**
     * Find zero or more UserBoxes that matches the filter.
     * @param {UserBoxFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userBox = await prisma.userBox.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: UserBoxFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserBox.
     * @param {UserBoxAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userBox = await prisma.userBox.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: UserBoxAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of UserBoxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBoxCountArgs} args - Arguments to filter UserBoxes to count.
     * @example
     * // Count the number of UserBoxes
     * const count = await prisma.userBox.count({
     *   where: {
     *     // ... the filter for the UserBoxes we want to count
     *   }
     * })
    **/
    count<T extends UserBoxCountArgs>(
      args?: Subset<T, UserBoxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBoxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBoxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBoxAggregateArgs>(args: Subset<T, UserBoxAggregateArgs>): Prisma.PrismaPromise<GetUserBoxAggregateType<T>>

    /**
     * Group by UserBox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBoxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBoxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBoxGroupByArgs['orderBy'] }
        : { orderBy?: UserBoxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBoxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBoxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBox.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserBoxClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    box<T extends BoxArgs= {}>(args?: Subset<T, BoxArgs>): Prisma__BoxClient<BoxGetPayload<T> | Null>;

    game<T extends UserBox$gameArgs= {}>(args?: Subset<T, UserBox$gameArgs>): Prisma.PrismaPromise<Array<GameGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserBox base type for findUnique actions
   */
  export type UserBoxFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserBox
     */
    select?: UserBoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBoxInclude | null
    /**
     * Filter, which UserBox to fetch.
     */
    where: UserBoxWhereUniqueInput
  }

  /**
   * UserBox findUnique
   */
  export interface UserBoxFindUniqueArgs extends UserBoxFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserBox findUniqueOrThrow
   */
  export type UserBoxFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserBox
     */
    select?: UserBoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBoxInclude | null
    /**
     * Filter, which UserBox to fetch.
     */
    where: UserBoxWhereUniqueInput
  }


  /**
   * UserBox base type for findFirst actions
   */
  export type UserBoxFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserBox
     */
    select?: UserBoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBoxInclude | null
    /**
     * Filter, which UserBox to fetch.
     */
    where?: UserBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBoxes to fetch.
     */
    orderBy?: Enumerable<UserBoxOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBoxes.
     */
    cursor?: UserBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBoxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBoxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBoxes.
     */
    distinct?: Enumerable<UserBoxScalarFieldEnum>
  }

  /**
   * UserBox findFirst
   */
  export interface UserBoxFindFirstArgs extends UserBoxFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserBox findFirstOrThrow
   */
  export type UserBoxFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserBox
     */
    select?: UserBoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBoxInclude | null
    /**
     * Filter, which UserBox to fetch.
     */
    where?: UserBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBoxes to fetch.
     */
    orderBy?: Enumerable<UserBoxOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBoxes.
     */
    cursor?: UserBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBoxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBoxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBoxes.
     */
    distinct?: Enumerable<UserBoxScalarFieldEnum>
  }


  /**
   * UserBox findMany
   */
  export type UserBoxFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserBox
     */
    select?: UserBoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBoxInclude | null
    /**
     * Filter, which UserBoxes to fetch.
     */
    where?: UserBoxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBoxes to fetch.
     */
    orderBy?: Enumerable<UserBoxOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBoxes.
     */
    cursor?: UserBoxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBoxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBoxes.
     */
    skip?: number
    distinct?: Enumerable<UserBoxScalarFieldEnum>
  }


  /**
   * UserBox create
   */
  export type UserBoxCreateArgs = {
    /**
     * Select specific fields to fetch from the UserBox
     */
    select?: UserBoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBoxInclude | null
    /**
     * The data needed to create a UserBox.
     */
    data: XOR<UserBoxCreateInput, UserBoxUncheckedCreateInput>
  }


  /**
   * UserBox createMany
   */
  export type UserBoxCreateManyArgs = {
    /**
     * The data used to create many UserBoxes.
     */
    data: Enumerable<UserBoxCreateManyInput>
  }


  /**
   * UserBox update
   */
  export type UserBoxUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserBox
     */
    select?: UserBoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBoxInclude | null
    /**
     * The data needed to update a UserBox.
     */
    data: XOR<UserBoxUpdateInput, UserBoxUncheckedUpdateInput>
    /**
     * Choose, which UserBox to update.
     */
    where: UserBoxWhereUniqueInput
  }


  /**
   * UserBox updateMany
   */
  export type UserBoxUpdateManyArgs = {
    /**
     * The data used to update UserBoxes.
     */
    data: XOR<UserBoxUpdateManyMutationInput, UserBoxUncheckedUpdateManyInput>
    /**
     * Filter which UserBoxes to update
     */
    where?: UserBoxWhereInput
  }


  /**
   * UserBox upsert
   */
  export type UserBoxUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserBox
     */
    select?: UserBoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBoxInclude | null
    /**
     * The filter to search for the UserBox to update in case it exists.
     */
    where: UserBoxWhereUniqueInput
    /**
     * In case the UserBox found by the `where` argument doesn't exist, create a new UserBox with this data.
     */
    create: XOR<UserBoxCreateInput, UserBoxUncheckedCreateInput>
    /**
     * In case the UserBox was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBoxUpdateInput, UserBoxUncheckedUpdateInput>
  }


  /**
   * UserBox delete
   */
  export type UserBoxDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserBox
     */
    select?: UserBoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBoxInclude | null
    /**
     * Filter which UserBox to delete.
     */
    where: UserBoxWhereUniqueInput
  }


  /**
   * UserBox deleteMany
   */
  export type UserBoxDeleteManyArgs = {
    /**
     * Filter which UserBoxes to delete
     */
    where?: UserBoxWhereInput
  }


  /**
   * UserBox findRaw
   */
  export type UserBoxFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * UserBox aggregateRaw
   */
  export type UserBoxAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * UserBox.game
   */
  export type UserBox$gameArgs = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude | null
    where?: GameWhereInput
    orderBy?: Enumerable<GameOrderByWithRelationInput>
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<GameScalarFieldEnum>
  }


  /**
   * UserBox without action
   */
  export type UserBoxArgs = {
    /**
     * Select specific fields to fetch from the UserBox
     */
    select?: UserBoxSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserBoxInclude | null
  }



  /**
   * Model BannerImage
   */


  export type AggregateBannerImage = {
    _count: BannerImageCountAggregateOutputType | null
    _min: BannerImageMinAggregateOutputType | null
    _max: BannerImageMaxAggregateOutputType | null
  }

  export type BannerImageMinAggregateOutputType = {
    id: string | null
    bannerImgUrl: string | null
    bannerLink: string | null
    type: BannerImageType | null
    boxId: string | null
    offerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannerImageMaxAggregateOutputType = {
    id: string | null
    bannerImgUrl: string | null
    bannerLink: string | null
    type: BannerImageType | null
    boxId: string | null
    offerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BannerImageCountAggregateOutputType = {
    id: number
    bannerImgUrl: number
    bannerLink: number
    type: number
    boxId: number
    offerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BannerImageMinAggregateInputType = {
    id?: true
    bannerImgUrl?: true
    bannerLink?: true
    type?: true
    boxId?: true
    offerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannerImageMaxAggregateInputType = {
    id?: true
    bannerImgUrl?: true
    bannerLink?: true
    type?: true
    boxId?: true
    offerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BannerImageCountAggregateInputType = {
    id?: true
    bannerImgUrl?: true
    bannerLink?: true
    type?: true
    boxId?: true
    offerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BannerImageAggregateArgs = {
    /**
     * Filter which BannerImage to aggregate.
     */
    where?: BannerImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerImages to fetch.
     */
    orderBy?: Enumerable<BannerImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BannerImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BannerImages
    **/
    _count?: true | BannerImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerImageMaxAggregateInputType
  }

  export type GetBannerImageAggregateType<T extends BannerImageAggregateArgs> = {
        [P in keyof T & keyof AggregateBannerImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBannerImage[P]>
      : GetScalarType<T[P], AggregateBannerImage[P]>
  }




  export type BannerImageGroupByArgs = {
    where?: BannerImageWhereInput
    orderBy?: Enumerable<BannerImageOrderByWithAggregationInput>
    by: BannerImageScalarFieldEnum[]
    having?: BannerImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerImageCountAggregateInputType | true
    _min?: BannerImageMinAggregateInputType
    _max?: BannerImageMaxAggregateInputType
  }


  export type BannerImageGroupByOutputType = {
    id: string
    bannerImgUrl: string
    bannerLink: string | null
    type: BannerImageType | null
    boxId: string | null
    offerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: BannerImageCountAggregateOutputType | null
    _min: BannerImageMinAggregateOutputType | null
    _max: BannerImageMaxAggregateOutputType | null
  }

  type GetBannerImageGroupByPayload<T extends BannerImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BannerImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerImageGroupByOutputType[P]>
            : GetScalarType<T[P], BannerImageGroupByOutputType[P]>
        }
      >
    >


  export type BannerImageSelect = {
    id?: boolean
    bannerImgUrl?: boolean
    bannerLink?: boolean
    type?: boolean
    boxId?: boolean
    offerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    box?: boolean | BoxArgs
    offer?: boolean | OfferArgs
  }


  export type BannerImageInclude = {
    box?: boolean | BoxArgs
    offer?: boolean | OfferArgs
  }

  export type BannerImageGetPayload<S extends boolean | null | undefined | BannerImageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BannerImage :
    S extends undefined ? never :
    S extends { include: any } & (BannerImageArgs | BannerImageFindManyArgs)
    ? BannerImage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'box' ? BoxGetPayload<S['include'][P]> | null :
        P extends 'offer' ? OfferGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (BannerImageArgs | BannerImageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'box' ? BoxGetPayload<S['select'][P]> | null :
        P extends 'offer' ? OfferGetPayload<S['select'][P]> | null :  P extends keyof BannerImage ? BannerImage[P] : never
  } 
      : BannerImage


  type BannerImageCountArgs = 
    Omit<BannerImageFindManyArgs, 'select' | 'include'> & {
      select?: BannerImageCountAggregateInputType | true
    }

  export interface BannerImageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BannerImage that matches the filter.
     * @param {BannerImageFindUniqueArgs} args - Arguments to find a BannerImage
     * @example
     * // Get one BannerImage
     * const bannerImage = await prisma.bannerImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BannerImageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BannerImageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BannerImage'> extends True ? Prisma__BannerImageClient<BannerImageGetPayload<T>> : Prisma__BannerImageClient<BannerImageGetPayload<T> | null, null>

    /**
     * Find one BannerImage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BannerImageFindUniqueOrThrowArgs} args - Arguments to find a BannerImage
     * @example
     * // Get one BannerImage
     * const bannerImage = await prisma.bannerImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BannerImageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BannerImageFindUniqueOrThrowArgs>
    ): Prisma__BannerImageClient<BannerImageGetPayload<T>>

    /**
     * Find the first BannerImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerImageFindFirstArgs} args - Arguments to find a BannerImage
     * @example
     * // Get one BannerImage
     * const bannerImage = await prisma.bannerImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BannerImageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BannerImageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BannerImage'> extends True ? Prisma__BannerImageClient<BannerImageGetPayload<T>> : Prisma__BannerImageClient<BannerImageGetPayload<T> | null, null>

    /**
     * Find the first BannerImage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerImageFindFirstOrThrowArgs} args - Arguments to find a BannerImage
     * @example
     * // Get one BannerImage
     * const bannerImage = await prisma.bannerImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BannerImageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BannerImageFindFirstOrThrowArgs>
    ): Prisma__BannerImageClient<BannerImageGetPayload<T>>

    /**
     * Find zero or more BannerImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BannerImages
     * const bannerImages = await prisma.bannerImage.findMany()
     * 
     * // Get first 10 BannerImages
     * const bannerImages = await prisma.bannerImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerImageWithIdOnly = await prisma.bannerImage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BannerImageFindManyArgs>(
      args?: SelectSubset<T, BannerImageFindManyArgs>
    ): Prisma.PrismaPromise<Array<BannerImageGetPayload<T>>>

    /**
     * Create a BannerImage.
     * @param {BannerImageCreateArgs} args - Arguments to create a BannerImage.
     * @example
     * // Create one BannerImage
     * const BannerImage = await prisma.bannerImage.create({
     *   data: {
     *     // ... data to create a BannerImage
     *   }
     * })
     * 
    **/
    create<T extends BannerImageCreateArgs>(
      args: SelectSubset<T, BannerImageCreateArgs>
    ): Prisma__BannerImageClient<BannerImageGetPayload<T>>

    /**
     * Create many BannerImages.
     *     @param {BannerImageCreateManyArgs} args - Arguments to create many BannerImages.
     *     @example
     *     // Create many BannerImages
     *     const bannerImage = await prisma.bannerImage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BannerImageCreateManyArgs>(
      args?: SelectSubset<T, BannerImageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BannerImage.
     * @param {BannerImageDeleteArgs} args - Arguments to delete one BannerImage.
     * @example
     * // Delete one BannerImage
     * const BannerImage = await prisma.bannerImage.delete({
     *   where: {
     *     // ... filter to delete one BannerImage
     *   }
     * })
     * 
    **/
    delete<T extends BannerImageDeleteArgs>(
      args: SelectSubset<T, BannerImageDeleteArgs>
    ): Prisma__BannerImageClient<BannerImageGetPayload<T>>

    /**
     * Update one BannerImage.
     * @param {BannerImageUpdateArgs} args - Arguments to update one BannerImage.
     * @example
     * // Update one BannerImage
     * const bannerImage = await prisma.bannerImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BannerImageUpdateArgs>(
      args: SelectSubset<T, BannerImageUpdateArgs>
    ): Prisma__BannerImageClient<BannerImageGetPayload<T>>

    /**
     * Delete zero or more BannerImages.
     * @param {BannerImageDeleteManyArgs} args - Arguments to filter BannerImages to delete.
     * @example
     * // Delete a few BannerImages
     * const { count } = await prisma.bannerImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BannerImageDeleteManyArgs>(
      args?: SelectSubset<T, BannerImageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BannerImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BannerImages
     * const bannerImage = await prisma.bannerImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BannerImageUpdateManyArgs>(
      args: SelectSubset<T, BannerImageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BannerImage.
     * @param {BannerImageUpsertArgs} args - Arguments to update or create a BannerImage.
     * @example
     * // Update or create a BannerImage
     * const bannerImage = await prisma.bannerImage.upsert({
     *   create: {
     *     // ... data to create a BannerImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BannerImage we want to update
     *   }
     * })
    **/
    upsert<T extends BannerImageUpsertArgs>(
      args: SelectSubset<T, BannerImageUpsertArgs>
    ): Prisma__BannerImageClient<BannerImageGetPayload<T>>

    /**
     * Find zero or more BannerImages that matches the filter.
     * @param {BannerImageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const bannerImage = await prisma.bannerImage.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: BannerImageFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a BannerImage.
     * @param {BannerImageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const bannerImage = await prisma.bannerImage.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: BannerImageAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of BannerImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerImageCountArgs} args - Arguments to filter BannerImages to count.
     * @example
     * // Count the number of BannerImages
     * const count = await prisma.bannerImage.count({
     *   where: {
     *     // ... the filter for the BannerImages we want to count
     *   }
     * })
    **/
    count<T extends BannerImageCountArgs>(
      args?: Subset<T, BannerImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BannerImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerImageAggregateArgs>(args: Subset<T, BannerImageAggregateArgs>): Prisma.PrismaPromise<GetBannerImageAggregateType<T>>

    /**
     * Group by BannerImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BannerImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BannerImageGroupByArgs['orderBy'] }
        : { orderBy?: BannerImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BannerImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BannerImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BannerImageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    box<T extends BoxArgs= {}>(args?: Subset<T, BoxArgs>): Prisma__BoxClient<BoxGetPayload<T> | Null>;

    offer<T extends OfferArgs= {}>(args?: Subset<T, OfferArgs>): Prisma__OfferClient<OfferGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BannerImage base type for findUnique actions
   */
  export type BannerImageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BannerImage
     */
    select?: BannerImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannerImageInclude | null
    /**
     * Filter, which BannerImage to fetch.
     */
    where: BannerImageWhereUniqueInput
  }

  /**
   * BannerImage findUnique
   */
  export interface BannerImageFindUniqueArgs extends BannerImageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BannerImage findUniqueOrThrow
   */
  export type BannerImageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BannerImage
     */
    select?: BannerImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannerImageInclude | null
    /**
     * Filter, which BannerImage to fetch.
     */
    where: BannerImageWhereUniqueInput
  }


  /**
   * BannerImage base type for findFirst actions
   */
  export type BannerImageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BannerImage
     */
    select?: BannerImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannerImageInclude | null
    /**
     * Filter, which BannerImage to fetch.
     */
    where?: BannerImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerImages to fetch.
     */
    orderBy?: Enumerable<BannerImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannerImages.
     */
    cursor?: BannerImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannerImages.
     */
    distinct?: Enumerable<BannerImageScalarFieldEnum>
  }

  /**
   * BannerImage findFirst
   */
  export interface BannerImageFindFirstArgs extends BannerImageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BannerImage findFirstOrThrow
   */
  export type BannerImageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BannerImage
     */
    select?: BannerImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannerImageInclude | null
    /**
     * Filter, which BannerImage to fetch.
     */
    where?: BannerImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerImages to fetch.
     */
    orderBy?: Enumerable<BannerImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BannerImages.
     */
    cursor?: BannerImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BannerImages.
     */
    distinct?: Enumerable<BannerImageScalarFieldEnum>
  }


  /**
   * BannerImage findMany
   */
  export type BannerImageFindManyArgs = {
    /**
     * Select specific fields to fetch from the BannerImage
     */
    select?: BannerImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannerImageInclude | null
    /**
     * Filter, which BannerImages to fetch.
     */
    where?: BannerImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BannerImages to fetch.
     */
    orderBy?: Enumerable<BannerImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BannerImages.
     */
    cursor?: BannerImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BannerImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BannerImages.
     */
    skip?: number
    distinct?: Enumerable<BannerImageScalarFieldEnum>
  }


  /**
   * BannerImage create
   */
  export type BannerImageCreateArgs = {
    /**
     * Select specific fields to fetch from the BannerImage
     */
    select?: BannerImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannerImageInclude | null
    /**
     * The data needed to create a BannerImage.
     */
    data: XOR<BannerImageCreateInput, BannerImageUncheckedCreateInput>
  }


  /**
   * BannerImage createMany
   */
  export type BannerImageCreateManyArgs = {
    /**
     * The data used to create many BannerImages.
     */
    data: Enumerable<BannerImageCreateManyInput>
  }


  /**
   * BannerImage update
   */
  export type BannerImageUpdateArgs = {
    /**
     * Select specific fields to fetch from the BannerImage
     */
    select?: BannerImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannerImageInclude | null
    /**
     * The data needed to update a BannerImage.
     */
    data: XOR<BannerImageUpdateInput, BannerImageUncheckedUpdateInput>
    /**
     * Choose, which BannerImage to update.
     */
    where: BannerImageWhereUniqueInput
  }


  /**
   * BannerImage updateMany
   */
  export type BannerImageUpdateManyArgs = {
    /**
     * The data used to update BannerImages.
     */
    data: XOR<BannerImageUpdateManyMutationInput, BannerImageUncheckedUpdateManyInput>
    /**
     * Filter which BannerImages to update
     */
    where?: BannerImageWhereInput
  }


  /**
   * BannerImage upsert
   */
  export type BannerImageUpsertArgs = {
    /**
     * Select specific fields to fetch from the BannerImage
     */
    select?: BannerImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannerImageInclude | null
    /**
     * The filter to search for the BannerImage to update in case it exists.
     */
    where: BannerImageWhereUniqueInput
    /**
     * In case the BannerImage found by the `where` argument doesn't exist, create a new BannerImage with this data.
     */
    create: XOR<BannerImageCreateInput, BannerImageUncheckedCreateInput>
    /**
     * In case the BannerImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BannerImageUpdateInput, BannerImageUncheckedUpdateInput>
  }


  /**
   * BannerImage delete
   */
  export type BannerImageDeleteArgs = {
    /**
     * Select specific fields to fetch from the BannerImage
     */
    select?: BannerImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannerImageInclude | null
    /**
     * Filter which BannerImage to delete.
     */
    where: BannerImageWhereUniqueInput
  }


  /**
   * BannerImage deleteMany
   */
  export type BannerImageDeleteManyArgs = {
    /**
     * Filter which BannerImages to delete
     */
    where?: BannerImageWhereInput
  }


  /**
   * BannerImage findRaw
   */
  export type BannerImageFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * BannerImage aggregateRaw
   */
  export type BannerImageAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * BannerImage without action
   */
  export type BannerImageArgs = {
    /**
     * Select specific fields to fetch from the BannerImage
     */
    select?: BannerImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannerImageInclude | null
  }



  /**
   * Model BoxParams
   */


  export type AggregateBoxParams = {
    _count: BoxParamsCountAggregateOutputType | null
    _min: BoxParamsMinAggregateOutputType | null
    _max: BoxParamsMaxAggregateOutputType | null
  }

  export type BoxParamsMinAggregateOutputType = {
    id: string | null
    isBestSelling: boolean | null
    isRecommended: boolean | null
    isNew: boolean | null
    isBigPrice: boolean | null
    isSubsciptionBonus: boolean | null
    boxId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BoxParamsMaxAggregateOutputType = {
    id: string | null
    isBestSelling: boolean | null
    isRecommended: boolean | null
    isNew: boolean | null
    isBigPrice: boolean | null
    isSubsciptionBonus: boolean | null
    boxId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BoxParamsCountAggregateOutputType = {
    id: number
    isBestSelling: number
    isRecommended: number
    isNew: number
    isBigPrice: number
    isSubsciptionBonus: number
    boxId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BoxParamsMinAggregateInputType = {
    id?: true
    isBestSelling?: true
    isRecommended?: true
    isNew?: true
    isBigPrice?: true
    isSubsciptionBonus?: true
    boxId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BoxParamsMaxAggregateInputType = {
    id?: true
    isBestSelling?: true
    isRecommended?: true
    isNew?: true
    isBigPrice?: true
    isSubsciptionBonus?: true
    boxId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BoxParamsCountAggregateInputType = {
    id?: true
    isBestSelling?: true
    isRecommended?: true
    isNew?: true
    isBigPrice?: true
    isSubsciptionBonus?: true
    boxId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BoxParamsAggregateArgs = {
    /**
     * Filter which BoxParams to aggregate.
     */
    where?: BoxParamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoxParams to fetch.
     */
    orderBy?: Enumerable<BoxParamsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoxParamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoxParams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoxParams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoxParams
    **/
    _count?: true | BoxParamsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoxParamsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoxParamsMaxAggregateInputType
  }

  export type GetBoxParamsAggregateType<T extends BoxParamsAggregateArgs> = {
        [P in keyof T & keyof AggregateBoxParams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoxParams[P]>
      : GetScalarType<T[P], AggregateBoxParams[P]>
  }




  export type BoxParamsGroupByArgs = {
    where?: BoxParamsWhereInput
    orderBy?: Enumerable<BoxParamsOrderByWithAggregationInput>
    by: BoxParamsScalarFieldEnum[]
    having?: BoxParamsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoxParamsCountAggregateInputType | true
    _min?: BoxParamsMinAggregateInputType
    _max?: BoxParamsMaxAggregateInputType
  }


  export type BoxParamsGroupByOutputType = {
    id: string
    isBestSelling: boolean
    isRecommended: boolean
    isNew: boolean
    isBigPrice: boolean
    isSubsciptionBonus: boolean
    boxId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: BoxParamsCountAggregateOutputType | null
    _min: BoxParamsMinAggregateOutputType | null
    _max: BoxParamsMaxAggregateOutputType | null
  }

  type GetBoxParamsGroupByPayload<T extends BoxParamsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BoxParamsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoxParamsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoxParamsGroupByOutputType[P]>
            : GetScalarType<T[P], BoxParamsGroupByOutputType[P]>
        }
      >
    >


  export type BoxParamsSelect = {
    id?: boolean
    isBestSelling?: boolean
    isRecommended?: boolean
    isNew?: boolean
    isBigPrice?: boolean
    isSubsciptionBonus?: boolean
    boxId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    box?: boolean | BoxArgs
  }


  export type BoxParamsInclude = {
    box?: boolean | BoxArgs
  }

  export type BoxParamsGetPayload<S extends boolean | null | undefined | BoxParamsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BoxParams :
    S extends undefined ? never :
    S extends { include: any } & (BoxParamsArgs | BoxParamsFindManyArgs)
    ? BoxParams  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'box' ? BoxGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (BoxParamsArgs | BoxParamsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'box' ? BoxGetPayload<S['select'][P]> | null :  P extends keyof BoxParams ? BoxParams[P] : never
  } 
      : BoxParams


  type BoxParamsCountArgs = 
    Omit<BoxParamsFindManyArgs, 'select' | 'include'> & {
      select?: BoxParamsCountAggregateInputType | true
    }

  export interface BoxParamsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BoxParams that matches the filter.
     * @param {BoxParamsFindUniqueArgs} args - Arguments to find a BoxParams
     * @example
     * // Get one BoxParams
     * const boxParams = await prisma.boxParams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BoxParamsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BoxParamsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BoxParams'> extends True ? Prisma__BoxParamsClient<BoxParamsGetPayload<T>> : Prisma__BoxParamsClient<BoxParamsGetPayload<T> | null, null>

    /**
     * Find one BoxParams that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BoxParamsFindUniqueOrThrowArgs} args - Arguments to find a BoxParams
     * @example
     * // Get one BoxParams
     * const boxParams = await prisma.boxParams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BoxParamsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, BoxParamsFindUniqueOrThrowArgs>
    ): Prisma__BoxParamsClient<BoxParamsGetPayload<T>>

    /**
     * Find the first BoxParams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxParamsFindFirstArgs} args - Arguments to find a BoxParams
     * @example
     * // Get one BoxParams
     * const boxParams = await prisma.boxParams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BoxParamsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BoxParamsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BoxParams'> extends True ? Prisma__BoxParamsClient<BoxParamsGetPayload<T>> : Prisma__BoxParamsClient<BoxParamsGetPayload<T> | null, null>

    /**
     * Find the first BoxParams that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxParamsFindFirstOrThrowArgs} args - Arguments to find a BoxParams
     * @example
     * // Get one BoxParams
     * const boxParams = await prisma.boxParams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BoxParamsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BoxParamsFindFirstOrThrowArgs>
    ): Prisma__BoxParamsClient<BoxParamsGetPayload<T>>

    /**
     * Find zero or more BoxParams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxParamsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoxParams
     * const boxParams = await prisma.boxParams.findMany()
     * 
     * // Get first 10 BoxParams
     * const boxParams = await prisma.boxParams.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boxParamsWithIdOnly = await prisma.boxParams.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BoxParamsFindManyArgs>(
      args?: SelectSubset<T, BoxParamsFindManyArgs>
    ): Prisma.PrismaPromise<Array<BoxParamsGetPayload<T>>>

    /**
     * Create a BoxParams.
     * @param {BoxParamsCreateArgs} args - Arguments to create a BoxParams.
     * @example
     * // Create one BoxParams
     * const BoxParams = await prisma.boxParams.create({
     *   data: {
     *     // ... data to create a BoxParams
     *   }
     * })
     * 
    **/
    create<T extends BoxParamsCreateArgs>(
      args: SelectSubset<T, BoxParamsCreateArgs>
    ): Prisma__BoxParamsClient<BoxParamsGetPayload<T>>

    /**
     * Create many BoxParams.
     *     @param {BoxParamsCreateManyArgs} args - Arguments to create many BoxParams.
     *     @example
     *     // Create many BoxParams
     *     const boxParams = await prisma.boxParams.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BoxParamsCreateManyArgs>(
      args?: SelectSubset<T, BoxParamsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BoxParams.
     * @param {BoxParamsDeleteArgs} args - Arguments to delete one BoxParams.
     * @example
     * // Delete one BoxParams
     * const BoxParams = await prisma.boxParams.delete({
     *   where: {
     *     // ... filter to delete one BoxParams
     *   }
     * })
     * 
    **/
    delete<T extends BoxParamsDeleteArgs>(
      args: SelectSubset<T, BoxParamsDeleteArgs>
    ): Prisma__BoxParamsClient<BoxParamsGetPayload<T>>

    /**
     * Update one BoxParams.
     * @param {BoxParamsUpdateArgs} args - Arguments to update one BoxParams.
     * @example
     * // Update one BoxParams
     * const boxParams = await prisma.boxParams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BoxParamsUpdateArgs>(
      args: SelectSubset<T, BoxParamsUpdateArgs>
    ): Prisma__BoxParamsClient<BoxParamsGetPayload<T>>

    /**
     * Delete zero or more BoxParams.
     * @param {BoxParamsDeleteManyArgs} args - Arguments to filter BoxParams to delete.
     * @example
     * // Delete a few BoxParams
     * const { count } = await prisma.boxParams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BoxParamsDeleteManyArgs>(
      args?: SelectSubset<T, BoxParamsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoxParams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxParamsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoxParams
     * const boxParams = await prisma.boxParams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BoxParamsUpdateManyArgs>(
      args: SelectSubset<T, BoxParamsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BoxParams.
     * @param {BoxParamsUpsertArgs} args - Arguments to update or create a BoxParams.
     * @example
     * // Update or create a BoxParams
     * const boxParams = await prisma.boxParams.upsert({
     *   create: {
     *     // ... data to create a BoxParams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoxParams we want to update
     *   }
     * })
    **/
    upsert<T extends BoxParamsUpsertArgs>(
      args: SelectSubset<T, BoxParamsUpsertArgs>
    ): Prisma__BoxParamsClient<BoxParamsGetPayload<T>>

    /**
     * Find zero or more BoxParams that matches the filter.
     * @param {BoxParamsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const boxParams = await prisma.boxParams.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: BoxParamsFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a BoxParams.
     * @param {BoxParamsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const boxParams = await prisma.boxParams.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: BoxParamsAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of BoxParams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxParamsCountArgs} args - Arguments to filter BoxParams to count.
     * @example
     * // Count the number of BoxParams
     * const count = await prisma.boxParams.count({
     *   where: {
     *     // ... the filter for the BoxParams we want to count
     *   }
     * })
    **/
    count<T extends BoxParamsCountArgs>(
      args?: Subset<T, BoxParamsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoxParamsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoxParams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxParamsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoxParamsAggregateArgs>(args: Subset<T, BoxParamsAggregateArgs>): Prisma.PrismaPromise<GetBoxParamsAggregateType<T>>

    /**
     * Group by BoxParams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoxParamsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoxParamsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoxParamsGroupByArgs['orderBy'] }
        : { orderBy?: BoxParamsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoxParamsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoxParamsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BoxParams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BoxParamsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    box<T extends BoxArgs= {}>(args?: Subset<T, BoxArgs>): Prisma__BoxClient<BoxGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BoxParams base type for findUnique actions
   */
  export type BoxParamsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the BoxParams
     */
    select?: BoxParamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxParamsInclude | null
    /**
     * Filter, which BoxParams to fetch.
     */
    where: BoxParamsWhereUniqueInput
  }

  /**
   * BoxParams findUnique
   */
  export interface BoxParamsFindUniqueArgs extends BoxParamsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoxParams findUniqueOrThrow
   */
  export type BoxParamsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoxParams
     */
    select?: BoxParamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxParamsInclude | null
    /**
     * Filter, which BoxParams to fetch.
     */
    where: BoxParamsWhereUniqueInput
  }


  /**
   * BoxParams base type for findFirst actions
   */
  export type BoxParamsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the BoxParams
     */
    select?: BoxParamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxParamsInclude | null
    /**
     * Filter, which BoxParams to fetch.
     */
    where?: BoxParamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoxParams to fetch.
     */
    orderBy?: Enumerable<BoxParamsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoxParams.
     */
    cursor?: BoxParamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoxParams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoxParams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoxParams.
     */
    distinct?: Enumerable<BoxParamsScalarFieldEnum>
  }

  /**
   * BoxParams findFirst
   */
  export interface BoxParamsFindFirstArgs extends BoxParamsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoxParams findFirstOrThrow
   */
  export type BoxParamsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the BoxParams
     */
    select?: BoxParamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxParamsInclude | null
    /**
     * Filter, which BoxParams to fetch.
     */
    where?: BoxParamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoxParams to fetch.
     */
    orderBy?: Enumerable<BoxParamsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoxParams.
     */
    cursor?: BoxParamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoxParams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoxParams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoxParams.
     */
    distinct?: Enumerable<BoxParamsScalarFieldEnum>
  }


  /**
   * BoxParams findMany
   */
  export type BoxParamsFindManyArgs = {
    /**
     * Select specific fields to fetch from the BoxParams
     */
    select?: BoxParamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxParamsInclude | null
    /**
     * Filter, which BoxParams to fetch.
     */
    where?: BoxParamsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoxParams to fetch.
     */
    orderBy?: Enumerable<BoxParamsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoxParams.
     */
    cursor?: BoxParamsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoxParams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoxParams.
     */
    skip?: number
    distinct?: Enumerable<BoxParamsScalarFieldEnum>
  }


  /**
   * BoxParams create
   */
  export type BoxParamsCreateArgs = {
    /**
     * Select specific fields to fetch from the BoxParams
     */
    select?: BoxParamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxParamsInclude | null
    /**
     * The data needed to create a BoxParams.
     */
    data: XOR<BoxParamsCreateInput, BoxParamsUncheckedCreateInput>
  }


  /**
   * BoxParams createMany
   */
  export type BoxParamsCreateManyArgs = {
    /**
     * The data used to create many BoxParams.
     */
    data: Enumerable<BoxParamsCreateManyInput>
  }


  /**
   * BoxParams update
   */
  export type BoxParamsUpdateArgs = {
    /**
     * Select specific fields to fetch from the BoxParams
     */
    select?: BoxParamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxParamsInclude | null
    /**
     * The data needed to update a BoxParams.
     */
    data: XOR<BoxParamsUpdateInput, BoxParamsUncheckedUpdateInput>
    /**
     * Choose, which BoxParams to update.
     */
    where: BoxParamsWhereUniqueInput
  }


  /**
   * BoxParams updateMany
   */
  export type BoxParamsUpdateManyArgs = {
    /**
     * The data used to update BoxParams.
     */
    data: XOR<BoxParamsUpdateManyMutationInput, BoxParamsUncheckedUpdateManyInput>
    /**
     * Filter which BoxParams to update
     */
    where?: BoxParamsWhereInput
  }


  /**
   * BoxParams upsert
   */
  export type BoxParamsUpsertArgs = {
    /**
     * Select specific fields to fetch from the BoxParams
     */
    select?: BoxParamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxParamsInclude | null
    /**
     * The filter to search for the BoxParams to update in case it exists.
     */
    where: BoxParamsWhereUniqueInput
    /**
     * In case the BoxParams found by the `where` argument doesn't exist, create a new BoxParams with this data.
     */
    create: XOR<BoxParamsCreateInput, BoxParamsUncheckedCreateInput>
    /**
     * In case the BoxParams was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoxParamsUpdateInput, BoxParamsUncheckedUpdateInput>
  }


  /**
   * BoxParams delete
   */
  export type BoxParamsDeleteArgs = {
    /**
     * Select specific fields to fetch from the BoxParams
     */
    select?: BoxParamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxParamsInclude | null
    /**
     * Filter which BoxParams to delete.
     */
    where: BoxParamsWhereUniqueInput
  }


  /**
   * BoxParams deleteMany
   */
  export type BoxParamsDeleteManyArgs = {
    /**
     * Filter which BoxParams to delete
     */
    where?: BoxParamsWhereInput
  }


  /**
   * BoxParams findRaw
   */
  export type BoxParamsFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * BoxParams aggregateRaw
   */
  export type BoxParamsAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * BoxParams without action
   */
  export type BoxParamsArgs = {
    /**
     * Select specific fields to fetch from the BoxParams
     */
    select?: BoxParamsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoxParamsInclude | null
  }



  /**
   * Model Historical
   */


  export type AggregateHistorical = {
    _count: HistoricalCountAggregateOutputType | null
    _min: HistoricalMinAggregateOutputType | null
    _max: HistoricalMaxAggregateOutputType | null
  }

  export type HistoricalMinAggregateOutputType = {
    id: string | null
    date: Date | null
    description: string | null
    userId: string | null
    action: EnumHistoricalAction | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HistoricalMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    description: string | null
    userId: string | null
    action: EnumHistoricalAction | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HistoricalCountAggregateOutputType = {
    id: number
    date: number
    description: number
    userId: number
    action: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HistoricalMinAggregateInputType = {
    id?: true
    date?: true
    description?: true
    userId?: true
    action?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HistoricalMaxAggregateInputType = {
    id?: true
    date?: true
    description?: true
    userId?: true
    action?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HistoricalCountAggregateInputType = {
    id?: true
    date?: true
    description?: true
    userId?: true
    action?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HistoricalAggregateArgs = {
    /**
     * Filter which Historical to aggregate.
     */
    where?: HistoricalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Historicals to fetch.
     */
    orderBy?: Enumerable<HistoricalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HistoricalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Historicals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Historicals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Historicals
    **/
    _count?: true | HistoricalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistoricalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistoricalMaxAggregateInputType
  }

  export type GetHistoricalAggregateType<T extends HistoricalAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorical]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorical[P]>
      : GetScalarType<T[P], AggregateHistorical[P]>
  }




  export type HistoricalGroupByArgs = {
    where?: HistoricalWhereInput
    orderBy?: Enumerable<HistoricalOrderByWithAggregationInput>
    by: HistoricalScalarFieldEnum[]
    having?: HistoricalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistoricalCountAggregateInputType | true
    _min?: HistoricalMinAggregateInputType
    _max?: HistoricalMaxAggregateInputType
  }


  export type HistoricalGroupByOutputType = {
    id: string
    date: Date
    description: string
    userId: string
    action: EnumHistoricalAction
    createdAt: Date | null
    updatedAt: Date | null
    _count: HistoricalCountAggregateOutputType | null
    _min: HistoricalMinAggregateOutputType | null
    _max: HistoricalMaxAggregateOutputType | null
  }

  type GetHistoricalGroupByPayload<T extends HistoricalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HistoricalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistoricalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistoricalGroupByOutputType[P]>
            : GetScalarType<T[P], HistoricalGroupByOutputType[P]>
        }
      >
    >


  export type HistoricalSelect = {
    id?: boolean
    date?: boolean
    description?: boolean
    userId?: boolean
    action?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
  }


  export type HistoricalInclude = {
    user?: boolean | UserArgs
  }

  export type HistoricalGetPayload<S extends boolean | null | undefined | HistoricalArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Historical :
    S extends undefined ? never :
    S extends { include: any } & (HistoricalArgs | HistoricalFindManyArgs)
    ? Historical  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (HistoricalArgs | HistoricalFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Historical ? Historical[P] : never
  } 
      : Historical


  type HistoricalCountArgs = 
    Omit<HistoricalFindManyArgs, 'select' | 'include'> & {
      select?: HistoricalCountAggregateInputType | true
    }

  export interface HistoricalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Historical that matches the filter.
     * @param {HistoricalFindUniqueArgs} args - Arguments to find a Historical
     * @example
     * // Get one Historical
     * const historical = await prisma.historical.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HistoricalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HistoricalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Historical'> extends True ? Prisma__HistoricalClient<HistoricalGetPayload<T>> : Prisma__HistoricalClient<HistoricalGetPayload<T> | null, null>

    /**
     * Find one Historical that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HistoricalFindUniqueOrThrowArgs} args - Arguments to find a Historical
     * @example
     * // Get one Historical
     * const historical = await prisma.historical.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HistoricalFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HistoricalFindUniqueOrThrowArgs>
    ): Prisma__HistoricalClient<HistoricalGetPayload<T>>

    /**
     * Find the first Historical that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricalFindFirstArgs} args - Arguments to find a Historical
     * @example
     * // Get one Historical
     * const historical = await prisma.historical.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HistoricalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HistoricalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Historical'> extends True ? Prisma__HistoricalClient<HistoricalGetPayload<T>> : Prisma__HistoricalClient<HistoricalGetPayload<T> | null, null>

    /**
     * Find the first Historical that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricalFindFirstOrThrowArgs} args - Arguments to find a Historical
     * @example
     * // Get one Historical
     * const historical = await prisma.historical.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HistoricalFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HistoricalFindFirstOrThrowArgs>
    ): Prisma__HistoricalClient<HistoricalGetPayload<T>>

    /**
     * Find zero or more Historicals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Historicals
     * const historicals = await prisma.historical.findMany()
     * 
     * // Get first 10 Historicals
     * const historicals = await prisma.historical.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historicalWithIdOnly = await prisma.historical.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HistoricalFindManyArgs>(
      args?: SelectSubset<T, HistoricalFindManyArgs>
    ): Prisma.PrismaPromise<Array<HistoricalGetPayload<T>>>

    /**
     * Create a Historical.
     * @param {HistoricalCreateArgs} args - Arguments to create a Historical.
     * @example
     * // Create one Historical
     * const Historical = await prisma.historical.create({
     *   data: {
     *     // ... data to create a Historical
     *   }
     * })
     * 
    **/
    create<T extends HistoricalCreateArgs>(
      args: SelectSubset<T, HistoricalCreateArgs>
    ): Prisma__HistoricalClient<HistoricalGetPayload<T>>

    /**
     * Create many Historicals.
     *     @param {HistoricalCreateManyArgs} args - Arguments to create many Historicals.
     *     @example
     *     // Create many Historicals
     *     const historical = await prisma.historical.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HistoricalCreateManyArgs>(
      args?: SelectSubset<T, HistoricalCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Historical.
     * @param {HistoricalDeleteArgs} args - Arguments to delete one Historical.
     * @example
     * // Delete one Historical
     * const Historical = await prisma.historical.delete({
     *   where: {
     *     // ... filter to delete one Historical
     *   }
     * })
     * 
    **/
    delete<T extends HistoricalDeleteArgs>(
      args: SelectSubset<T, HistoricalDeleteArgs>
    ): Prisma__HistoricalClient<HistoricalGetPayload<T>>

    /**
     * Update one Historical.
     * @param {HistoricalUpdateArgs} args - Arguments to update one Historical.
     * @example
     * // Update one Historical
     * const historical = await prisma.historical.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HistoricalUpdateArgs>(
      args: SelectSubset<T, HistoricalUpdateArgs>
    ): Prisma__HistoricalClient<HistoricalGetPayload<T>>

    /**
     * Delete zero or more Historicals.
     * @param {HistoricalDeleteManyArgs} args - Arguments to filter Historicals to delete.
     * @example
     * // Delete a few Historicals
     * const { count } = await prisma.historical.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HistoricalDeleteManyArgs>(
      args?: SelectSubset<T, HistoricalDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Historicals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Historicals
     * const historical = await prisma.historical.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HistoricalUpdateManyArgs>(
      args: SelectSubset<T, HistoricalUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Historical.
     * @param {HistoricalUpsertArgs} args - Arguments to update or create a Historical.
     * @example
     * // Update or create a Historical
     * const historical = await prisma.historical.upsert({
     *   create: {
     *     // ... data to create a Historical
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Historical we want to update
     *   }
     * })
    **/
    upsert<T extends HistoricalUpsertArgs>(
      args: SelectSubset<T, HistoricalUpsertArgs>
    ): Prisma__HistoricalClient<HistoricalGetPayload<T>>

    /**
     * Find zero or more Historicals that matches the filter.
     * @param {HistoricalFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const historical = await prisma.historical.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: HistoricalFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Historical.
     * @param {HistoricalAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const historical = await prisma.historical.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: HistoricalAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Historicals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricalCountArgs} args - Arguments to filter Historicals to count.
     * @example
     * // Count the number of Historicals
     * const count = await prisma.historical.count({
     *   where: {
     *     // ... the filter for the Historicals we want to count
     *   }
     * })
    **/
    count<T extends HistoricalCountArgs>(
      args?: Subset<T, HistoricalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistoricalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Historical.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistoricalAggregateArgs>(args: Subset<T, HistoricalAggregateArgs>): Prisma.PrismaPromise<GetHistoricalAggregateType<T>>

    /**
     * Group by Historical.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoricalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HistoricalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HistoricalGroupByArgs['orderBy'] }
        : { orderBy?: HistoricalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HistoricalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistoricalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Historical.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HistoricalClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Historical base type for findUnique actions
   */
  export type HistoricalFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Historical
     */
    select?: HistoricalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoricalInclude | null
    /**
     * Filter, which Historical to fetch.
     */
    where: HistoricalWhereUniqueInput
  }

  /**
   * Historical findUnique
   */
  export interface HistoricalFindUniqueArgs extends HistoricalFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Historical findUniqueOrThrow
   */
  export type HistoricalFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Historical
     */
    select?: HistoricalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoricalInclude | null
    /**
     * Filter, which Historical to fetch.
     */
    where: HistoricalWhereUniqueInput
  }


  /**
   * Historical base type for findFirst actions
   */
  export type HistoricalFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Historical
     */
    select?: HistoricalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoricalInclude | null
    /**
     * Filter, which Historical to fetch.
     */
    where?: HistoricalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Historicals to fetch.
     */
    orderBy?: Enumerable<HistoricalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Historicals.
     */
    cursor?: HistoricalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Historicals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Historicals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Historicals.
     */
    distinct?: Enumerable<HistoricalScalarFieldEnum>
  }

  /**
   * Historical findFirst
   */
  export interface HistoricalFindFirstArgs extends HistoricalFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Historical findFirstOrThrow
   */
  export type HistoricalFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Historical
     */
    select?: HistoricalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoricalInclude | null
    /**
     * Filter, which Historical to fetch.
     */
    where?: HistoricalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Historicals to fetch.
     */
    orderBy?: Enumerable<HistoricalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Historicals.
     */
    cursor?: HistoricalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Historicals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Historicals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Historicals.
     */
    distinct?: Enumerable<HistoricalScalarFieldEnum>
  }


  /**
   * Historical findMany
   */
  export type HistoricalFindManyArgs = {
    /**
     * Select specific fields to fetch from the Historical
     */
    select?: HistoricalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoricalInclude | null
    /**
     * Filter, which Historicals to fetch.
     */
    where?: HistoricalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Historicals to fetch.
     */
    orderBy?: Enumerable<HistoricalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Historicals.
     */
    cursor?: HistoricalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Historicals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Historicals.
     */
    skip?: number
    distinct?: Enumerable<HistoricalScalarFieldEnum>
  }


  /**
   * Historical create
   */
  export type HistoricalCreateArgs = {
    /**
     * Select specific fields to fetch from the Historical
     */
    select?: HistoricalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoricalInclude | null
    /**
     * The data needed to create a Historical.
     */
    data: XOR<HistoricalCreateInput, HistoricalUncheckedCreateInput>
  }


  /**
   * Historical createMany
   */
  export type HistoricalCreateManyArgs = {
    /**
     * The data used to create many Historicals.
     */
    data: Enumerable<HistoricalCreateManyInput>
  }


  /**
   * Historical update
   */
  export type HistoricalUpdateArgs = {
    /**
     * Select specific fields to fetch from the Historical
     */
    select?: HistoricalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoricalInclude | null
    /**
     * The data needed to update a Historical.
     */
    data: XOR<HistoricalUpdateInput, HistoricalUncheckedUpdateInput>
    /**
     * Choose, which Historical to update.
     */
    where: HistoricalWhereUniqueInput
  }


  /**
   * Historical updateMany
   */
  export type HistoricalUpdateManyArgs = {
    /**
     * The data used to update Historicals.
     */
    data: XOR<HistoricalUpdateManyMutationInput, HistoricalUncheckedUpdateManyInput>
    /**
     * Filter which Historicals to update
     */
    where?: HistoricalWhereInput
  }


  /**
   * Historical upsert
   */
  export type HistoricalUpsertArgs = {
    /**
     * Select specific fields to fetch from the Historical
     */
    select?: HistoricalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoricalInclude | null
    /**
     * The filter to search for the Historical to update in case it exists.
     */
    where: HistoricalWhereUniqueInput
    /**
     * In case the Historical found by the `where` argument doesn't exist, create a new Historical with this data.
     */
    create: XOR<HistoricalCreateInput, HistoricalUncheckedCreateInput>
    /**
     * In case the Historical was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HistoricalUpdateInput, HistoricalUncheckedUpdateInput>
  }


  /**
   * Historical delete
   */
  export type HistoricalDeleteArgs = {
    /**
     * Select specific fields to fetch from the Historical
     */
    select?: HistoricalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoricalInclude | null
    /**
     * Filter which Historical to delete.
     */
    where: HistoricalWhereUniqueInput
  }


  /**
   * Historical deleteMany
   */
  export type HistoricalDeleteManyArgs = {
    /**
     * Filter which Historicals to delete
     */
    where?: HistoricalWhereInput
  }


  /**
   * Historical findRaw
   */
  export type HistoricalFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Historical aggregateRaw
   */
  export type HistoricalAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Historical without action
   */
  export type HistoricalArgs = {
    /**
     * Select specific fields to fetch from the Historical
     */
    select?: HistoricalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoricalInclude | null
  }



  /**
   * Model Message
   */


  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    message: string | null
    sendingDate: Date | null
    senderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    message: string | null
    sendingDate: Date | null
    senderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    message: number
    sendingDate: number
    senderId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    message?: true
    sendingDate?: true
    senderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    message?: true
    sendingDate?: true
    senderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    message?: true
    sendingDate?: true
    senderId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs = {
    where?: MessageWhereInput
    orderBy?: Enumerable<MessageOrderByWithAggregationInput>
    by: MessageScalarFieldEnum[]
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }


  export type MessageGroupByOutputType = {
    id: string
    message: string
    sendingDate: Date
    senderId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect = {
    id?: boolean
    message?: boolean
    sendingDate?: boolean
    senderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sender?: boolean | UserArgs
    receiver?: boolean | Message$receiverArgs
    _count?: boolean | MessageCountOutputTypeArgs
  }


  export type MessageInclude = {
    sender?: boolean | UserArgs
    receiver?: boolean | Message$receiverArgs
    _count?: boolean | MessageCountOutputTypeArgs
  }

  export type MessageGetPayload<S extends boolean | null | undefined | MessageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Message :
    S extends undefined ? never :
    S extends { include: any } & (MessageArgs | MessageFindManyArgs)
    ? Message  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'sender' ? UserGetPayload<S['include'][P]> :
        P extends 'receiver' ? Array < ReceiverGetPayload<S['include'][P]>>  :
        P extends '_count' ? MessageCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (MessageArgs | MessageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'sender' ? UserGetPayload<S['select'][P]> :
        P extends 'receiver' ? Array < ReceiverGetPayload<S['select'][P]>>  :
        P extends '_count' ? MessageCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Message ? Message[P] : never
  } 
      : Message


  type MessageCountArgs = 
    Omit<MessageFindManyArgs, 'select' | 'include'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Message'> extends True ? Prisma__MessageClient<MessageGetPayload<T>> : Prisma__MessageClient<MessageGetPayload<T> | null, null>

    /**
     * Find one Message that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MessageFindUniqueOrThrowArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Message'> extends True ? Prisma__MessageClient<MessageGetPayload<T>> : Prisma__MessageClient<MessageGetPayload<T> | null, null>

    /**
     * Find the first Message that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MessageFindFirstOrThrowArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessageFindManyArgs>(
      args?: SelectSubset<T, MessageFindManyArgs>
    ): Prisma.PrismaPromise<Array<MessageGetPayload<T>>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
    **/
    create<T extends MessageCreateArgs>(
      args: SelectSubset<T, MessageCreateArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Create many Messages.
     *     @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     *     @example
     *     // Create many Messages
     *     const message = await prisma.message.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessageCreateManyArgs>(
      args?: SelectSubset<T, MessageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
    **/
    delete<T extends MessageDeleteArgs>(
      args: SelectSubset<T, MessageDeleteArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageUpdateArgs>(
      args: SelectSubset<T, MessageUpdateArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageDeleteManyArgs>(
      args?: SelectSubset<T, MessageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageUpdateManyArgs>(
      args: SelectSubset<T, MessageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
    **/
    upsert<T extends MessageUpsertArgs>(
      args: SelectSubset<T, MessageUpsertArgs>
    ): Prisma__MessageClient<MessageGetPayload<T>>

    /**
     * Find zero or more Messages that matches the filter.
     * @param {MessageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const message = await prisma.message.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: MessageFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Message.
     * @param {MessageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const message = await prisma.message.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: MessageAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MessageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    sender<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    receiver<T extends Message$receiverArgs= {}>(args?: Subset<T, Message$receiverArgs>): Prisma.PrismaPromise<Array<ReceiverGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Message base type for findUnique actions
   */
  export type MessageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUnique
   */
  export interface MessageFindUniqueArgs extends MessageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message base type for findFirst actions
   */
  export type MessageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: Enumerable<MessageScalarFieldEnum>
  }

  /**
   * Message findFirst
   */
  export interface MessageFindFirstArgs extends MessageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Message findMany
   */
  export type MessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: Enumerable<MessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: Enumerable<MessageScalarFieldEnum>
  }


  /**
   * Message create
   */
  export type MessageCreateArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }


  /**
   * Message createMany
   */
  export type MessageCreateManyArgs = {
    /**
     * The data used to create many Messages.
     */
    data: Enumerable<MessageCreateManyInput>
  }


  /**
   * Message update
   */
  export type MessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }


  /**
   * Message upsert
   */
  export type MessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }


  /**
   * Message delete
   */
  export type MessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }


  /**
   * Message findRaw
   */
  export type MessageFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Message aggregateRaw
   */
  export type MessageAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Message.receiver
   */
  export type Message$receiverArgs = {
    /**
     * Select specific fields to fetch from the Receiver
     */
    select?: ReceiverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiverInclude | null
    where?: ReceiverWhereInput
    orderBy?: Enumerable<ReceiverOrderByWithRelationInput>
    cursor?: ReceiverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReceiverScalarFieldEnum>
  }


  /**
   * Message without action
   */
  export type MessageArgs = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude | null
  }



  /**
   * Model Receiver
   */


  export type AggregateReceiver = {
    _count: ReceiverCountAggregateOutputType | null
    _min: ReceiverMinAggregateOutputType | null
    _max: ReceiverMaxAggregateOutputType | null
  }

  export type ReceiverMinAggregateOutputType = {
    id: string | null
    readingDate: Date | null
    receiverId: string | null
    messageId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReceiverMaxAggregateOutputType = {
    id: string | null
    readingDate: Date | null
    receiverId: string | null
    messageId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReceiverCountAggregateOutputType = {
    id: number
    readingDate: number
    receiverId: number
    messageId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReceiverMinAggregateInputType = {
    id?: true
    readingDate?: true
    receiverId?: true
    messageId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReceiverMaxAggregateInputType = {
    id?: true
    readingDate?: true
    receiverId?: true
    messageId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReceiverCountAggregateInputType = {
    id?: true
    readingDate?: true
    receiverId?: true
    messageId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReceiverAggregateArgs = {
    /**
     * Filter which Receiver to aggregate.
     */
    where?: ReceiverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receivers to fetch.
     */
    orderBy?: Enumerable<ReceiverOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceiverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Receivers
    **/
    _count?: true | ReceiverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceiverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceiverMaxAggregateInputType
  }

  export type GetReceiverAggregateType<T extends ReceiverAggregateArgs> = {
        [P in keyof T & keyof AggregateReceiver]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceiver[P]>
      : GetScalarType<T[P], AggregateReceiver[P]>
  }




  export type ReceiverGroupByArgs = {
    where?: ReceiverWhereInput
    orderBy?: Enumerable<ReceiverOrderByWithAggregationInput>
    by: ReceiverScalarFieldEnum[]
    having?: ReceiverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceiverCountAggregateInputType | true
    _min?: ReceiverMinAggregateInputType
    _max?: ReceiverMaxAggregateInputType
  }


  export type ReceiverGroupByOutputType = {
    id: string
    readingDate: Date
    receiverId: string
    messageId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: ReceiverCountAggregateOutputType | null
    _min: ReceiverMinAggregateOutputType | null
    _max: ReceiverMaxAggregateOutputType | null
  }

  type GetReceiverGroupByPayload<T extends ReceiverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ReceiverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceiverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceiverGroupByOutputType[P]>
            : GetScalarType<T[P], ReceiverGroupByOutputType[P]>
        }
      >
    >


  export type ReceiverSelect = {
    id?: boolean
    readingDate?: boolean
    receiverId?: boolean
    messageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    receiver?: boolean | UserArgs
    message?: boolean | MessageArgs
  }


  export type ReceiverInclude = {
    receiver?: boolean | UserArgs
    message?: boolean | MessageArgs
  }

  export type ReceiverGetPayload<S extends boolean | null | undefined | ReceiverArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Receiver :
    S extends undefined ? never :
    S extends { include: any } & (ReceiverArgs | ReceiverFindManyArgs)
    ? Receiver  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'receiver' ? UserGetPayload<S['include'][P]> :
        P extends 'message' ? MessageGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ReceiverArgs | ReceiverFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'receiver' ? UserGetPayload<S['select'][P]> :
        P extends 'message' ? MessageGetPayload<S['select'][P]> :  P extends keyof Receiver ? Receiver[P] : never
  } 
      : Receiver


  type ReceiverCountArgs = 
    Omit<ReceiverFindManyArgs, 'select' | 'include'> & {
      select?: ReceiverCountAggregateInputType | true
    }

  export interface ReceiverDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Receiver that matches the filter.
     * @param {ReceiverFindUniqueArgs} args - Arguments to find a Receiver
     * @example
     * // Get one Receiver
     * const receiver = await prisma.receiver.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReceiverFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReceiverFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Receiver'> extends True ? Prisma__ReceiverClient<ReceiverGetPayload<T>> : Prisma__ReceiverClient<ReceiverGetPayload<T> | null, null>

    /**
     * Find one Receiver that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReceiverFindUniqueOrThrowArgs} args - Arguments to find a Receiver
     * @example
     * // Get one Receiver
     * const receiver = await prisma.receiver.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReceiverFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ReceiverFindUniqueOrThrowArgs>
    ): Prisma__ReceiverClient<ReceiverGetPayload<T>>

    /**
     * Find the first Receiver that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiverFindFirstArgs} args - Arguments to find a Receiver
     * @example
     * // Get one Receiver
     * const receiver = await prisma.receiver.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReceiverFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReceiverFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Receiver'> extends True ? Prisma__ReceiverClient<ReceiverGetPayload<T>> : Prisma__ReceiverClient<ReceiverGetPayload<T> | null, null>

    /**
     * Find the first Receiver that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiverFindFirstOrThrowArgs} args - Arguments to find a Receiver
     * @example
     * // Get one Receiver
     * const receiver = await prisma.receiver.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReceiverFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReceiverFindFirstOrThrowArgs>
    ): Prisma__ReceiverClient<ReceiverGetPayload<T>>

    /**
     * Find zero or more Receivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiverFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Receivers
     * const receivers = await prisma.receiver.findMany()
     * 
     * // Get first 10 Receivers
     * const receivers = await prisma.receiver.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receiverWithIdOnly = await prisma.receiver.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReceiverFindManyArgs>(
      args?: SelectSubset<T, ReceiverFindManyArgs>
    ): Prisma.PrismaPromise<Array<ReceiverGetPayload<T>>>

    /**
     * Create a Receiver.
     * @param {ReceiverCreateArgs} args - Arguments to create a Receiver.
     * @example
     * // Create one Receiver
     * const Receiver = await prisma.receiver.create({
     *   data: {
     *     // ... data to create a Receiver
     *   }
     * })
     * 
    **/
    create<T extends ReceiverCreateArgs>(
      args: SelectSubset<T, ReceiverCreateArgs>
    ): Prisma__ReceiverClient<ReceiverGetPayload<T>>

    /**
     * Create many Receivers.
     *     @param {ReceiverCreateManyArgs} args - Arguments to create many Receivers.
     *     @example
     *     // Create many Receivers
     *     const receiver = await prisma.receiver.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReceiverCreateManyArgs>(
      args?: SelectSubset<T, ReceiverCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Receiver.
     * @param {ReceiverDeleteArgs} args - Arguments to delete one Receiver.
     * @example
     * // Delete one Receiver
     * const Receiver = await prisma.receiver.delete({
     *   where: {
     *     // ... filter to delete one Receiver
     *   }
     * })
     * 
    **/
    delete<T extends ReceiverDeleteArgs>(
      args: SelectSubset<T, ReceiverDeleteArgs>
    ): Prisma__ReceiverClient<ReceiverGetPayload<T>>

    /**
     * Update one Receiver.
     * @param {ReceiverUpdateArgs} args - Arguments to update one Receiver.
     * @example
     * // Update one Receiver
     * const receiver = await prisma.receiver.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReceiverUpdateArgs>(
      args: SelectSubset<T, ReceiverUpdateArgs>
    ): Prisma__ReceiverClient<ReceiverGetPayload<T>>

    /**
     * Delete zero or more Receivers.
     * @param {ReceiverDeleteManyArgs} args - Arguments to filter Receivers to delete.
     * @example
     * // Delete a few Receivers
     * const { count } = await prisma.receiver.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReceiverDeleteManyArgs>(
      args?: SelectSubset<T, ReceiverDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Receivers
     * const receiver = await prisma.receiver.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReceiverUpdateManyArgs>(
      args: SelectSubset<T, ReceiverUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Receiver.
     * @param {ReceiverUpsertArgs} args - Arguments to update or create a Receiver.
     * @example
     * // Update or create a Receiver
     * const receiver = await prisma.receiver.upsert({
     *   create: {
     *     // ... data to create a Receiver
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Receiver we want to update
     *   }
     * })
    **/
    upsert<T extends ReceiverUpsertArgs>(
      args: SelectSubset<T, ReceiverUpsertArgs>
    ): Prisma__ReceiverClient<ReceiverGetPayload<T>>

    /**
     * Find zero or more Receivers that matches the filter.
     * @param {ReceiverFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const receiver = await prisma.receiver.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ReceiverFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Receiver.
     * @param {ReceiverAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const receiver = await prisma.receiver.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ReceiverAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Receivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiverCountArgs} args - Arguments to filter Receivers to count.
     * @example
     * // Count the number of Receivers
     * const count = await prisma.receiver.count({
     *   where: {
     *     // ... the filter for the Receivers we want to count
     *   }
     * })
    **/
    count<T extends ReceiverCountArgs>(
      args?: Subset<T, ReceiverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceiverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Receiver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceiverAggregateArgs>(args: Subset<T, ReceiverAggregateArgs>): Prisma.PrismaPromise<GetReceiverAggregateType<T>>

    /**
     * Group by Receiver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceiverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceiverGroupByArgs['orderBy'] }
        : { orderBy?: ReceiverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceiverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceiverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Receiver.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReceiverClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    receiver<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    message<T extends MessageArgs= {}>(args?: Subset<T, MessageArgs>): Prisma__MessageClient<MessageGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Receiver base type for findUnique actions
   */
  export type ReceiverFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Receiver
     */
    select?: ReceiverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiverInclude | null
    /**
     * Filter, which Receiver to fetch.
     */
    where: ReceiverWhereUniqueInput
  }

  /**
   * Receiver findUnique
   */
  export interface ReceiverFindUniqueArgs extends ReceiverFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Receiver findUniqueOrThrow
   */
  export type ReceiverFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Receiver
     */
    select?: ReceiverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiverInclude | null
    /**
     * Filter, which Receiver to fetch.
     */
    where: ReceiverWhereUniqueInput
  }


  /**
   * Receiver base type for findFirst actions
   */
  export type ReceiverFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Receiver
     */
    select?: ReceiverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiverInclude | null
    /**
     * Filter, which Receiver to fetch.
     */
    where?: ReceiverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receivers to fetch.
     */
    orderBy?: Enumerable<ReceiverOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receivers.
     */
    cursor?: ReceiverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receivers.
     */
    distinct?: Enumerable<ReceiverScalarFieldEnum>
  }

  /**
   * Receiver findFirst
   */
  export interface ReceiverFindFirstArgs extends ReceiverFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Receiver findFirstOrThrow
   */
  export type ReceiverFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Receiver
     */
    select?: ReceiverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiverInclude | null
    /**
     * Filter, which Receiver to fetch.
     */
    where?: ReceiverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receivers to fetch.
     */
    orderBy?: Enumerable<ReceiverOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receivers.
     */
    cursor?: ReceiverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receivers.
     */
    distinct?: Enumerable<ReceiverScalarFieldEnum>
  }


  /**
   * Receiver findMany
   */
  export type ReceiverFindManyArgs = {
    /**
     * Select specific fields to fetch from the Receiver
     */
    select?: ReceiverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiverInclude | null
    /**
     * Filter, which Receivers to fetch.
     */
    where?: ReceiverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receivers to fetch.
     */
    orderBy?: Enumerable<ReceiverOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Receivers.
     */
    cursor?: ReceiverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receivers.
     */
    skip?: number
    distinct?: Enumerable<ReceiverScalarFieldEnum>
  }


  /**
   * Receiver create
   */
  export type ReceiverCreateArgs = {
    /**
     * Select specific fields to fetch from the Receiver
     */
    select?: ReceiverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiverInclude | null
    /**
     * The data needed to create a Receiver.
     */
    data: XOR<ReceiverCreateInput, ReceiverUncheckedCreateInput>
  }


  /**
   * Receiver createMany
   */
  export type ReceiverCreateManyArgs = {
    /**
     * The data used to create many Receivers.
     */
    data: Enumerable<ReceiverCreateManyInput>
  }


  /**
   * Receiver update
   */
  export type ReceiverUpdateArgs = {
    /**
     * Select specific fields to fetch from the Receiver
     */
    select?: ReceiverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiverInclude | null
    /**
     * The data needed to update a Receiver.
     */
    data: XOR<ReceiverUpdateInput, ReceiverUncheckedUpdateInput>
    /**
     * Choose, which Receiver to update.
     */
    where: ReceiverWhereUniqueInput
  }


  /**
   * Receiver updateMany
   */
  export type ReceiverUpdateManyArgs = {
    /**
     * The data used to update Receivers.
     */
    data: XOR<ReceiverUpdateManyMutationInput, ReceiverUncheckedUpdateManyInput>
    /**
     * Filter which Receivers to update
     */
    where?: ReceiverWhereInput
  }


  /**
   * Receiver upsert
   */
  export type ReceiverUpsertArgs = {
    /**
     * Select specific fields to fetch from the Receiver
     */
    select?: ReceiverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiverInclude | null
    /**
     * The filter to search for the Receiver to update in case it exists.
     */
    where: ReceiverWhereUniqueInput
    /**
     * In case the Receiver found by the `where` argument doesn't exist, create a new Receiver with this data.
     */
    create: XOR<ReceiverCreateInput, ReceiverUncheckedCreateInput>
    /**
     * In case the Receiver was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceiverUpdateInput, ReceiverUncheckedUpdateInput>
  }


  /**
   * Receiver delete
   */
  export type ReceiverDeleteArgs = {
    /**
     * Select specific fields to fetch from the Receiver
     */
    select?: ReceiverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiverInclude | null
    /**
     * Filter which Receiver to delete.
     */
    where: ReceiverWhereUniqueInput
  }


  /**
   * Receiver deleteMany
   */
  export type ReceiverDeleteManyArgs = {
    /**
     * Filter which Receivers to delete
     */
    where?: ReceiverWhereInput
  }


  /**
   * Receiver findRaw
   */
  export type ReceiverFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Receiver aggregateRaw
   */
  export type ReceiverAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Receiver without action
   */
  export type ReceiverArgs = {
    /**
     * Select specific fields to fetch from the Receiver
     */
    select?: ReceiverSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReceiverInclude | null
  }



  /**
   * Model NewsLetter
   */


  export type AggregateNewsLetter = {
    _count: NewsLetterCountAggregateOutputType | null
    _min: NewsLetterMinAggregateOutputType | null
    _max: NewsLetterMaxAggregateOutputType | null
  }

  export type NewsLetterMinAggregateOutputType = {
    id: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsLetterMaxAggregateOutputType = {
    id: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NewsLetterCountAggregateOutputType = {
    id: number
    email: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NewsLetterMinAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsLetterMaxAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NewsLetterCountAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NewsLetterAggregateArgs = {
    /**
     * Filter which NewsLetter to aggregate.
     */
    where?: NewsLetterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsLetters to fetch.
     */
    orderBy?: Enumerable<NewsLetterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NewsLetterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsLetters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsLetters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NewsLetters
    **/
    _count?: true | NewsLetterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsLetterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsLetterMaxAggregateInputType
  }

  export type GetNewsLetterAggregateType<T extends NewsLetterAggregateArgs> = {
        [P in keyof T & keyof AggregateNewsLetter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNewsLetter[P]>
      : GetScalarType<T[P], AggregateNewsLetter[P]>
  }




  export type NewsLetterGroupByArgs = {
    where?: NewsLetterWhereInput
    orderBy?: Enumerable<NewsLetterOrderByWithAggregationInput>
    by: NewsLetterScalarFieldEnum[]
    having?: NewsLetterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsLetterCountAggregateInputType | true
    _min?: NewsLetterMinAggregateInputType
    _max?: NewsLetterMaxAggregateInputType
  }


  export type NewsLetterGroupByOutputType = {
    id: string
    email: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: NewsLetterCountAggregateOutputType | null
    _min: NewsLetterMinAggregateOutputType | null
    _max: NewsLetterMaxAggregateOutputType | null
  }

  type GetNewsLetterGroupByPayload<T extends NewsLetterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NewsLetterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsLetterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsLetterGroupByOutputType[P]>
            : GetScalarType<T[P], NewsLetterGroupByOutputType[P]>
        }
      >
    >


  export type NewsLetterSelect = {
    id?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type NewsLetterGetPayload<S extends boolean | null | undefined | NewsLetterArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? NewsLetter :
    S extends undefined ? never :
    S extends { include: any } & (NewsLetterArgs | NewsLetterFindManyArgs)
    ? NewsLetter 
    : S extends { select: any } & (NewsLetterArgs | NewsLetterFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof NewsLetter ? NewsLetter[P] : never
  } 
      : NewsLetter


  type NewsLetterCountArgs = 
    Omit<NewsLetterFindManyArgs, 'select' | 'include'> & {
      select?: NewsLetterCountAggregateInputType | true
    }

  export interface NewsLetterDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one NewsLetter that matches the filter.
     * @param {NewsLetterFindUniqueArgs} args - Arguments to find a NewsLetter
     * @example
     * // Get one NewsLetter
     * const newsLetter = await prisma.newsLetter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NewsLetterFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NewsLetterFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'NewsLetter'> extends True ? Prisma__NewsLetterClient<NewsLetterGetPayload<T>> : Prisma__NewsLetterClient<NewsLetterGetPayload<T> | null, null>

    /**
     * Find one NewsLetter that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NewsLetterFindUniqueOrThrowArgs} args - Arguments to find a NewsLetter
     * @example
     * // Get one NewsLetter
     * const newsLetter = await prisma.newsLetter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NewsLetterFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NewsLetterFindUniqueOrThrowArgs>
    ): Prisma__NewsLetterClient<NewsLetterGetPayload<T>>

    /**
     * Find the first NewsLetter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsLetterFindFirstArgs} args - Arguments to find a NewsLetter
     * @example
     * // Get one NewsLetter
     * const newsLetter = await prisma.newsLetter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NewsLetterFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NewsLetterFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'NewsLetter'> extends True ? Prisma__NewsLetterClient<NewsLetterGetPayload<T>> : Prisma__NewsLetterClient<NewsLetterGetPayload<T> | null, null>

    /**
     * Find the first NewsLetter that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsLetterFindFirstOrThrowArgs} args - Arguments to find a NewsLetter
     * @example
     * // Get one NewsLetter
     * const newsLetter = await prisma.newsLetter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NewsLetterFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NewsLetterFindFirstOrThrowArgs>
    ): Prisma__NewsLetterClient<NewsLetterGetPayload<T>>

    /**
     * Find zero or more NewsLetters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsLetterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NewsLetters
     * const newsLetters = await prisma.newsLetter.findMany()
     * 
     * // Get first 10 NewsLetters
     * const newsLetters = await prisma.newsLetter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsLetterWithIdOnly = await prisma.newsLetter.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NewsLetterFindManyArgs>(
      args?: SelectSubset<T, NewsLetterFindManyArgs>
    ): Prisma.PrismaPromise<Array<NewsLetterGetPayload<T>>>

    /**
     * Create a NewsLetter.
     * @param {NewsLetterCreateArgs} args - Arguments to create a NewsLetter.
     * @example
     * // Create one NewsLetter
     * const NewsLetter = await prisma.newsLetter.create({
     *   data: {
     *     // ... data to create a NewsLetter
     *   }
     * })
     * 
    **/
    create<T extends NewsLetterCreateArgs>(
      args: SelectSubset<T, NewsLetterCreateArgs>
    ): Prisma__NewsLetterClient<NewsLetterGetPayload<T>>

    /**
     * Create many NewsLetters.
     *     @param {NewsLetterCreateManyArgs} args - Arguments to create many NewsLetters.
     *     @example
     *     // Create many NewsLetters
     *     const newsLetter = await prisma.newsLetter.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NewsLetterCreateManyArgs>(
      args?: SelectSubset<T, NewsLetterCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NewsLetter.
     * @param {NewsLetterDeleteArgs} args - Arguments to delete one NewsLetter.
     * @example
     * // Delete one NewsLetter
     * const NewsLetter = await prisma.newsLetter.delete({
     *   where: {
     *     // ... filter to delete one NewsLetter
     *   }
     * })
     * 
    **/
    delete<T extends NewsLetterDeleteArgs>(
      args: SelectSubset<T, NewsLetterDeleteArgs>
    ): Prisma__NewsLetterClient<NewsLetterGetPayload<T>>

    /**
     * Update one NewsLetter.
     * @param {NewsLetterUpdateArgs} args - Arguments to update one NewsLetter.
     * @example
     * // Update one NewsLetter
     * const newsLetter = await prisma.newsLetter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NewsLetterUpdateArgs>(
      args: SelectSubset<T, NewsLetterUpdateArgs>
    ): Prisma__NewsLetterClient<NewsLetterGetPayload<T>>

    /**
     * Delete zero or more NewsLetters.
     * @param {NewsLetterDeleteManyArgs} args - Arguments to filter NewsLetters to delete.
     * @example
     * // Delete a few NewsLetters
     * const { count } = await prisma.newsLetter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NewsLetterDeleteManyArgs>(
      args?: SelectSubset<T, NewsLetterDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NewsLetters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsLetterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NewsLetters
     * const newsLetter = await prisma.newsLetter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NewsLetterUpdateManyArgs>(
      args: SelectSubset<T, NewsLetterUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NewsLetter.
     * @param {NewsLetterUpsertArgs} args - Arguments to update or create a NewsLetter.
     * @example
     * // Update or create a NewsLetter
     * const newsLetter = await prisma.newsLetter.upsert({
     *   create: {
     *     // ... data to create a NewsLetter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NewsLetter we want to update
     *   }
     * })
    **/
    upsert<T extends NewsLetterUpsertArgs>(
      args: SelectSubset<T, NewsLetterUpsertArgs>
    ): Prisma__NewsLetterClient<NewsLetterGetPayload<T>>

    /**
     * Find zero or more NewsLetters that matches the filter.
     * @param {NewsLetterFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const newsLetter = await prisma.newsLetter.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: NewsLetterFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a NewsLetter.
     * @param {NewsLetterAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const newsLetter = await prisma.newsLetter.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: NewsLetterAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of NewsLetters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsLetterCountArgs} args - Arguments to filter NewsLetters to count.
     * @example
     * // Count the number of NewsLetters
     * const count = await prisma.newsLetter.count({
     *   where: {
     *     // ... the filter for the NewsLetters we want to count
     *   }
     * })
    **/
    count<T extends NewsLetterCountArgs>(
      args?: Subset<T, NewsLetterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsLetterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NewsLetter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsLetterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsLetterAggregateArgs>(args: Subset<T, NewsLetterAggregateArgs>): Prisma.PrismaPromise<GetNewsLetterAggregateType<T>>

    /**
     * Group by NewsLetter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsLetterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NewsLetterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NewsLetterGroupByArgs['orderBy'] }
        : { orderBy?: NewsLetterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NewsLetterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsLetterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for NewsLetter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NewsLetterClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * NewsLetter base type for findUnique actions
   */
  export type NewsLetterFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the NewsLetter
     */
    select?: NewsLetterSelect | null
    /**
     * Filter, which NewsLetter to fetch.
     */
    where: NewsLetterWhereUniqueInput
  }

  /**
   * NewsLetter findUnique
   */
  export interface NewsLetterFindUniqueArgs extends NewsLetterFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NewsLetter findUniqueOrThrow
   */
  export type NewsLetterFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the NewsLetter
     */
    select?: NewsLetterSelect | null
    /**
     * Filter, which NewsLetter to fetch.
     */
    where: NewsLetterWhereUniqueInput
  }


  /**
   * NewsLetter base type for findFirst actions
   */
  export type NewsLetterFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the NewsLetter
     */
    select?: NewsLetterSelect | null
    /**
     * Filter, which NewsLetter to fetch.
     */
    where?: NewsLetterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsLetters to fetch.
     */
    orderBy?: Enumerable<NewsLetterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsLetters.
     */
    cursor?: NewsLetterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsLetters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsLetters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsLetters.
     */
    distinct?: Enumerable<NewsLetterScalarFieldEnum>
  }

  /**
   * NewsLetter findFirst
   */
  export interface NewsLetterFindFirstArgs extends NewsLetterFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NewsLetter findFirstOrThrow
   */
  export type NewsLetterFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the NewsLetter
     */
    select?: NewsLetterSelect | null
    /**
     * Filter, which NewsLetter to fetch.
     */
    where?: NewsLetterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsLetters to fetch.
     */
    orderBy?: Enumerable<NewsLetterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NewsLetters.
     */
    cursor?: NewsLetterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsLetters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsLetters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NewsLetters.
     */
    distinct?: Enumerable<NewsLetterScalarFieldEnum>
  }


  /**
   * NewsLetter findMany
   */
  export type NewsLetterFindManyArgs = {
    /**
     * Select specific fields to fetch from the NewsLetter
     */
    select?: NewsLetterSelect | null
    /**
     * Filter, which NewsLetters to fetch.
     */
    where?: NewsLetterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NewsLetters to fetch.
     */
    orderBy?: Enumerable<NewsLetterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NewsLetters.
     */
    cursor?: NewsLetterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NewsLetters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NewsLetters.
     */
    skip?: number
    distinct?: Enumerable<NewsLetterScalarFieldEnum>
  }


  /**
   * NewsLetter create
   */
  export type NewsLetterCreateArgs = {
    /**
     * Select specific fields to fetch from the NewsLetter
     */
    select?: NewsLetterSelect | null
    /**
     * The data needed to create a NewsLetter.
     */
    data: XOR<NewsLetterCreateInput, NewsLetterUncheckedCreateInput>
  }


  /**
   * NewsLetter createMany
   */
  export type NewsLetterCreateManyArgs = {
    /**
     * The data used to create many NewsLetters.
     */
    data: Enumerable<NewsLetterCreateManyInput>
  }


  /**
   * NewsLetter update
   */
  export type NewsLetterUpdateArgs = {
    /**
     * Select specific fields to fetch from the NewsLetter
     */
    select?: NewsLetterSelect | null
    /**
     * The data needed to update a NewsLetter.
     */
    data: XOR<NewsLetterUpdateInput, NewsLetterUncheckedUpdateInput>
    /**
     * Choose, which NewsLetter to update.
     */
    where: NewsLetterWhereUniqueInput
  }


  /**
   * NewsLetter updateMany
   */
  export type NewsLetterUpdateManyArgs = {
    /**
     * The data used to update NewsLetters.
     */
    data: XOR<NewsLetterUpdateManyMutationInput, NewsLetterUncheckedUpdateManyInput>
    /**
     * Filter which NewsLetters to update
     */
    where?: NewsLetterWhereInput
  }


  /**
   * NewsLetter upsert
   */
  export type NewsLetterUpsertArgs = {
    /**
     * Select specific fields to fetch from the NewsLetter
     */
    select?: NewsLetterSelect | null
    /**
     * The filter to search for the NewsLetter to update in case it exists.
     */
    where: NewsLetterWhereUniqueInput
    /**
     * In case the NewsLetter found by the `where` argument doesn't exist, create a new NewsLetter with this data.
     */
    create: XOR<NewsLetterCreateInput, NewsLetterUncheckedCreateInput>
    /**
     * In case the NewsLetter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NewsLetterUpdateInput, NewsLetterUncheckedUpdateInput>
  }


  /**
   * NewsLetter delete
   */
  export type NewsLetterDeleteArgs = {
    /**
     * Select specific fields to fetch from the NewsLetter
     */
    select?: NewsLetterSelect | null
    /**
     * Filter which NewsLetter to delete.
     */
    where: NewsLetterWhereUniqueInput
  }


  /**
   * NewsLetter deleteMany
   */
  export type NewsLetterDeleteManyArgs = {
    /**
     * Filter which NewsLetters to delete
     */
    where?: NewsLetterWhereInput
  }


  /**
   * NewsLetter findRaw
   */
  export type NewsLetterFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * NewsLetter aggregateRaw
   */
  export type NewsLetterAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * NewsLetter without action
   */
  export type NewsLetterArgs = {
    /**
     * Select specific fields to fetch from the NewsLetter
     */
    select?: NewsLetterSelect | null
  }



  /**
   * Model Temoignage
   */


  export type AggregateTemoignage = {
    _count: TemoignageCountAggregateOutputType | null
    _avg: TemoignageAvgAggregateOutputType | null
    _sum: TemoignageSumAggregateOutputType | null
    _min: TemoignageMinAggregateOutputType | null
    _max: TemoignageMaxAggregateOutputType | null
  }

  export type TemoignageAvgAggregateOutputType = {
    rating: number | null
  }

  export type TemoignageSumAggregateOutputType = {
    rating: number | null
  }

  export type TemoignageMinAggregateOutputType = {
    id: string | null
    comment: string | null
    rating: number | null
    commentDate: Date | null
    isToShow: boolean | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemoignageMaxAggregateOutputType = {
    id: string | null
    comment: string | null
    rating: number | null
    commentDate: Date | null
    isToShow: boolean | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemoignageCountAggregateOutputType = {
    id: number
    comment: number
    rating: number
    commentDate: number
    isToShow: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TemoignageAvgAggregateInputType = {
    rating?: true
  }

  export type TemoignageSumAggregateInputType = {
    rating?: true
  }

  export type TemoignageMinAggregateInputType = {
    id?: true
    comment?: true
    rating?: true
    commentDate?: true
    isToShow?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemoignageMaxAggregateInputType = {
    id?: true
    comment?: true
    rating?: true
    commentDate?: true
    isToShow?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemoignageCountAggregateInputType = {
    id?: true
    comment?: true
    rating?: true
    commentDate?: true
    isToShow?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TemoignageAggregateArgs = {
    /**
     * Filter which Temoignage to aggregate.
     */
    where?: TemoignageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Temoignages to fetch.
     */
    orderBy?: Enumerable<TemoignageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemoignageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Temoignages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Temoignages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Temoignages
    **/
    _count?: true | TemoignageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemoignageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemoignageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemoignageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemoignageMaxAggregateInputType
  }

  export type GetTemoignageAggregateType<T extends TemoignageAggregateArgs> = {
        [P in keyof T & keyof AggregateTemoignage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemoignage[P]>
      : GetScalarType<T[P], AggregateTemoignage[P]>
  }




  export type TemoignageGroupByArgs = {
    where?: TemoignageWhereInput
    orderBy?: Enumerable<TemoignageOrderByWithAggregationInput>
    by: TemoignageScalarFieldEnum[]
    having?: TemoignageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemoignageCountAggregateInputType | true
    _avg?: TemoignageAvgAggregateInputType
    _sum?: TemoignageSumAggregateInputType
    _min?: TemoignageMinAggregateInputType
    _max?: TemoignageMaxAggregateInputType
  }


  export type TemoignageGroupByOutputType = {
    id: string
    comment: string
    rating: number
    commentDate: Date
    isToShow: boolean
    userId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: TemoignageCountAggregateOutputType | null
    _avg: TemoignageAvgAggregateOutputType | null
    _sum: TemoignageSumAggregateOutputType | null
    _min: TemoignageMinAggregateOutputType | null
    _max: TemoignageMaxAggregateOutputType | null
  }

  type GetTemoignageGroupByPayload<T extends TemoignageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TemoignageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemoignageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemoignageGroupByOutputType[P]>
            : GetScalarType<T[P], TemoignageGroupByOutputType[P]>
        }
      >
    >


  export type TemoignageSelect = {
    id?: boolean
    comment?: boolean
    rating?: boolean
    commentDate?: boolean
    isToShow?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
  }


  export type TemoignageInclude = {
    user?: boolean | UserArgs
  }

  export type TemoignageGetPayload<S extends boolean | null | undefined | TemoignageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Temoignage :
    S extends undefined ? never :
    S extends { include: any } & (TemoignageArgs | TemoignageFindManyArgs)
    ? Temoignage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TemoignageArgs | TemoignageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Temoignage ? Temoignage[P] : never
  } 
      : Temoignage


  type TemoignageCountArgs = 
    Omit<TemoignageFindManyArgs, 'select' | 'include'> & {
      select?: TemoignageCountAggregateInputType | true
    }

  export interface TemoignageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Temoignage that matches the filter.
     * @param {TemoignageFindUniqueArgs} args - Arguments to find a Temoignage
     * @example
     * // Get one Temoignage
     * const temoignage = await prisma.temoignage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TemoignageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TemoignageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Temoignage'> extends True ? Prisma__TemoignageClient<TemoignageGetPayload<T>> : Prisma__TemoignageClient<TemoignageGetPayload<T> | null, null>

    /**
     * Find one Temoignage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TemoignageFindUniqueOrThrowArgs} args - Arguments to find a Temoignage
     * @example
     * // Get one Temoignage
     * const temoignage = await prisma.temoignage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TemoignageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TemoignageFindUniqueOrThrowArgs>
    ): Prisma__TemoignageClient<TemoignageGetPayload<T>>

    /**
     * Find the first Temoignage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemoignageFindFirstArgs} args - Arguments to find a Temoignage
     * @example
     * // Get one Temoignage
     * const temoignage = await prisma.temoignage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TemoignageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TemoignageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Temoignage'> extends True ? Prisma__TemoignageClient<TemoignageGetPayload<T>> : Prisma__TemoignageClient<TemoignageGetPayload<T> | null, null>

    /**
     * Find the first Temoignage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemoignageFindFirstOrThrowArgs} args - Arguments to find a Temoignage
     * @example
     * // Get one Temoignage
     * const temoignage = await prisma.temoignage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TemoignageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TemoignageFindFirstOrThrowArgs>
    ): Prisma__TemoignageClient<TemoignageGetPayload<T>>

    /**
     * Find zero or more Temoignages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemoignageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Temoignages
     * const temoignages = await prisma.temoignage.findMany()
     * 
     * // Get first 10 Temoignages
     * const temoignages = await prisma.temoignage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const temoignageWithIdOnly = await prisma.temoignage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TemoignageFindManyArgs>(
      args?: SelectSubset<T, TemoignageFindManyArgs>
    ): Prisma.PrismaPromise<Array<TemoignageGetPayload<T>>>

    /**
     * Create a Temoignage.
     * @param {TemoignageCreateArgs} args - Arguments to create a Temoignage.
     * @example
     * // Create one Temoignage
     * const Temoignage = await prisma.temoignage.create({
     *   data: {
     *     // ... data to create a Temoignage
     *   }
     * })
     * 
    **/
    create<T extends TemoignageCreateArgs>(
      args: SelectSubset<T, TemoignageCreateArgs>
    ): Prisma__TemoignageClient<TemoignageGetPayload<T>>

    /**
     * Create many Temoignages.
     *     @param {TemoignageCreateManyArgs} args - Arguments to create many Temoignages.
     *     @example
     *     // Create many Temoignages
     *     const temoignage = await prisma.temoignage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TemoignageCreateManyArgs>(
      args?: SelectSubset<T, TemoignageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Temoignage.
     * @param {TemoignageDeleteArgs} args - Arguments to delete one Temoignage.
     * @example
     * // Delete one Temoignage
     * const Temoignage = await prisma.temoignage.delete({
     *   where: {
     *     // ... filter to delete one Temoignage
     *   }
     * })
     * 
    **/
    delete<T extends TemoignageDeleteArgs>(
      args: SelectSubset<T, TemoignageDeleteArgs>
    ): Prisma__TemoignageClient<TemoignageGetPayload<T>>

    /**
     * Update one Temoignage.
     * @param {TemoignageUpdateArgs} args - Arguments to update one Temoignage.
     * @example
     * // Update one Temoignage
     * const temoignage = await prisma.temoignage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TemoignageUpdateArgs>(
      args: SelectSubset<T, TemoignageUpdateArgs>
    ): Prisma__TemoignageClient<TemoignageGetPayload<T>>

    /**
     * Delete zero or more Temoignages.
     * @param {TemoignageDeleteManyArgs} args - Arguments to filter Temoignages to delete.
     * @example
     * // Delete a few Temoignages
     * const { count } = await prisma.temoignage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TemoignageDeleteManyArgs>(
      args?: SelectSubset<T, TemoignageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Temoignages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemoignageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Temoignages
     * const temoignage = await prisma.temoignage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TemoignageUpdateManyArgs>(
      args: SelectSubset<T, TemoignageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Temoignage.
     * @param {TemoignageUpsertArgs} args - Arguments to update or create a Temoignage.
     * @example
     * // Update or create a Temoignage
     * const temoignage = await prisma.temoignage.upsert({
     *   create: {
     *     // ... data to create a Temoignage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Temoignage we want to update
     *   }
     * })
    **/
    upsert<T extends TemoignageUpsertArgs>(
      args: SelectSubset<T, TemoignageUpsertArgs>
    ): Prisma__TemoignageClient<TemoignageGetPayload<T>>

    /**
     * Find zero or more Temoignages that matches the filter.
     * @param {TemoignageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const temoignage = await prisma.temoignage.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TemoignageFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Temoignage.
     * @param {TemoignageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const temoignage = await prisma.temoignage.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TemoignageAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Temoignages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemoignageCountArgs} args - Arguments to filter Temoignages to count.
     * @example
     * // Count the number of Temoignages
     * const count = await prisma.temoignage.count({
     *   where: {
     *     // ... the filter for the Temoignages we want to count
     *   }
     * })
    **/
    count<T extends TemoignageCountArgs>(
      args?: Subset<T, TemoignageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemoignageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Temoignage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemoignageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemoignageAggregateArgs>(args: Subset<T, TemoignageAggregateArgs>): Prisma.PrismaPromise<GetTemoignageAggregateType<T>>

    /**
     * Group by Temoignage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemoignageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemoignageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemoignageGroupByArgs['orderBy'] }
        : { orderBy?: TemoignageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemoignageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemoignageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Temoignage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TemoignageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Temoignage base type for findUnique actions
   */
  export type TemoignageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Temoignage
     */
    select?: TemoignageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemoignageInclude | null
    /**
     * Filter, which Temoignage to fetch.
     */
    where: TemoignageWhereUniqueInput
  }

  /**
   * Temoignage findUnique
   */
  export interface TemoignageFindUniqueArgs extends TemoignageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Temoignage findUniqueOrThrow
   */
  export type TemoignageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Temoignage
     */
    select?: TemoignageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemoignageInclude | null
    /**
     * Filter, which Temoignage to fetch.
     */
    where: TemoignageWhereUniqueInput
  }


  /**
   * Temoignage base type for findFirst actions
   */
  export type TemoignageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Temoignage
     */
    select?: TemoignageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemoignageInclude | null
    /**
     * Filter, which Temoignage to fetch.
     */
    where?: TemoignageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Temoignages to fetch.
     */
    orderBy?: Enumerable<TemoignageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Temoignages.
     */
    cursor?: TemoignageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Temoignages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Temoignages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Temoignages.
     */
    distinct?: Enumerable<TemoignageScalarFieldEnum>
  }

  /**
   * Temoignage findFirst
   */
  export interface TemoignageFindFirstArgs extends TemoignageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Temoignage findFirstOrThrow
   */
  export type TemoignageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Temoignage
     */
    select?: TemoignageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemoignageInclude | null
    /**
     * Filter, which Temoignage to fetch.
     */
    where?: TemoignageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Temoignages to fetch.
     */
    orderBy?: Enumerable<TemoignageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Temoignages.
     */
    cursor?: TemoignageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Temoignages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Temoignages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Temoignages.
     */
    distinct?: Enumerable<TemoignageScalarFieldEnum>
  }


  /**
   * Temoignage findMany
   */
  export type TemoignageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Temoignage
     */
    select?: TemoignageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemoignageInclude | null
    /**
     * Filter, which Temoignages to fetch.
     */
    where?: TemoignageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Temoignages to fetch.
     */
    orderBy?: Enumerable<TemoignageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Temoignages.
     */
    cursor?: TemoignageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Temoignages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Temoignages.
     */
    skip?: number
    distinct?: Enumerable<TemoignageScalarFieldEnum>
  }


  /**
   * Temoignage create
   */
  export type TemoignageCreateArgs = {
    /**
     * Select specific fields to fetch from the Temoignage
     */
    select?: TemoignageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemoignageInclude | null
    /**
     * The data needed to create a Temoignage.
     */
    data: XOR<TemoignageCreateInput, TemoignageUncheckedCreateInput>
  }


  /**
   * Temoignage createMany
   */
  export type TemoignageCreateManyArgs = {
    /**
     * The data used to create many Temoignages.
     */
    data: Enumerable<TemoignageCreateManyInput>
  }


  /**
   * Temoignage update
   */
  export type TemoignageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Temoignage
     */
    select?: TemoignageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemoignageInclude | null
    /**
     * The data needed to update a Temoignage.
     */
    data: XOR<TemoignageUpdateInput, TemoignageUncheckedUpdateInput>
    /**
     * Choose, which Temoignage to update.
     */
    where: TemoignageWhereUniqueInput
  }


  /**
   * Temoignage updateMany
   */
  export type TemoignageUpdateManyArgs = {
    /**
     * The data used to update Temoignages.
     */
    data: XOR<TemoignageUpdateManyMutationInput, TemoignageUncheckedUpdateManyInput>
    /**
     * Filter which Temoignages to update
     */
    where?: TemoignageWhereInput
  }


  /**
   * Temoignage upsert
   */
  export type TemoignageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Temoignage
     */
    select?: TemoignageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemoignageInclude | null
    /**
     * The filter to search for the Temoignage to update in case it exists.
     */
    where: TemoignageWhereUniqueInput
    /**
     * In case the Temoignage found by the `where` argument doesn't exist, create a new Temoignage with this data.
     */
    create: XOR<TemoignageCreateInput, TemoignageUncheckedCreateInput>
    /**
     * In case the Temoignage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemoignageUpdateInput, TemoignageUncheckedUpdateInput>
  }


  /**
   * Temoignage delete
   */
  export type TemoignageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Temoignage
     */
    select?: TemoignageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemoignageInclude | null
    /**
     * Filter which Temoignage to delete.
     */
    where: TemoignageWhereUniqueInput
  }


  /**
   * Temoignage deleteMany
   */
  export type TemoignageDeleteManyArgs = {
    /**
     * Filter which Temoignages to delete
     */
    where?: TemoignageWhereInput
  }


  /**
   * Temoignage findRaw
   */
  export type TemoignageFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Temoignage aggregateRaw
   */
  export type TemoignageAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Temoignage without action
   */
  export type TemoignageArgs = {
    /**
     * Select specific fields to fetch from the Temoignage
     */
    select?: TemoignageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemoignageInclude | null
  }



  /**
   * Model Offer
   */


  export type AggregateOffer = {
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  export type OfferAvgAggregateOutputType = {
    price: number | null
    priceThreeMonth: number | null
    numberMysteryBoxBronze: number | null
    numberMysteryBoxSylver: number | null
    numberMysteryBoxGold: number | null
    duration: number | null
  }

  export type OfferSumAggregateOutputType = {
    price: number | null
    priceThreeMonth: number | null
    numberMysteryBoxBronze: number | null
    numberMysteryBoxSylver: number | null
    numberMysteryBoxGold: number | null
    duration: number | null
  }

  export type OfferMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    priceThreeMonth: number | null
    color: string | null
    numberMysteryBoxBronze: number | null
    numberMysteryBoxSylver: number | null
    numberMysteryBoxGold: number | null
    isAwardLevelActive: boolean | null
    isWeeklyAwardActive: boolean | null
    isStandardSupportActive: boolean | null
    isVIPSupportActive: boolean | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    priceThreeMonth: number | null
    color: string | null
    numberMysteryBoxBronze: number | null
    numberMysteryBoxSylver: number | null
    numberMysteryBoxGold: number | null
    isAwardLevelActive: boolean | null
    isWeeklyAwardActive: boolean | null
    isStandardSupportActive: boolean | null
    isVIPSupportActive: boolean | null
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferCountAggregateOutputType = {
    id: number
    name: number
    price: number
    priceThreeMonth: number
    color: number
    numberMysteryBoxBronze: number
    numberMysteryBoxSylver: number
    numberMysteryBoxGold: number
    isAwardLevelActive: number
    isWeeklyAwardActive: number
    isStandardSupportActive: number
    isVIPSupportActive: number
    duration: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OfferAvgAggregateInputType = {
    price?: true
    priceThreeMonth?: true
    numberMysteryBoxBronze?: true
    numberMysteryBoxSylver?: true
    numberMysteryBoxGold?: true
    duration?: true
  }

  export type OfferSumAggregateInputType = {
    price?: true
    priceThreeMonth?: true
    numberMysteryBoxBronze?: true
    numberMysteryBoxSylver?: true
    numberMysteryBoxGold?: true
    duration?: true
  }

  export type OfferMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    priceThreeMonth?: true
    color?: true
    numberMysteryBoxBronze?: true
    numberMysteryBoxSylver?: true
    numberMysteryBoxGold?: true
    isAwardLevelActive?: true
    isWeeklyAwardActive?: true
    isStandardSupportActive?: true
    isVIPSupportActive?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    priceThreeMonth?: true
    color?: true
    numberMysteryBoxBronze?: true
    numberMysteryBoxSylver?: true
    numberMysteryBoxGold?: true
    isAwardLevelActive?: true
    isWeeklyAwardActive?: true
    isStandardSupportActive?: true
    isVIPSupportActive?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    priceThreeMonth?: true
    color?: true
    numberMysteryBoxBronze?: true
    numberMysteryBoxSylver?: true
    numberMysteryBoxGold?: true
    isAwardLevelActive?: true
    isWeeklyAwardActive?: true
    isStandardSupportActive?: true
    isVIPSupportActive?: true
    duration?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OfferAggregateArgs = {
    /**
     * Filter which Offer to aggregate.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: Enumerable<OfferOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Offers
    **/
    _count?: true | OfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferMaxAggregateInputType
  }

  export type GetOfferAggregateType<T extends OfferAggregateArgs> = {
        [P in keyof T & keyof AggregateOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffer[P]>
      : GetScalarType<T[P], AggregateOffer[P]>
  }




  export type OfferGroupByArgs = {
    where?: OfferWhereInput
    orderBy?: Enumerable<OfferOrderByWithAggregationInput>
    by: OfferScalarFieldEnum[]
    having?: OfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferCountAggregateInputType | true
    _avg?: OfferAvgAggregateInputType
    _sum?: OfferSumAggregateInputType
    _min?: OfferMinAggregateInputType
    _max?: OfferMaxAggregateInputType
  }


  export type OfferGroupByOutputType = {
    id: string
    name: string
    price: number
    priceThreeMonth: number | null
    color: string | null
    numberMysteryBoxBronze: number
    numberMysteryBoxSylver: number
    numberMysteryBoxGold: number
    isAwardLevelActive: boolean
    isWeeklyAwardActive: boolean
    isStandardSupportActive: boolean
    isVIPSupportActive: boolean
    duration: number | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  type GetOfferGroupByPayload<T extends OfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferGroupByOutputType[P]>
            : GetScalarType<T[P], OfferGroupByOutputType[P]>
        }
      >
    >


  export type OfferSelect = {
    id?: boolean
    name?: boolean
    price?: boolean
    priceThreeMonth?: boolean
    color?: boolean
    numberMysteryBoxBronze?: boolean
    numberMysteryBoxSylver?: boolean
    numberMysteryBoxGold?: boolean
    isAwardLevelActive?: boolean
    isWeeklyAwardActive?: boolean
    isStandardSupportActive?: boolean
    isVIPSupportActive?: boolean
    duration?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | Offer$subscriptionArgs
    bannerImage?: boolean | Offer$bannerImageArgs
    transaction?: boolean | Offer$transactionArgs
    _count?: boolean | OfferCountOutputTypeArgs
  }


  export type OfferInclude = {
    subscription?: boolean | Offer$subscriptionArgs
    bannerImage?: boolean | Offer$bannerImageArgs
    transaction?: boolean | Offer$transactionArgs
    _count?: boolean | OfferCountOutputTypeArgs
  }

  export type OfferGetPayload<S extends boolean | null | undefined | OfferArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Offer :
    S extends undefined ? never :
    S extends { include: any } & (OfferArgs | OfferFindManyArgs)
    ? Offer  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'subscription' ? Array < SubscriptionGetPayload<S['include'][P]>>  :
        P extends 'bannerImage' ? Array < BannerImageGetPayload<S['include'][P]>>  :
        P extends 'transaction' ? Array < TransactionGetPayload<S['include'][P]>>  :
        P extends '_count' ? OfferCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (OfferArgs | OfferFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'subscription' ? Array < SubscriptionGetPayload<S['select'][P]>>  :
        P extends 'bannerImage' ? Array < BannerImageGetPayload<S['select'][P]>>  :
        P extends 'transaction' ? Array < TransactionGetPayload<S['select'][P]>>  :
        P extends '_count' ? OfferCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Offer ? Offer[P] : never
  } 
      : Offer


  type OfferCountArgs = 
    Omit<OfferFindManyArgs, 'select' | 'include'> & {
      select?: OfferCountAggregateInputType | true
    }

  export interface OfferDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Offer that matches the filter.
     * @param {OfferFindUniqueArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OfferFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OfferFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Offer'> extends True ? Prisma__OfferClient<OfferGetPayload<T>> : Prisma__OfferClient<OfferGetPayload<T> | null, null>

    /**
     * Find one Offer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OfferFindUniqueOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OfferFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OfferFindUniqueOrThrowArgs>
    ): Prisma__OfferClient<OfferGetPayload<T>>

    /**
     * Find the first Offer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OfferFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OfferFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Offer'> extends True ? Prisma__OfferClient<OfferGetPayload<T>> : Prisma__OfferClient<OfferGetPayload<T> | null, null>

    /**
     * Find the first Offer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OfferFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OfferFindFirstOrThrowArgs>
    ): Prisma__OfferClient<OfferGetPayload<T>>

    /**
     * Find zero or more Offers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offers
     * const offers = await prisma.offer.findMany()
     * 
     * // Get first 10 Offers
     * const offers = await prisma.offer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offerWithIdOnly = await prisma.offer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OfferFindManyArgs>(
      args?: SelectSubset<T, OfferFindManyArgs>
    ): Prisma.PrismaPromise<Array<OfferGetPayload<T>>>

    /**
     * Create a Offer.
     * @param {OfferCreateArgs} args - Arguments to create a Offer.
     * @example
     * // Create one Offer
     * const Offer = await prisma.offer.create({
     *   data: {
     *     // ... data to create a Offer
     *   }
     * })
     * 
    **/
    create<T extends OfferCreateArgs>(
      args: SelectSubset<T, OfferCreateArgs>
    ): Prisma__OfferClient<OfferGetPayload<T>>

    /**
     * Create many Offers.
     *     @param {OfferCreateManyArgs} args - Arguments to create many Offers.
     *     @example
     *     // Create many Offers
     *     const offer = await prisma.offer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OfferCreateManyArgs>(
      args?: SelectSubset<T, OfferCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Offer.
     * @param {OfferDeleteArgs} args - Arguments to delete one Offer.
     * @example
     * // Delete one Offer
     * const Offer = await prisma.offer.delete({
     *   where: {
     *     // ... filter to delete one Offer
     *   }
     * })
     * 
    **/
    delete<T extends OfferDeleteArgs>(
      args: SelectSubset<T, OfferDeleteArgs>
    ): Prisma__OfferClient<OfferGetPayload<T>>

    /**
     * Update one Offer.
     * @param {OfferUpdateArgs} args - Arguments to update one Offer.
     * @example
     * // Update one Offer
     * const offer = await prisma.offer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OfferUpdateArgs>(
      args: SelectSubset<T, OfferUpdateArgs>
    ): Prisma__OfferClient<OfferGetPayload<T>>

    /**
     * Delete zero or more Offers.
     * @param {OfferDeleteManyArgs} args - Arguments to filter Offers to delete.
     * @example
     * // Delete a few Offers
     * const { count } = await prisma.offer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OfferDeleteManyArgs>(
      args?: SelectSubset<T, OfferDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offers
     * const offer = await prisma.offer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OfferUpdateManyArgs>(
      args: SelectSubset<T, OfferUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Offer.
     * @param {OfferUpsertArgs} args - Arguments to update or create a Offer.
     * @example
     * // Update or create a Offer
     * const offer = await prisma.offer.upsert({
     *   create: {
     *     // ... data to create a Offer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offer we want to update
     *   }
     * })
    **/
    upsert<T extends OfferUpsertArgs>(
      args: SelectSubset<T, OfferUpsertArgs>
    ): Prisma__OfferClient<OfferGetPayload<T>>

    /**
     * Find zero or more Offers that matches the filter.
     * @param {OfferFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const offer = await prisma.offer.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: OfferFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Offer.
     * @param {OfferAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const offer = await prisma.offer.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: OfferAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferCountArgs} args - Arguments to filter Offers to count.
     * @example
     * // Count the number of Offers
     * const count = await prisma.offer.count({
     *   where: {
     *     // ... the filter for the Offers we want to count
     *   }
     * })
    **/
    count<T extends OfferCountArgs>(
      args?: Subset<T, OfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferAggregateArgs>(args: Subset<T, OfferAggregateArgs>): Prisma.PrismaPromise<GetOfferAggregateType<T>>

    /**
     * Group by Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferGroupByArgs['orderBy'] }
        : { orderBy?: OfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Offer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OfferClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    subscription<T extends Offer$subscriptionArgs= {}>(args?: Subset<T, Offer$subscriptionArgs>): Prisma.PrismaPromise<Array<SubscriptionGetPayload<T>>| Null>;

    bannerImage<T extends Offer$bannerImageArgs= {}>(args?: Subset<T, Offer$bannerImageArgs>): Prisma.PrismaPromise<Array<BannerImageGetPayload<T>>| Null>;

    transaction<T extends Offer$transactionArgs= {}>(args?: Subset<T, Offer$transactionArgs>): Prisma.PrismaPromise<Array<TransactionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Offer base type for findUnique actions
   */
  export type OfferFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferInclude | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer findUnique
   */
  export interface OfferFindUniqueArgs extends OfferFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Offer findUniqueOrThrow
   */
  export type OfferFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferInclude | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }


  /**
   * Offer base type for findFirst actions
   */
  export type OfferFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferInclude | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: Enumerable<OfferOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: Enumerable<OfferScalarFieldEnum>
  }

  /**
   * Offer findFirst
   */
  export interface OfferFindFirstArgs extends OfferFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Offer findFirstOrThrow
   */
  export type OfferFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferInclude | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: Enumerable<OfferOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: Enumerable<OfferScalarFieldEnum>
  }


  /**
   * Offer findMany
   */
  export type OfferFindManyArgs = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferInclude | null
    /**
     * Filter, which Offers to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: Enumerable<OfferOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    distinct?: Enumerable<OfferScalarFieldEnum>
  }


  /**
   * Offer create
   */
  export type OfferCreateArgs = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferInclude | null
    /**
     * The data needed to create a Offer.
     */
    data: XOR<OfferCreateInput, OfferUncheckedCreateInput>
  }


  /**
   * Offer createMany
   */
  export type OfferCreateManyArgs = {
    /**
     * The data used to create many Offers.
     */
    data: Enumerable<OfferCreateManyInput>
  }


  /**
   * Offer update
   */
  export type OfferUpdateArgs = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferInclude | null
    /**
     * The data needed to update a Offer.
     */
    data: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
    /**
     * Choose, which Offer to update.
     */
    where: OfferWhereUniqueInput
  }


  /**
   * Offer updateMany
   */
  export type OfferUpdateManyArgs = {
    /**
     * The data used to update Offers.
     */
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyInput>
    /**
     * Filter which Offers to update
     */
    where?: OfferWhereInput
  }


  /**
   * Offer upsert
   */
  export type OfferUpsertArgs = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferInclude | null
    /**
     * The filter to search for the Offer to update in case it exists.
     */
    where: OfferWhereUniqueInput
    /**
     * In case the Offer found by the `where` argument doesn't exist, create a new Offer with this data.
     */
    create: XOR<OfferCreateInput, OfferUncheckedCreateInput>
    /**
     * In case the Offer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
  }


  /**
   * Offer delete
   */
  export type OfferDeleteArgs = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferInclude | null
    /**
     * Filter which Offer to delete.
     */
    where: OfferWhereUniqueInput
  }


  /**
   * Offer deleteMany
   */
  export type OfferDeleteManyArgs = {
    /**
     * Filter which Offers to delete
     */
    where?: OfferWhereInput
  }


  /**
   * Offer findRaw
   */
  export type OfferFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Offer aggregateRaw
   */
  export type OfferAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Offer.subscription
   */
  export type Offer$subscriptionArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
    where?: SubscriptionWhereInput
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SubscriptionScalarFieldEnum>
  }


  /**
   * Offer.bannerImage
   */
  export type Offer$bannerImageArgs = {
    /**
     * Select specific fields to fetch from the BannerImage
     */
    select?: BannerImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BannerImageInclude | null
    where?: BannerImageWhereInput
    orderBy?: Enumerable<BannerImageOrderByWithRelationInput>
    cursor?: BannerImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BannerImageScalarFieldEnum>
  }


  /**
   * Offer.transaction
   */
  export type Offer$transactionArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude | null
    where?: TransactionWhereInput
    orderBy?: Enumerable<TransactionOrderByWithRelationInput>
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * Offer without action
   */
  export type OfferArgs = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OfferInclude | null
  }



  /**
   * Model Subscription
   */


  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    durationType: EnumPriceSubscription | null
    status: EnumStatusSubscription | null
    autoRenewal: boolean | null
    userId: string | null
    offerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    startDate: Date | null
    endDate: Date | null
    durationType: EnumPriceSubscription | null
    status: EnumStatusSubscription | null
    autoRenewal: boolean | null
    userId: string | null
    offerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    startDate: number
    endDate: number
    durationType: number
    status: number
    autoRenewal: number
    userId: number
    offerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    durationType?: true
    status?: true
    autoRenewal?: true
    userId?: true
    offerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    durationType?: true
    status?: true
    autoRenewal?: true
    userId?: true
    offerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    startDate?: true
    endDate?: true
    durationType?: true
    status?: true
    autoRenewal?: true
    userId?: true
    offerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs = {
    where?: SubscriptionWhereInput
    orderBy?: Enumerable<SubscriptionOrderByWithAggregationInput>
    by: SubscriptionScalarFieldEnum[]
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }


  export type SubscriptionGroupByOutputType = {
    id: string
    startDate: Date
    endDate: Date
    durationType: EnumPriceSubscription | null
    status: EnumStatusSubscription | null
    autoRenewal: boolean
    userId: string
    offerId: string
    createdAt: Date | null
    updatedAt: Date | null
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect = {
    id?: boolean
    startDate?: boolean
    endDate?: boolean
    durationType?: boolean
    status?: boolean
    autoRenewal?: boolean
    userId?: boolean
    offerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
    offer?: boolean | OfferArgs
  }


  export type SubscriptionInclude = {
    user?: boolean | UserArgs
    offer?: boolean | OfferArgs
  }

  export type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Subscription :
    S extends undefined ? never :
    S extends { include: any } & (SubscriptionArgs | SubscriptionFindManyArgs)
    ? Subscription  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'offer' ? OfferGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SubscriptionArgs | SubscriptionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'offer' ? OfferGetPayload<S['select'][P]> :  P extends keyof Subscription ? Subscription[P] : never
  } 
      : Subscription


  type SubscriptionCountArgs = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubscriptionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubscriptionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Subscription'> extends True ? Prisma__SubscriptionClient<SubscriptionGetPayload<T>> : Prisma__SubscriptionClient<SubscriptionGetPayload<T> | null, null>

    /**
     * Find one Subscription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs>
    ): Prisma__SubscriptionClient<SubscriptionGetPayload<T>>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubscriptionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubscriptionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Subscription'> extends True ? Prisma__SubscriptionClient<SubscriptionGetPayload<T>> : Prisma__SubscriptionClient<SubscriptionGetPayload<T> | null, null>

    /**
     * Find the first Subscription that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs>
    ): Prisma__SubscriptionClient<SubscriptionGetPayload<T>>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubscriptionFindManyArgs>(
      args?: SelectSubset<T, SubscriptionFindManyArgs>
    ): Prisma.PrismaPromise<Array<SubscriptionGetPayload<T>>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
    **/
    create<T extends SubscriptionCreateArgs>(
      args: SelectSubset<T, SubscriptionCreateArgs>
    ): Prisma__SubscriptionClient<SubscriptionGetPayload<T>>

    /**
     * Create many Subscriptions.
     *     @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     *     @example
     *     // Create many Subscriptions
     *     const subscription = await prisma.subscription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubscriptionCreateManyArgs>(
      args?: SelectSubset<T, SubscriptionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
    **/
    delete<T extends SubscriptionDeleteArgs>(
      args: SelectSubset<T, SubscriptionDeleteArgs>
    ): Prisma__SubscriptionClient<SubscriptionGetPayload<T>>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubscriptionUpdateArgs>(
      args: SelectSubset<T, SubscriptionUpdateArgs>
    ): Prisma__SubscriptionClient<SubscriptionGetPayload<T>>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubscriptionDeleteManyArgs>(
      args?: SelectSubset<T, SubscriptionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubscriptionUpdateManyArgs>(
      args: SelectSubset<T, SubscriptionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
    **/
    upsert<T extends SubscriptionUpsertArgs>(
      args: SelectSubset<T, SubscriptionUpsertArgs>
    ): Prisma__SubscriptionClient<SubscriptionGetPayload<T>>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * @param {SubscriptionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const subscription = await prisma.subscription.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: SubscriptionFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Subscription.
     * @param {SubscriptionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const subscription = await prisma.subscription.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: SubscriptionAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubscriptionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    offer<T extends OfferArgs= {}>(args?: Subset<T, OfferArgs>): Prisma__OfferClient<OfferGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Subscription base type for findUnique actions
   */
  export type SubscriptionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUnique
   */
  export interface SubscriptionFindUniqueArgs extends SubscriptionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription base type for findFirst actions
   */
  export type SubscriptionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: Enumerable<SubscriptionScalarFieldEnum>
  }

  /**
   * Subscription findFirst
   */
  export interface SubscriptionFindFirstArgs extends SubscriptionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: Enumerable<SubscriptionScalarFieldEnum>
  }


  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: Enumerable<SubscriptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: Enumerable<SubscriptionScalarFieldEnum>
  }


  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }


  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs = {
    /**
     * The data used to create many Subscriptions.
     */
    data: Enumerable<SubscriptionCreateManyInput>
  }


  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }


  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }


  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }


  /**
   * Subscription findRaw
   */
  export type SubscriptionFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Subscription aggregateRaw
   */
  export type SubscriptionAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Subscription without action
   */
  export type SubscriptionArgs = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude | null
  }



  /**
   * Model Game
   */


  export type AggregateGame = {
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  export type GameAvgAggregateOutputType = {
    gainPercentage: number | null
    gainDraw: number | null
  }

  export type GameSumAggregateOutputType = {
    gainPercentage: number | null
    gainDraw: number | null
  }

  export type GameMinAggregateOutputType = {
    id: string | null
    reference: string | null
    startDate: Date | null
    endDate: Date | null
    status: EnumStatusGame | null
    version: EnumVersionGame | null
    type: EnumTypeGame | null
    userBoxId: string | null
    patronageId: string | null
    gainPercentage: number | null
    gainDraw: number | null
    articleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameMaxAggregateOutputType = {
    id: string | null
    reference: string | null
    startDate: Date | null
    endDate: Date | null
    status: EnumStatusGame | null
    version: EnumVersionGame | null
    type: EnumTypeGame | null
    userBoxId: string | null
    patronageId: string | null
    gainPercentage: number | null
    gainDraw: number | null
    articleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameCountAggregateOutputType = {
    id: number
    reference: number
    startDate: number
    endDate: number
    status: number
    version: number
    type: number
    userBoxId: number
    patronageId: number
    gainPercentage: number
    gainDraw: number
    articleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameAvgAggregateInputType = {
    gainPercentage?: true
    gainDraw?: true
  }

  export type GameSumAggregateInputType = {
    gainPercentage?: true
    gainDraw?: true
  }

  export type GameMinAggregateInputType = {
    id?: true
    reference?: true
    startDate?: true
    endDate?: true
    status?: true
    version?: true
    type?: true
    userBoxId?: true
    patronageId?: true
    gainPercentage?: true
    gainDraw?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameMaxAggregateInputType = {
    id?: true
    reference?: true
    startDate?: true
    endDate?: true
    status?: true
    version?: true
    type?: true
    userBoxId?: true
    patronageId?: true
    gainPercentage?: true
    gainDraw?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameCountAggregateInputType = {
    id?: true
    reference?: true
    startDate?: true
    endDate?: true
    status?: true
    version?: true
    type?: true
    userBoxId?: true
    patronageId?: true
    gainPercentage?: true
    gainDraw?: true
    articleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameAggregateArgs = {
    /**
     * Filter which Game to aggregate.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: Enumerable<GameOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Games
    **/
    _count?: true | GameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameMaxAggregateInputType
  }

  export type GetGameAggregateType<T extends GameAggregateArgs> = {
        [P in keyof T & keyof AggregateGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame[P]>
      : GetScalarType<T[P], AggregateGame[P]>
  }




  export type GameGroupByArgs = {
    where?: GameWhereInput
    orderBy?: Enumerable<GameOrderByWithAggregationInput>
    by: GameScalarFieldEnum[]
    having?: GameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCountAggregateInputType | true
    _avg?: GameAvgAggregateInputType
    _sum?: GameSumAggregateInputType
    _min?: GameMinAggregateInputType
    _max?: GameMaxAggregateInputType
  }


  export type GameGroupByOutputType = {
    id: string
    reference: string
    startDate: Date
    endDate: Date | null
    status: EnumStatusGame
    version: EnumVersionGame | null
    type: EnumTypeGame | null
    userBoxId: string | null
    patronageId: string | null
    gainPercentage: number | null
    gainDraw: number | null
    articleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  type GetGameGroupByPayload<T extends GameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<GameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameGroupByOutputType[P]>
            : GetScalarType<T[P], GameGroupByOutputType[P]>
        }
      >
    >


  export type GameSelect = {
    id?: boolean
    reference?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    version?: boolean
    type?: boolean
    userBoxId?: boolean
    patronageId?: boolean
    gainPercentage?: boolean
    gainDraw?: boolean
    articleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userBox?: boolean | UserBoxArgs
    patronage?: boolean | PatronageArgs
    article?: boolean | ArticleArgs
    shoppingCart?: boolean | ShoppingCartArgs
    transaction?: boolean | Game$transactionArgs
    _count?: boolean | GameCountOutputTypeArgs
  }


  export type GameInclude = {
    userBox?: boolean | UserBoxArgs
    patronage?: boolean | PatronageArgs
    article?: boolean | ArticleArgs
    shoppingCart?: boolean | ShoppingCartArgs
    transaction?: boolean | Game$transactionArgs
    _count?: boolean | GameCountOutputTypeArgs
  }

  export type GameGetPayload<S extends boolean | null | undefined | GameArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Game :
    S extends undefined ? never :
    S extends { include: any } & (GameArgs | GameFindManyArgs)
    ? Game  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'userBox' ? UserBoxGetPayload<S['include'][P]> | null :
        P extends 'patronage' ? PatronageGetPayload<S['include'][P]> | null :
        P extends 'article' ? ArticleGetPayload<S['include'][P]> | null :
        P extends 'shoppingCart' ? ShoppingCartGetPayload<S['include'][P]> | null :
        P extends 'transaction' ? Array < TransactionGetPayload<S['include'][P]>>  :
        P extends '_count' ? GameCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (GameArgs | GameFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'userBox' ? UserBoxGetPayload<S['select'][P]> | null :
        P extends 'patronage' ? PatronageGetPayload<S['select'][P]> | null :
        P extends 'article' ? ArticleGetPayload<S['select'][P]> | null :
        P extends 'shoppingCart' ? ShoppingCartGetPayload<S['select'][P]> | null :
        P extends 'transaction' ? Array < TransactionGetPayload<S['select'][P]>>  :
        P extends '_count' ? GameCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Game ? Game[P] : never
  } 
      : Game


  type GameCountArgs = 
    Omit<GameFindManyArgs, 'select' | 'include'> & {
      select?: GameCountAggregateInputType | true
    }

  export interface GameDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Game that matches the filter.
     * @param {GameFindUniqueArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GameFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GameFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Game'> extends True ? Prisma__GameClient<GameGetPayload<T>> : Prisma__GameClient<GameGetPayload<T> | null, null>

    /**
     * Find one Game that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GameFindUniqueOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GameFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, GameFindUniqueOrThrowArgs>
    ): Prisma__GameClient<GameGetPayload<T>>

    /**
     * Find the first Game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GameFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GameFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Game'> extends True ? Prisma__GameClient<GameGetPayload<T>> : Prisma__GameClient<GameGetPayload<T> | null, null>

    /**
     * Find the first Game that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GameFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GameFindFirstOrThrowArgs>
    ): Prisma__GameClient<GameGetPayload<T>>

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.game.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameWithIdOnly = await prisma.game.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GameFindManyArgs>(
      args?: SelectSubset<T, GameFindManyArgs>
    ): Prisma.PrismaPromise<Array<GameGetPayload<T>>>

    /**
     * Create a Game.
     * @param {GameCreateArgs} args - Arguments to create a Game.
     * @example
     * // Create one Game
     * const Game = await prisma.game.create({
     *   data: {
     *     // ... data to create a Game
     *   }
     * })
     * 
    **/
    create<T extends GameCreateArgs>(
      args: SelectSubset<T, GameCreateArgs>
    ): Prisma__GameClient<GameGetPayload<T>>

    /**
     * Create many Games.
     *     @param {GameCreateManyArgs} args - Arguments to create many Games.
     *     @example
     *     // Create many Games
     *     const game = await prisma.game.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GameCreateManyArgs>(
      args?: SelectSubset<T, GameCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Game.
     * @param {GameDeleteArgs} args - Arguments to delete one Game.
     * @example
     * // Delete one Game
     * const Game = await prisma.game.delete({
     *   where: {
     *     // ... filter to delete one Game
     *   }
     * })
     * 
    **/
    delete<T extends GameDeleteArgs>(
      args: SelectSubset<T, GameDeleteArgs>
    ): Prisma__GameClient<GameGetPayload<T>>

    /**
     * Update one Game.
     * @param {GameUpdateArgs} args - Arguments to update one Game.
     * @example
     * // Update one Game
     * const game = await prisma.game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GameUpdateArgs>(
      args: SelectSubset<T, GameUpdateArgs>
    ): Prisma__GameClient<GameGetPayload<T>>

    /**
     * Delete zero or more Games.
     * @param {GameDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GameDeleteManyArgs>(
      args?: SelectSubset<T, GameDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GameUpdateManyArgs>(
      args: SelectSubset<T, GameUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Game.
     * @param {GameUpsertArgs} args - Arguments to update or create a Game.
     * @example
     * // Update or create a Game
     * const game = await prisma.game.upsert({
     *   create: {
     *     // ... data to create a Game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game we want to update
     *   }
     * })
    **/
    upsert<T extends GameUpsertArgs>(
      args: SelectSubset<T, GameUpsertArgs>
    ): Prisma__GameClient<GameGetPayload<T>>

    /**
     * Find zero or more Games that matches the filter.
     * @param {GameFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const game = await prisma.game.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: GameFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Game.
     * @param {GameAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const game = await prisma.game.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: GameAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.game.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends GameCountArgs>(
      args?: Subset<T, GameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAggregateArgs>(args: Subset<T, GameAggregateArgs>): Prisma.PrismaPromise<GetGameAggregateType<T>>

    /**
     * Group by Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameGroupByArgs['orderBy'] }
        : { orderBy?: GameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GameClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    userBox<T extends UserBoxArgs= {}>(args?: Subset<T, UserBoxArgs>): Prisma__UserBoxClient<UserBoxGetPayload<T> | Null>;

    patronage<T extends PatronageArgs= {}>(args?: Subset<T, PatronageArgs>): Prisma__PatronageClient<PatronageGetPayload<T> | Null>;

    article<T extends ArticleArgs= {}>(args?: Subset<T, ArticleArgs>): Prisma__ArticleClient<ArticleGetPayload<T> | Null>;

    shoppingCart<T extends ShoppingCartArgs= {}>(args?: Subset<T, ShoppingCartArgs>): Prisma__ShoppingCartClient<ShoppingCartGetPayload<T> | Null>;

    transaction<T extends Game$transactionArgs= {}>(args?: Subset<T, Game$transactionArgs>): Prisma.PrismaPromise<Array<TransactionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Game base type for findUnique actions
   */
  export type GameFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findUnique
   */
  export interface GameFindUniqueArgs extends GameFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Game findUniqueOrThrow
   */
  export type GameFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }


  /**
   * Game base type for findFirst actions
   */
  export type GameFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: Enumerable<GameOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: Enumerable<GameScalarFieldEnum>
  }

  /**
   * Game findFirst
   */
  export interface GameFindFirstArgs extends GameFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Game findFirstOrThrow
   */
  export type GameFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: Enumerable<GameOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: Enumerable<GameScalarFieldEnum>
  }


  /**
   * Game findMany
   */
  export type GameFindManyArgs = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude | null
    /**
     * Filter, which Games to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: Enumerable<GameOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    distinct?: Enumerable<GameScalarFieldEnum>
  }


  /**
   * Game create
   */
  export type GameCreateArgs = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude | null
    /**
     * The data needed to create a Game.
     */
    data: XOR<GameCreateInput, GameUncheckedCreateInput>
  }


  /**
   * Game createMany
   */
  export type GameCreateManyArgs = {
    /**
     * The data used to create many Games.
     */
    data: Enumerable<GameCreateManyInput>
  }


  /**
   * Game update
   */
  export type GameUpdateArgs = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude | null
    /**
     * The data needed to update a Game.
     */
    data: XOR<GameUpdateInput, GameUncheckedUpdateInput>
    /**
     * Choose, which Game to update.
     */
    where: GameWhereUniqueInput
  }


  /**
   * Game updateMany
   */
  export type GameUpdateManyArgs = {
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
  }


  /**
   * Game upsert
   */
  export type GameUpsertArgs = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude | null
    /**
     * The filter to search for the Game to update in case it exists.
     */
    where: GameWhereUniqueInput
    /**
     * In case the Game found by the `where` argument doesn't exist, create a new Game with this data.
     */
    create: XOR<GameCreateInput, GameUncheckedCreateInput>
    /**
     * In case the Game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameUpdateInput, GameUncheckedUpdateInput>
  }


  /**
   * Game delete
   */
  export type GameDeleteArgs = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude | null
    /**
     * Filter which Game to delete.
     */
    where: GameWhereUniqueInput
  }


  /**
   * Game deleteMany
   */
  export type GameDeleteManyArgs = {
    /**
     * Filter which Games to delete
     */
    where?: GameWhereInput
  }


  /**
   * Game findRaw
   */
  export type GameFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Game aggregateRaw
   */
  export type GameAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Game.transaction
   */
  export type Game$transactionArgs = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TransactionInclude | null
    where?: TransactionWhereInput
    orderBy?: Enumerable<TransactionOrderByWithRelationInput>
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * Game without action
   */
  export type GameArgs = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GameInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AddressScalarFieldEnum: {
    id: 'id',
    firstAdress: 'firstAdress',
    secondAdress: 'secondAdress',
    zipCode: 'zipCode',
    city: 'city',
    region: 'region',
    country: 'country',
    additionnalInformation: 'additionnalInformation',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const ArticlePhotoScalarFieldEnum: {
    id: 'id',
    photoUrl: 'photoUrl',
    status: 'status',
    articleId: 'articleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ArticlePhotoScalarFieldEnum = (typeof ArticlePhotoScalarFieldEnum)[keyof typeof ArticlePhotoScalarFieldEnum]


  export const ArticleScalarFieldEnum: {
    id: 'id',
    reference: 'reference',
    designation: 'designation',
    type: 'type',
    size: 'size',
    color: 'color',
    productUrl: 'productUrl',
    observation: 'observation',
    winningChance: 'winningChance',
    providerId: 'providerId',
    unitySizeId: 'unitySizeId',
    subCategoryId: 'subCategoryId',
    boxId: 'boxId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ArticleScalarFieldEnum = (typeof ArticleScalarFieldEnum)[keyof typeof ArticleScalarFieldEnum]


  export const BankScalarFieldEnum: {
    id: 'id',
    accountNumber: 'accountNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankScalarFieldEnum = (typeof BankScalarFieldEnum)[keyof typeof BankScalarFieldEnum]


  export const BannerImageScalarFieldEnum: {
    id: 'id',
    bannerImgUrl: 'bannerImgUrl',
    bannerLink: 'bannerLink',
    type: 'type',
    boxId: 'boxId',
    offerId: 'offerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BannerImageScalarFieldEnum = (typeof BannerImageScalarFieldEnum)[keyof typeof BannerImageScalarFieldEnum]


  export const BoxArticleScalarFieldEnum: {
    id: 'id',
    winningChance: 'winningChance',
    boxId: 'boxId',
    articleId: 'articleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BoxArticleScalarFieldEnum = (typeof BoxArticleScalarFieldEnum)[keyof typeof BoxArticleScalarFieldEnum]


  export const BoxImageScalarFieldEnum: {
    id: 'id',
    photoUrl: 'photoUrl',
    status: 'status',
    boxId: 'boxId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BoxImageScalarFieldEnum = (typeof BoxImageScalarFieldEnum)[keyof typeof BoxImageScalarFieldEnum]


  export const BoxParamsScalarFieldEnum: {
    id: 'id',
    isBestSelling: 'isBestSelling',
    isRecommended: 'isRecommended',
    isNew: 'isNew',
    isBigPrice: 'isBigPrice',
    isSubsciptionBonus: 'isSubsciptionBonus',
    boxId: 'boxId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BoxParamsScalarFieldEnum = (typeof BoxParamsScalarFieldEnum)[keyof typeof BoxParamsScalarFieldEnum]


  export const BoxRewardLevelScalarFieldEnum: {
    id: 'id',
    boxId: 'boxId',
    rewardLevelId: 'rewardLevelId'
  };

  export type BoxRewardLevelScalarFieldEnum = (typeof BoxRewardLevelScalarFieldEnum)[keyof typeof BoxRewardLevelScalarFieldEnum]


  export const BoxScalarFieldEnum: {
    id: 'id',
    reference: 'reference',
    name: 'name',
    price: 'price',
    number: 'number',
    description: 'description',
    badge: 'badge',
    boxTypeId: 'boxTypeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BoxScalarFieldEnum = (typeof BoxScalarFieldEnum)[keyof typeof BoxScalarFieldEnum]


  export const BoxTypeScalarFieldEnum: {
    id: 'id',
    reference: 'reference',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BoxTypeScalarFieldEnum = (typeof BoxTypeScalarFieldEnum)[keyof typeof BoxTypeScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    reference: 'reference',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const CodeConfirmLoginScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    useId: 'useId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CodeConfirmLoginScalarFieldEnum = (typeof CodeConfirmLoginScalarFieldEnum)[keyof typeof CodeConfirmLoginScalarFieldEnum]


  export const CodeConfirmMailScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    useId: 'useId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CodeConfirmMailScalarFieldEnum = (typeof CodeConfirmMailScalarFieldEnum)[keyof typeof CodeConfirmMailScalarFieldEnum]


  export const DailyRewardScalarFieldEnum: {
    id: 'id',
    number: 'number',
    boxId: 'boxId'
  };

  export type DailyRewardScalarFieldEnum = (typeof DailyRewardScalarFieldEnum)[keyof typeof DailyRewardScalarFieldEnum]


  export const GameScalarFieldEnum: {
    id: 'id',
    reference: 'reference',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    version: 'version',
    type: 'type',
    userBoxId: 'userBoxId',
    patronageId: 'patronageId',
    gainPercentage: 'gainPercentage',
    gainDraw: 'gainDraw',
    articleId: 'articleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameScalarFieldEnum = (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum]


  export const HistoricalScalarFieldEnum: {
    id: 'id',
    date: 'date',
    description: 'description',
    userId: 'userId',
    action: 'action',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HistoricalScalarFieldEnum = (typeof HistoricalScalarFieldEnum)[keyof typeof HistoricalScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    message: 'message',
    sendingDate: 'sendingDate',
    senderId: 'senderId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const ModelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    keyword: 'keyword',
    permissionIDs: 'permissionIDs',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModelScalarFieldEnum = (typeof ModelScalarFieldEnum)[keyof typeof ModelScalarFieldEnum]


  export const NewsLetterScalarFieldEnum: {
    id: 'id',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NewsLetterScalarFieldEnum = (typeof NewsLetterScalarFieldEnum)[keyof typeof NewsLetterScalarFieldEnum]


  export const OfferScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    priceThreeMonth: 'priceThreeMonth',
    color: 'color',
    numberMysteryBoxBronze: 'numberMysteryBoxBronze',
    numberMysteryBoxSylver: 'numberMysteryBoxSylver',
    numberMysteryBoxGold: 'numberMysteryBoxGold',
    isAwardLevelActive: 'isAwardLevelActive',
    isWeeklyAwardActive: 'isWeeklyAwardActive',
    isStandardSupportActive: 'isStandardSupportActive',
    isVIPSupportActive: 'isVIPSupportActive',
    duration: 'duration',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OfferScalarFieldEnum = (typeof OfferScalarFieldEnum)[keyof typeof OfferScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    status: 'status',
    followedLink: 'followedLink',
    orderNumber: 'orderNumber',
    shoppingCartId: 'shoppingCartId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const PatronageScalarFieldEnum: {
    id: 'id',
    gainPercentage: 'gainPercentage',
    discountPercentage: 'discountPercentage',
    status: 'status',
    bonusEndDate: 'bonusEndDate',
    userParentId: 'userParentId',
    userChildId: 'userChildId',
    bonusCollect: 'bonusCollect',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatronageScalarFieldEnum = (typeof PatronageScalarFieldEnum)[keyof typeof PatronageScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    keyword: 'keyword',
    rulesIDs: 'rulesIDs',
    modelsIDs: 'modelsIDs',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    postUrl: 'postUrl',
    articleId: 'articleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const PriceScalarFieldEnum: {
    id: 'id',
    reference: 'reference',
    currentPrice: 'currentPrice',
    oldPrice: 'oldPrice',
    rate: 'rate',
    reduction: 'reduction',
    sellingPrice: 'sellingPrice',
    articleId: 'articleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PriceScalarFieldEnum = (typeof PriceScalarFieldEnum)[keyof typeof PriceScalarFieldEnum]


  export const ProviderScalarFieldEnum: {
    id: 'id',
    reference: 'reference',
    companyName: 'companyName',
    address: 'address',
    phone: 'phone',
    webSite: 'webSite',
    logo: 'logo',
    isPinned: 'isPinned',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProviderScalarFieldEnum = (typeof ProviderScalarFieldEnum)[keyof typeof ProviderScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const ReceiverScalarFieldEnum: {
    id: 'id',
    readingDate: 'readingDate',
    receiverId: 'receiverId',
    messageId: 'messageId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReceiverScalarFieldEnum = (typeof ReceiverScalarFieldEnum)[keyof typeof ReceiverScalarFieldEnum]


  export const RewardLevelScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    name: 'name',
    unlockThreshold: 'unlockThreshold',
    description: 'description'
  };

  export type RewardLevelScalarFieldEnum = (typeof RewardLevelScalarFieldEnum)[keyof typeof RewardLevelScalarFieldEnum]


  export const RuleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    keyword: 'keyword',
    permissionIDs: 'permissionIDs',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RuleScalarFieldEnum = (typeof RuleScalarFieldEnum)[keyof typeof RuleScalarFieldEnum]


  export const ShoppingCartScalarFieldEnum: {
    id: 'id',
    winningDate: 'winningDate',
    isClaimed: 'isClaimed',
    gameId: 'gameId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShoppingCartScalarFieldEnum = (typeof ShoppingCartScalarFieldEnum)[keyof typeof ShoppingCartScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SubCategoryScalarFieldEnum: {
    id: 'id',
    reference: 'reference',
    name: 'name',
    categoryId: 'categoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubCategoryScalarFieldEnum = (typeof SubCategoryScalarFieldEnum)[keyof typeof SubCategoryScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    startDate: 'startDate',
    endDate: 'endDate',
    durationType: 'durationType',
    status: 'status',
    autoRenewal: 'autoRenewal',
    userId: 'userId',
    offerId: 'offerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const TemoignageScalarFieldEnum: {
    id: 'id',
    comment: 'comment',
    rating: 'rating',
    commentDate: 'commentDate',
    isToShow: 'isToShow',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TemoignageScalarFieldEnum = (typeof TemoignageScalarFieldEnum)[keyof typeof TemoignageScalarFieldEnum]


  export const TokenBlackListScalarFieldEnum: {
    id: 'id',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TokenBlackListScalarFieldEnum = (typeof TokenBlackListScalarFieldEnum)[keyof typeof TokenBlackListScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    date: 'date',
    amount: 'amount',
    status: 'status',
    boxId: 'boxId',
    walletId: 'walletId',
    offerId: 'offerId',
    shoppingCartId: 'shoppingCartId',
    bankId: 'bankId',
    gameId: 'gameId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const UnitySizeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    abbreviation: 'abbreviation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitySizeScalarFieldEnum = (typeof UnitySizeScalarFieldEnum)[keyof typeof UnitySizeScalarFieldEnum]


  export const UserBoxScalarFieldEnum: {
    id: 'id',
    type: 'type',
    duration: 'duration',
    dayNumber: 'dayNumber',
    isPlayed: 'isPlayed',
    isLocked: 'isLocked',
    playedDate: 'playedDate',
    activationDate: 'activationDate',
    deactivationDate: 'deactivationDate',
    orderNumber: 'orderNumber',
    name: 'name',
    unlockThreshold: 'unlockThreshold',
    description: 'description',
    userId: 'userId',
    boxId: 'boxId',
    lot: 'lot',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserBoxScalarFieldEnum = (typeof UserBoxScalarFieldEnum)[keyof typeof UserBoxScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    username: 'username',
    photoUrl: 'photoUrl',
    email: 'email',
    isActif: 'isActif',
    isMember: 'isMember',
    isAdmin: 'isAdmin',
    emailIsVerified: 'emailIsVerified',
    twoAuthIsActive: 'twoAuthIsActive',
    phone: 'phone',
    gender: 'gender',
    birthDate: 'birthDate',
    password: 'password',
    socketId: 'socketId',
    refreshToken: 'refreshToken',
    supportingDocumentUrl: 'supportingDocumentUrl',
    isValideSupportingDocument: 'isValideSupportingDocument',
    registrationBonus: 'registrationBonus',
    latestConnectedDate: 'latestConnectedDate',
    signInCount: 'signInCount',
    lotCount: 'lotCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ruleId: 'ruleId',
    stripeCustomerId: 'stripeCustomerId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    balance: 'balance',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringNullableFilter | string | null
    username?: StringFilter | string
    photoUrl?: StringNullableFilter | string | null
    email?: StringFilter | string
    isActif?: BoolFilter | boolean
    isMember?: BoolFilter | boolean
    isAdmin?: BoolFilter | boolean
    emailIsVerified?: BoolFilter | boolean
    twoAuthIsActive?: BoolFilter | boolean
    phone?: StringNullableFilter | string | null
    gender?: EnumEnumGenderNullableFilter | EnumGender | null
    birthDate?: DateTimeNullableFilter | Date | string | null
    password?: StringFilter | string
    socketId?: StringNullableFilter | string | null
    refreshToken?: StringNullableFilter | string | null
    supportingDocumentUrl?: StringNullableFilter | string | null
    isValideSupportingDocument?: BoolFilter | boolean
    registrationBonus?: FloatNullableFilter | number | null
    latestConnectedDate?: DateTimeNullableFilter | Date | string | null
    signInCount?: IntNullableFilter | number | null
    lotCount?: IntNullableFilter | number | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    ruleId?: StringNullableFilter | string | null
    stripeCustomerId?: StringNullableFilter | string | null
    rule?: XOR<RuleRelationFilter, RuleWhereInput> | null
    address?: XOR<AddressRelationFilter, AddressWhereInput> | null
    codeConfirmLogin?: CodeConfirmLoginListRelationFilter
    codeConfirmMail?: CodeConfirmMailListRelationFilter
    wallet?: XOR<WalletRelationFilter, WalletWhereInput> | null
    shoppingCart?: ShoppingCartListRelationFilter
    userBox?: UserBoxListRelationFilter
    historical?: HistoricalListRelationFilter
    message?: MessageListRelationFilter
    receiver?: ReceiverListRelationFilter
    temoignage?: TemoignageListRelationFilter
    subscription?: SubscriptionListRelationFilter
    patronage?: PatronageListRelationFilter
    userChild?: XOR<PatronageRelationFilter, PatronageWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    photoUrl?: SortOrder
    email?: SortOrder
    isActif?: SortOrder
    isMember?: SortOrder
    isAdmin?: SortOrder
    emailIsVerified?: SortOrder
    twoAuthIsActive?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    password?: SortOrder
    socketId?: SortOrder
    refreshToken?: SortOrder
    supportingDocumentUrl?: SortOrder
    isValideSupportingDocument?: SortOrder
    registrationBonus?: SortOrder
    latestConnectedDate?: SortOrder
    signInCount?: SortOrder
    lotCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ruleId?: SortOrder
    stripeCustomerId?: SortOrder
    rule?: RuleOrderByWithRelationInput
    address?: AddressOrderByWithRelationInput
    codeConfirmLogin?: CodeConfirmLoginOrderByRelationAggregateInput
    codeConfirmMail?: CodeConfirmMailOrderByRelationAggregateInput
    wallet?: WalletOrderByWithRelationInput
    shoppingCart?: ShoppingCartOrderByRelationAggregateInput
    userBox?: UserBoxOrderByRelationAggregateInput
    historical?: HistoricalOrderByRelationAggregateInput
    message?: MessageOrderByRelationAggregateInput
    receiver?: ReceiverOrderByRelationAggregateInput
    temoignage?: TemoignageOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByRelationAggregateInput
    patronage?: PatronageOrderByRelationAggregateInput
    userChild?: PatronageOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    username?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    photoUrl?: SortOrder
    email?: SortOrder
    isActif?: SortOrder
    isMember?: SortOrder
    isAdmin?: SortOrder
    emailIsVerified?: SortOrder
    twoAuthIsActive?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    password?: SortOrder
    socketId?: SortOrder
    refreshToken?: SortOrder
    supportingDocumentUrl?: SortOrder
    isValideSupportingDocument?: SortOrder
    registrationBonus?: SortOrder
    latestConnectedDate?: SortOrder
    signInCount?: SortOrder
    lotCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ruleId?: SortOrder
    stripeCustomerId?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringNullableWithAggregatesFilter | string | null
    username?: StringWithAggregatesFilter | string
    photoUrl?: StringNullableWithAggregatesFilter | string | null
    email?: StringWithAggregatesFilter | string
    isActif?: BoolWithAggregatesFilter | boolean
    isMember?: BoolWithAggregatesFilter | boolean
    isAdmin?: BoolWithAggregatesFilter | boolean
    emailIsVerified?: BoolWithAggregatesFilter | boolean
    twoAuthIsActive?: BoolWithAggregatesFilter | boolean
    phone?: StringNullableWithAggregatesFilter | string | null
    gender?: EnumEnumGenderNullableWithAggregatesFilter | EnumGender | null
    birthDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    password?: StringWithAggregatesFilter | string
    socketId?: StringNullableWithAggregatesFilter | string | null
    refreshToken?: StringNullableWithAggregatesFilter | string | null
    supportingDocumentUrl?: StringNullableWithAggregatesFilter | string | null
    isValideSupportingDocument?: BoolWithAggregatesFilter | boolean
    registrationBonus?: FloatNullableWithAggregatesFilter | number | null
    latestConnectedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    signInCount?: IntNullableWithAggregatesFilter | number | null
    lotCount?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    ruleId?: StringNullableWithAggregatesFilter | string | null
    stripeCustomerId?: StringNullableWithAggregatesFilter | string | null
  }

  export type PatronageWhereInput = {
    AND?: Enumerable<PatronageWhereInput>
    OR?: Enumerable<PatronageWhereInput>
    NOT?: Enumerable<PatronageWhereInput>
    id?: StringFilter | string
    gainPercentage?: FloatNullableFilter | number | null
    discountPercentage?: FloatNullableFilter | number | null
    status?: EnumEnumStatusPatronageNullableFilter | EnumStatusPatronage | null
    bonusEndDate?: DateTimeNullableFilter | Date | string | null
    userParentId?: StringFilter | string
    userChildId?: StringFilter | string
    bonusCollect?: BoolNullableFilter | boolean | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    userParent?: XOR<UserRelationFilter, UserWhereInput>
    userChild?: XOR<UserRelationFilter, UserWhereInput>
    game?: GameListRelationFilter
  }

  export type PatronageOrderByWithRelationInput = {
    id?: SortOrder
    gainPercentage?: SortOrder
    discountPercentage?: SortOrder
    status?: SortOrder
    bonusEndDate?: SortOrder
    userParentId?: SortOrder
    userChildId?: SortOrder
    bonusCollect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userParent?: UserOrderByWithRelationInput
    userChild?: UserOrderByWithRelationInput
    game?: GameOrderByRelationAggregateInput
  }

  export type PatronageWhereUniqueInput = {
    id?: string
    userChildId?: string
  }

  export type PatronageOrderByWithAggregationInput = {
    id?: SortOrder
    gainPercentage?: SortOrder
    discountPercentage?: SortOrder
    status?: SortOrder
    bonusEndDate?: SortOrder
    userParentId?: SortOrder
    userChildId?: SortOrder
    bonusCollect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PatronageCountOrderByAggregateInput
    _avg?: PatronageAvgOrderByAggregateInput
    _max?: PatronageMaxOrderByAggregateInput
    _min?: PatronageMinOrderByAggregateInput
    _sum?: PatronageSumOrderByAggregateInput
  }

  export type PatronageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PatronageScalarWhereWithAggregatesInput>
    OR?: Enumerable<PatronageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PatronageScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    gainPercentage?: FloatNullableWithAggregatesFilter | number | null
    discountPercentage?: FloatNullableWithAggregatesFilter | number | null
    status?: EnumEnumStatusPatronageNullableWithAggregatesFilter | EnumStatusPatronage | null
    bonusEndDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    userParentId?: StringWithAggregatesFilter | string
    userChildId?: StringWithAggregatesFilter | string
    bonusCollect?: BoolNullableWithAggregatesFilter | boolean | null
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type CodeConfirmLoginWhereInput = {
    AND?: Enumerable<CodeConfirmLoginWhereInput>
    OR?: Enumerable<CodeConfirmLoginWhereInput>
    NOT?: Enumerable<CodeConfirmLoginWhereInput>
    id?: StringFilter | string
    uuid?: StringFilter | string
    useId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CodeConfirmLoginOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    useId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CodeConfirmLoginWhereUniqueInput = {
    id?: string
    uuid?: string
  }

  export type CodeConfirmLoginOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    useId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CodeConfirmLoginCountOrderByAggregateInput
    _max?: CodeConfirmLoginMaxOrderByAggregateInput
    _min?: CodeConfirmLoginMinOrderByAggregateInput
  }

  export type CodeConfirmLoginScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CodeConfirmLoginScalarWhereWithAggregatesInput>
    OR?: Enumerable<CodeConfirmLoginScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CodeConfirmLoginScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    uuid?: StringWithAggregatesFilter | string
    useId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type CodeConfirmMailWhereInput = {
    AND?: Enumerable<CodeConfirmMailWhereInput>
    OR?: Enumerable<CodeConfirmMailWhereInput>
    NOT?: Enumerable<CodeConfirmMailWhereInput>
    id?: StringFilter | string
    uuid?: StringFilter | string
    useId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CodeConfirmMailOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    useId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CodeConfirmMailWhereUniqueInput = {
    id?: string
    uuid?: string
  }

  export type CodeConfirmMailOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    useId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CodeConfirmMailCountOrderByAggregateInput
    _max?: CodeConfirmMailMaxOrderByAggregateInput
    _min?: CodeConfirmMailMinOrderByAggregateInput
  }

  export type CodeConfirmMailScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CodeConfirmMailScalarWhereWithAggregatesInput>
    OR?: Enumerable<CodeConfirmMailScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CodeConfirmMailScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    uuid?: StringWithAggregatesFilter | string
    useId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type TokenBlackListWhereInput = {
    AND?: Enumerable<TokenBlackListWhereInput>
    OR?: Enumerable<TokenBlackListWhereInput>
    NOT?: Enumerable<TokenBlackListWhereInput>
    id?: StringFilter | string
    token?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type TokenBlackListOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TokenBlackListWhereUniqueInput = {
    id?: string
    token?: string
  }

  export type TokenBlackListOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TokenBlackListCountOrderByAggregateInput
    _max?: TokenBlackListMaxOrderByAggregateInput
    _min?: TokenBlackListMinOrderByAggregateInput
  }

  export type TokenBlackListScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TokenBlackListScalarWhereWithAggregatesInput>
    OR?: Enumerable<TokenBlackListScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TokenBlackListScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    token?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type RuleWhereInput = {
    AND?: Enumerable<RuleWhereInput>
    OR?: Enumerable<RuleWhereInput>
    NOT?: Enumerable<RuleWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    keyword?: StringFilter | string
    permissionIDs?: StringNullableListFilter
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    user?: UserListRelationFilter
    permissions?: PermissionListRelationFilter
  }

  export type RuleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    keyword?: SortOrder
    permissionIDs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByRelationAggregateInput
    permissions?: PermissionOrderByRelationAggregateInput
  }

  export type RuleWhereUniqueInput = {
    id?: string
    name?: string
    keyword?: string
  }

  export type RuleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    keyword?: SortOrder
    permissionIDs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RuleCountOrderByAggregateInput
    _max?: RuleMaxOrderByAggregateInput
    _min?: RuleMinOrderByAggregateInput
  }

  export type RuleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RuleScalarWhereWithAggregatesInput>
    OR?: Enumerable<RuleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RuleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    keyword?: StringWithAggregatesFilter | string
    permissionIDs?: StringNullableListFilter
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type PermissionWhereInput = {
    AND?: Enumerable<PermissionWhereInput>
    OR?: Enumerable<PermissionWhereInput>
    NOT?: Enumerable<PermissionWhereInput>
    id?: StringFilter | string
    name?: EnumEnumPermissionFilter | EnumPermission
    keyword?: StringFilter | string
    rulesIDs?: StringNullableListFilter
    modelsIDs?: StringNullableListFilter
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    rules?: RuleListRelationFilter
    models?: ModelListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    keyword?: SortOrder
    rulesIDs?: SortOrder
    modelsIDs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rules?: RuleOrderByRelationAggregateInput
    models?: ModelOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = {
    id?: string
    keyword?: string
  }

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    keyword?: SortOrder
    rulesIDs?: SortOrder
    modelsIDs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PermissionScalarWhereWithAggregatesInput>
    OR?: Enumerable<PermissionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PermissionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: EnumEnumPermissionWithAggregatesFilter | EnumPermission
    keyword?: StringWithAggregatesFilter | string
    rulesIDs?: StringNullableListFilter
    modelsIDs?: StringNullableListFilter
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ModelWhereInput = {
    AND?: Enumerable<ModelWhereInput>
    OR?: Enumerable<ModelWhereInput>
    NOT?: Enumerable<ModelWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    keyword?: StringFilter | string
    permissionIDs?: StringNullableListFilter
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    permissions?: PermissionListRelationFilter
  }

  export type ModelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    keyword?: SortOrder
    permissionIDs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    permissions?: PermissionOrderByRelationAggregateInput
  }

  export type ModelWhereUniqueInput = {
    id?: string
    name?: string
    keyword?: string
  }

  export type ModelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    keyword?: SortOrder
    permissionIDs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModelCountOrderByAggregateInput
    _max?: ModelMaxOrderByAggregateInput
    _min?: ModelMinOrderByAggregateInput
  }

  export type ModelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ModelScalarWhereWithAggregatesInput>
    OR?: Enumerable<ModelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ModelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    keyword?: StringWithAggregatesFilter | string
    permissionIDs?: StringNullableListFilter
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type AddressWhereInput = {
    AND?: Enumerable<AddressWhereInput>
    OR?: Enumerable<AddressWhereInput>
    NOT?: Enumerable<AddressWhereInput>
    id?: StringFilter | string
    firstAdress?: StringFilter | string
    secondAdress?: StringNullableFilter | string | null
    zipCode?: StringFilter | string
    city?: StringFilter | string
    region?: StringFilter | string
    country?: StringFilter | string
    additionnalInformation?: StringNullableFilter | string | null
    userId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    firstAdress?: SortOrder
    secondAdress?: SortOrder
    zipCode?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    additionnalInformation?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AddressWhereUniqueInput = {
    id?: string
    userId?: string
  }

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    firstAdress?: SortOrder
    secondAdress?: SortOrder
    zipCode?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    additionnalInformation?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<AddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AddressScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    firstAdress?: StringWithAggregatesFilter | string
    secondAdress?: StringNullableWithAggregatesFilter | string | null
    zipCode?: StringWithAggregatesFilter | string
    city?: StringWithAggregatesFilter | string
    region?: StringWithAggregatesFilter | string
    country?: StringWithAggregatesFilter | string
    additionnalInformation?: StringNullableWithAggregatesFilter | string | null
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type WalletWhereInput = {
    AND?: Enumerable<WalletWhereInput>
    OR?: Enumerable<WalletWhereInput>
    NOT?: Enumerable<WalletWhereInput>
    id?: StringFilter | string
    balance?: FloatFilter | number
    userId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    transaction?: TransactionListRelationFilter
  }

  export type WalletOrderByWithRelationInput = {
    id?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    transaction?: TransactionOrderByRelationAggregateInput
  }

  export type WalletWhereUniqueInput = {
    id?: string
    userId?: string
  }

  export type WalletOrderByWithAggregationInput = {
    id?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WalletCountOrderByAggregateInput
    _avg?: WalletAvgOrderByAggregateInput
    _max?: WalletMaxOrderByAggregateInput
    _min?: WalletMinOrderByAggregateInput
    _sum?: WalletSumOrderByAggregateInput
  }

  export type WalletScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WalletScalarWhereWithAggregatesInput>
    OR?: Enumerable<WalletScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WalletScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    balance?: FloatWithAggregatesFilter | number
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type BoxTypeWhereInput = {
    AND?: Enumerable<BoxTypeWhereInput>
    OR?: Enumerable<BoxTypeWhereInput>
    NOT?: Enumerable<BoxTypeWhereInput>
    id?: StringFilter | string
    reference?: StringFilter | string
    name?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    box?: BoxListRelationFilter
  }

  export type BoxTypeOrderByWithRelationInput = {
    id?: SortOrder
    reference?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    box?: BoxOrderByRelationAggregateInput
  }

  export type BoxTypeWhereUniqueInput = {
    id?: string
    reference?: string
  }

  export type BoxTypeOrderByWithAggregationInput = {
    id?: SortOrder
    reference?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BoxTypeCountOrderByAggregateInput
    _max?: BoxTypeMaxOrderByAggregateInput
    _min?: BoxTypeMinOrderByAggregateInput
  }

  export type BoxTypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BoxTypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<BoxTypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BoxTypeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    reference?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type BoxWhereInput = {
    AND?: Enumerable<BoxWhereInput>
    OR?: Enumerable<BoxWhereInput>
    NOT?: Enumerable<BoxWhereInput>
    id?: StringFilter | string
    reference?: StringFilter | string
    name?: StringFilter | string
    price?: FloatFilter | number
    number?: IntFilter | number
    description?: StringFilter | string
    badge?: EnumEnumBadgeBoxNullableFilter | EnumBadgeBox | null
    boxTypeId?: StringNullableFilter | string | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    boxImage?: BoxImageListRelationFilter
    article?: ArticleListRelationFilter
    transaction?: TransactionListRelationFilter
    userBox?: UserBoxListRelationFilter
    bannerImage?: BannerImageListRelationFilter
    boxParams?: XOR<BoxParamsRelationFilter, BoxParamsWhereInput> | null
    boxType?: XOR<BoxTypeRelationFilter, BoxTypeWhereInput> | null
    boxArticle?: BoxArticleListRelationFilter
    dailyReward?: DailyRewardListRelationFilter
    boxRewardLevel?: BoxRewardLevelListRelationFilter
  }

  export type BoxOrderByWithRelationInput = {
    id?: SortOrder
    reference?: SortOrder
    name?: SortOrder
    price?: SortOrder
    number?: SortOrder
    description?: SortOrder
    badge?: SortOrder
    boxTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    boxImage?: BoxImageOrderByRelationAggregateInput
    article?: ArticleOrderByRelationAggregateInput
    transaction?: TransactionOrderByRelationAggregateInput
    userBox?: UserBoxOrderByRelationAggregateInput
    bannerImage?: BannerImageOrderByRelationAggregateInput
    boxParams?: BoxParamsOrderByWithRelationInput
    boxType?: BoxTypeOrderByWithRelationInput
    boxArticle?: BoxArticleOrderByRelationAggregateInput
    dailyReward?: DailyRewardOrderByRelationAggregateInput
    boxRewardLevel?: BoxRewardLevelOrderByRelationAggregateInput
  }

  export type BoxWhereUniqueInput = {
    id?: string
    reference?: string
  }

  export type BoxOrderByWithAggregationInput = {
    id?: SortOrder
    reference?: SortOrder
    name?: SortOrder
    price?: SortOrder
    number?: SortOrder
    description?: SortOrder
    badge?: SortOrder
    boxTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BoxCountOrderByAggregateInput
    _avg?: BoxAvgOrderByAggregateInput
    _max?: BoxMaxOrderByAggregateInput
    _min?: BoxMinOrderByAggregateInput
    _sum?: BoxSumOrderByAggregateInput
  }

  export type BoxScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BoxScalarWhereWithAggregatesInput>
    OR?: Enumerable<BoxScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BoxScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    reference?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    number?: IntWithAggregatesFilter | number
    description?: StringWithAggregatesFilter | string
    badge?: EnumEnumBadgeBoxNullableWithAggregatesFilter | EnumBadgeBox | null
    boxTypeId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type DailyRewardWhereInput = {
    AND?: Enumerable<DailyRewardWhereInput>
    OR?: Enumerable<DailyRewardWhereInput>
    NOT?: Enumerable<DailyRewardWhereInput>
    id?: StringFilter | string
    number?: IntFilter | number
    boxId?: StringFilter | string
    box?: XOR<BoxRelationFilter, BoxWhereInput>
  }

  export type DailyRewardOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    boxId?: SortOrder
    box?: BoxOrderByWithRelationInput
  }

  export type DailyRewardWhereUniqueInput = {
    id?: string
    number?: number
  }

  export type DailyRewardOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    boxId?: SortOrder
    _count?: DailyRewardCountOrderByAggregateInput
    _avg?: DailyRewardAvgOrderByAggregateInput
    _max?: DailyRewardMaxOrderByAggregateInput
    _min?: DailyRewardMinOrderByAggregateInput
    _sum?: DailyRewardSumOrderByAggregateInput
  }

  export type DailyRewardScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DailyRewardScalarWhereWithAggregatesInput>
    OR?: Enumerable<DailyRewardScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DailyRewardScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    number?: IntWithAggregatesFilter | number
    boxId?: StringWithAggregatesFilter | string
  }

  export type BoxRewardLevelWhereInput = {
    AND?: Enumerable<BoxRewardLevelWhereInput>
    OR?: Enumerable<BoxRewardLevelWhereInput>
    NOT?: Enumerable<BoxRewardLevelWhereInput>
    id?: StringFilter | string
    boxId?: StringFilter | string
    rewardLevelId?: StringFilter | string
    box?: XOR<BoxRelationFilter, BoxWhereInput>
    rewardLevel?: XOR<RewardLevelRelationFilter, RewardLevelWhereInput>
  }

  export type BoxRewardLevelOrderByWithRelationInput = {
    id?: SortOrder
    boxId?: SortOrder
    rewardLevelId?: SortOrder
    box?: BoxOrderByWithRelationInput
    rewardLevel?: RewardLevelOrderByWithRelationInput
  }

  export type BoxRewardLevelWhereUniqueInput = {
    id?: string
  }

  export type BoxRewardLevelOrderByWithAggregationInput = {
    id?: SortOrder
    boxId?: SortOrder
    rewardLevelId?: SortOrder
    _count?: BoxRewardLevelCountOrderByAggregateInput
    _max?: BoxRewardLevelMaxOrderByAggregateInput
    _min?: BoxRewardLevelMinOrderByAggregateInput
  }

  export type BoxRewardLevelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BoxRewardLevelScalarWhereWithAggregatesInput>
    OR?: Enumerable<BoxRewardLevelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BoxRewardLevelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    boxId?: StringWithAggregatesFilter | string
    rewardLevelId?: StringWithAggregatesFilter | string
  }

  export type RewardLevelWhereInput = {
    AND?: Enumerable<RewardLevelWhereInput>
    OR?: Enumerable<RewardLevelWhereInput>
    NOT?: Enumerable<RewardLevelWhereInput>
    id?: StringFilter | string
    orderNumber?: IntFilter | number
    name?: StringFilter | string
    unlockThreshold?: FloatFilter | number
    description?: StringNullableFilter | string | null
    boxRewardLevel?: BoxRewardLevelListRelationFilter
  }

  export type RewardLevelOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    name?: SortOrder
    unlockThreshold?: SortOrder
    description?: SortOrder
    boxRewardLevel?: BoxRewardLevelOrderByRelationAggregateInput
  }

  export type RewardLevelWhereUniqueInput = {
    id?: string
    orderNumber?: number
    name?: string
  }

  export type RewardLevelOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    name?: SortOrder
    unlockThreshold?: SortOrder
    description?: SortOrder
    _count?: RewardLevelCountOrderByAggregateInput
    _avg?: RewardLevelAvgOrderByAggregateInput
    _max?: RewardLevelMaxOrderByAggregateInput
    _min?: RewardLevelMinOrderByAggregateInput
    _sum?: RewardLevelSumOrderByAggregateInput
  }

  export type RewardLevelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RewardLevelScalarWhereWithAggregatesInput>
    OR?: Enumerable<RewardLevelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RewardLevelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    orderNumber?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    unlockThreshold?: FloatWithAggregatesFilter | number
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type BoxImageWhereInput = {
    AND?: Enumerable<BoxImageWhereInput>
    OR?: Enumerable<BoxImageWhereInput>
    NOT?: Enumerable<BoxImageWhereInput>
    id?: StringFilter | string
    photoUrl?: StringFilter | string
    status?: EnumEnumBoxImageStatusFilter | EnumBoxImageStatus
    boxId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    box?: XOR<BoxRelationFilter, BoxWhereInput>
  }

  export type BoxImageOrderByWithRelationInput = {
    id?: SortOrder
    photoUrl?: SortOrder
    status?: SortOrder
    boxId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    box?: BoxOrderByWithRelationInput
  }

  export type BoxImageWhereUniqueInput = {
    id?: string
  }

  export type BoxImageOrderByWithAggregationInput = {
    id?: SortOrder
    photoUrl?: SortOrder
    status?: SortOrder
    boxId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BoxImageCountOrderByAggregateInput
    _max?: BoxImageMaxOrderByAggregateInput
    _min?: BoxImageMinOrderByAggregateInput
  }

  export type BoxImageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BoxImageScalarWhereWithAggregatesInput>
    OR?: Enumerable<BoxImageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BoxImageScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    photoUrl?: StringWithAggregatesFilter | string
    status?: EnumEnumBoxImageStatusWithAggregatesFilter | EnumBoxImageStatus
    boxId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ProviderWhereInput = {
    AND?: Enumerable<ProviderWhereInput>
    OR?: Enumerable<ProviderWhereInput>
    NOT?: Enumerable<ProviderWhereInput>
    id?: StringFilter | string
    reference?: StringFilter | string
    companyName?: StringFilter | string
    address?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    webSite?: StringNullableFilter | string | null
    logo?: StringNullableFilter | string | null
    isPinned?: BoolNullableFilter | boolean | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    article?: ArticleListRelationFilter
  }

  export type ProviderOrderByWithRelationInput = {
    id?: SortOrder
    reference?: SortOrder
    companyName?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    webSite?: SortOrder
    logo?: SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    article?: ArticleOrderByRelationAggregateInput
  }

  export type ProviderWhereUniqueInput = {
    id?: string
    reference?: string
  }

  export type ProviderOrderByWithAggregationInput = {
    id?: SortOrder
    reference?: SortOrder
    companyName?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    webSite?: SortOrder
    logo?: SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProviderCountOrderByAggregateInput
    _max?: ProviderMaxOrderByAggregateInput
    _min?: ProviderMinOrderByAggregateInput
  }

  export type ProviderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProviderScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProviderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProviderScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    reference?: StringWithAggregatesFilter | string
    companyName?: StringWithAggregatesFilter | string
    address?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    webSite?: StringNullableWithAggregatesFilter | string | null
    logo?: StringNullableWithAggregatesFilter | string | null
    isPinned?: BoolNullableWithAggregatesFilter | boolean | null
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type CategoryWhereInput = {
    AND?: Enumerable<CategoryWhereInput>
    OR?: Enumerable<CategoryWhereInput>
    NOT?: Enumerable<CategoryWhereInput>
    id?: StringFilter | string
    reference?: StringFilter | string
    name?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    subCategory?: SubCategoryListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    reference?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subCategory?: SubCategoryOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = {
    id?: string
    reference?: string
  }

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    reference?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CategoryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    reference?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type SubCategoryWhereInput = {
    AND?: Enumerable<SubCategoryWhereInput>
    OR?: Enumerable<SubCategoryWhereInput>
    NOT?: Enumerable<SubCategoryWhereInput>
    id?: StringFilter | string
    reference?: StringFilter | string
    name?: StringFilter | string
    categoryId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    article?: ArticleListRelationFilter
  }

  export type SubCategoryOrderByWithRelationInput = {
    id?: SortOrder
    reference?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: CategoryOrderByWithRelationInput
    article?: ArticleOrderByRelationAggregateInput
  }

  export type SubCategoryWhereUniqueInput = {
    id?: string
    reference?: string
  }

  export type SubCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    reference?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubCategoryCountOrderByAggregateInput
    _max?: SubCategoryMaxOrderByAggregateInput
    _min?: SubCategoryMinOrderByAggregateInput
  }

  export type SubCategoryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubCategoryScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubCategoryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubCategoryScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    reference?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    categoryId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type UnitySizeWhereInput = {
    AND?: Enumerable<UnitySizeWhereInput>
    OR?: Enumerable<UnitySizeWhereInput>
    NOT?: Enumerable<UnitySizeWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    abbreviation?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    article?: ArticleListRelationFilter
  }

  export type UnitySizeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    article?: ArticleOrderByRelationAggregateInput
  }

  export type UnitySizeWhereUniqueInput = {
    id?: string
    name?: string
    abbreviation?: string
  }

  export type UnitySizeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitySizeCountOrderByAggregateInput
    _max?: UnitySizeMaxOrderByAggregateInput
    _min?: UnitySizeMinOrderByAggregateInput
  }

  export type UnitySizeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UnitySizeScalarWhereWithAggregatesInput>
    OR?: Enumerable<UnitySizeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UnitySizeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    abbreviation?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ArticleWhereInput = {
    AND?: Enumerable<ArticleWhereInput>
    OR?: Enumerable<ArticleWhereInput>
    NOT?: Enumerable<ArticleWhereInput>
    id?: StringFilter | string
    reference?: StringFilter | string
    designation?: StringFilter | string
    type?: EnumEnumTypeModeNullableFilter | EnumTypeMode | null
    size?: StringNullableFilter | string | null
    color?: StringNullableFilter | string | null
    productUrl?: StringNullableFilter | string | null
    observation?: StringNullableFilter | string | null
    winningChance?: FloatNullableFilter | number | null
    providerId?: StringNullableFilter | string | null
    unitySizeId?: StringNullableFilter | string | null
    subCategoryId?: StringFilter | string
    boxId?: StringNullableFilter | string | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    provider?: XOR<ProviderRelationFilter, ProviderWhereInput> | null
    unitySize?: XOR<UnitySizeRelationFilter, UnitySizeWhereInput> | null
    subCategory?: XOR<SubCategoryRelationFilter, SubCategoryWhereInput> | null
    box?: XOR<BoxRelationFilter, BoxWhereInput> | null
    articlePhoto?: ArticlePhotoListRelationFilter
    post?: PostListRelationFilter
    price?: XOR<PriceRelationFilter, PriceWhereInput> | null
    boxArticle?: BoxArticleListRelationFilter
    game?: GameListRelationFilter
  }

  export type ArticleOrderByWithRelationInput = {
    id?: SortOrder
    reference?: SortOrder
    designation?: SortOrder
    type?: SortOrder
    size?: SortOrder
    color?: SortOrder
    productUrl?: SortOrder
    observation?: SortOrder
    winningChance?: SortOrder
    providerId?: SortOrder
    unitySizeId?: SortOrder
    subCategoryId?: SortOrder
    boxId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: ProviderOrderByWithRelationInput
    unitySize?: UnitySizeOrderByWithRelationInput
    subCategory?: SubCategoryOrderByWithRelationInput
    box?: BoxOrderByWithRelationInput
    articlePhoto?: ArticlePhotoOrderByRelationAggregateInput
    post?: PostOrderByRelationAggregateInput
    price?: PriceOrderByWithRelationInput
    boxArticle?: BoxArticleOrderByRelationAggregateInput
    game?: GameOrderByRelationAggregateInput
  }

  export type ArticleWhereUniqueInput = {
    id?: string
    reference?: string
  }

  export type ArticleOrderByWithAggregationInput = {
    id?: SortOrder
    reference?: SortOrder
    designation?: SortOrder
    type?: SortOrder
    size?: SortOrder
    color?: SortOrder
    productUrl?: SortOrder
    observation?: SortOrder
    winningChance?: SortOrder
    providerId?: SortOrder
    unitySizeId?: SortOrder
    subCategoryId?: SortOrder
    boxId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ArticleCountOrderByAggregateInput
    _avg?: ArticleAvgOrderByAggregateInput
    _max?: ArticleMaxOrderByAggregateInput
    _min?: ArticleMinOrderByAggregateInput
    _sum?: ArticleSumOrderByAggregateInput
  }

  export type ArticleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ArticleScalarWhereWithAggregatesInput>
    OR?: Enumerable<ArticleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ArticleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    reference?: StringWithAggregatesFilter | string
    designation?: StringWithAggregatesFilter | string
    type?: EnumEnumTypeModeNullableWithAggregatesFilter | EnumTypeMode | null
    size?: StringNullableWithAggregatesFilter | string | null
    color?: StringNullableWithAggregatesFilter | string | null
    productUrl?: StringNullableWithAggregatesFilter | string | null
    observation?: StringNullableWithAggregatesFilter | string | null
    winningChance?: FloatNullableWithAggregatesFilter | number | null
    providerId?: StringNullableWithAggregatesFilter | string | null
    unitySizeId?: StringNullableWithAggregatesFilter | string | null
    subCategoryId?: StringWithAggregatesFilter | string
    boxId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type BoxArticleWhereInput = {
    AND?: Enumerable<BoxArticleWhereInput>
    OR?: Enumerable<BoxArticleWhereInput>
    NOT?: Enumerable<BoxArticleWhereInput>
    id?: StringFilter | string
    winningChance?: FloatFilter | number
    boxId?: StringFilter | string
    articleId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    box?: XOR<BoxRelationFilter, BoxWhereInput>
    article?: XOR<ArticleRelationFilter, ArticleWhereInput>
  }

  export type BoxArticleOrderByWithRelationInput = {
    id?: SortOrder
    winningChance?: SortOrder
    boxId?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    box?: BoxOrderByWithRelationInput
    article?: ArticleOrderByWithRelationInput
  }

  export type BoxArticleWhereUniqueInput = {
    id?: string
  }

  export type BoxArticleOrderByWithAggregationInput = {
    id?: SortOrder
    winningChance?: SortOrder
    boxId?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BoxArticleCountOrderByAggregateInput
    _avg?: BoxArticleAvgOrderByAggregateInput
    _max?: BoxArticleMaxOrderByAggregateInput
    _min?: BoxArticleMinOrderByAggregateInput
    _sum?: BoxArticleSumOrderByAggregateInput
  }

  export type BoxArticleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BoxArticleScalarWhereWithAggregatesInput>
    OR?: Enumerable<BoxArticleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BoxArticleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    winningChance?: FloatWithAggregatesFilter | number
    boxId?: StringWithAggregatesFilter | string
    articleId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ArticlePhotoWhereInput = {
    AND?: Enumerable<ArticlePhotoWhereInput>
    OR?: Enumerable<ArticlePhotoWhereInput>
    NOT?: Enumerable<ArticlePhotoWhereInput>
    id?: StringFilter | string
    photoUrl?: StringFilter | string
    status?: EnumArticlePhotoStatusNullableFilter | ArticlePhotoStatus | null
    articleId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    article?: XOR<ArticleRelationFilter, ArticleWhereInput>
  }

  export type ArticlePhotoOrderByWithRelationInput = {
    id?: SortOrder
    photoUrl?: SortOrder
    status?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    article?: ArticleOrderByWithRelationInput
  }

  export type ArticlePhotoWhereUniqueInput = {
    id?: string
  }

  export type ArticlePhotoOrderByWithAggregationInput = {
    id?: SortOrder
    photoUrl?: SortOrder
    status?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ArticlePhotoCountOrderByAggregateInput
    _max?: ArticlePhotoMaxOrderByAggregateInput
    _min?: ArticlePhotoMinOrderByAggregateInput
  }

  export type ArticlePhotoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ArticlePhotoScalarWhereWithAggregatesInput>
    OR?: Enumerable<ArticlePhotoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ArticlePhotoScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    photoUrl?: StringWithAggregatesFilter | string
    status?: EnumArticlePhotoStatusNullableWithAggregatesFilter | ArticlePhotoStatus | null
    articleId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type PostWhereInput = {
    AND?: Enumerable<PostWhereInput>
    OR?: Enumerable<PostWhereInput>
    NOT?: Enumerable<PostWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    content?: StringFilter | string
    postUrl?: StringFilter | string
    articleId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    article?: XOR<ArticleRelationFilter, ArticleWhereInput>
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    postUrl?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    article?: ArticleOrderByWithRelationInput
  }

  export type PostWhereUniqueInput = {
    id?: string
  }

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    postUrl?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PostScalarWhereWithAggregatesInput>
    OR?: Enumerable<PostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PostScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    postUrl?: StringWithAggregatesFilter | string
    articleId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type PriceWhereInput = {
    AND?: Enumerable<PriceWhereInput>
    OR?: Enumerable<PriceWhereInput>
    NOT?: Enumerable<PriceWhereInput>
    id?: StringFilter | string
    reference?: StringNullableFilter | string | null
    currentPrice?: FloatFilter | number
    oldPrice?: FloatNullableFilter | number | null
    rate?: FloatNullableFilter | number | null
    reduction?: FloatNullableFilter | number | null
    sellingPrice?: FloatNullableFilter | number | null
    articleId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    article?: XOR<ArticleRelationFilter, ArticleWhereInput>
  }

  export type PriceOrderByWithRelationInput = {
    id?: SortOrder
    reference?: SortOrder
    currentPrice?: SortOrder
    oldPrice?: SortOrder
    rate?: SortOrder
    reduction?: SortOrder
    sellingPrice?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    article?: ArticleOrderByWithRelationInput
  }

  export type PriceWhereUniqueInput = {
    id?: string
    articleId?: string
  }

  export type PriceOrderByWithAggregationInput = {
    id?: SortOrder
    reference?: SortOrder
    currentPrice?: SortOrder
    oldPrice?: SortOrder
    rate?: SortOrder
    reduction?: SortOrder
    sellingPrice?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PriceCountOrderByAggregateInput
    _avg?: PriceAvgOrderByAggregateInput
    _max?: PriceMaxOrderByAggregateInput
    _min?: PriceMinOrderByAggregateInput
    _sum?: PriceSumOrderByAggregateInput
  }

  export type PriceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PriceScalarWhereWithAggregatesInput>
    OR?: Enumerable<PriceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PriceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    reference?: StringNullableWithAggregatesFilter | string | null
    currentPrice?: FloatWithAggregatesFilter | number
    oldPrice?: FloatNullableWithAggregatesFilter | number | null
    rate?: FloatNullableWithAggregatesFilter | number | null
    reduction?: FloatNullableWithAggregatesFilter | number | null
    sellingPrice?: FloatNullableWithAggregatesFilter | number | null
    articleId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type OrderWhereInput = {
    AND?: Enumerable<OrderWhereInput>
    OR?: Enumerable<OrderWhereInput>
    NOT?: Enumerable<OrderWhereInput>
    id?: StringFilter | string
    status?: EnumEnumOrderStatusFilter | EnumOrderStatus
    followedLink?: StringNullableFilter | string | null
    orderNumber?: StringNullableFilter | string | null
    shoppingCartId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    shoppingCart?: XOR<ShoppingCartRelationFilter, ShoppingCartWhereInput>
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    followedLink?: SortOrder
    orderNumber?: SortOrder
    shoppingCartId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shoppingCart?: ShoppingCartOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = {
    id?: string
    shoppingCartId?: string
  }

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    followedLink?: SortOrder
    orderNumber?: SortOrder
    shoppingCartId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OrderScalarWhereWithAggregatesInput>
    OR?: Enumerable<OrderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OrderScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    status?: EnumEnumOrderStatusWithAggregatesFilter | EnumOrderStatus
    followedLink?: StringNullableWithAggregatesFilter | string | null
    orderNumber?: StringNullableWithAggregatesFilter | string | null
    shoppingCartId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ShoppingCartWhereInput = {
    AND?: Enumerable<ShoppingCartWhereInput>
    OR?: Enumerable<ShoppingCartWhereInput>
    NOT?: Enumerable<ShoppingCartWhereInput>
    id?: StringFilter | string
    winningDate?: DateTimeFilter | Date | string
    isClaimed?: BoolNullableFilter | boolean | null
    gameId?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    game?: XOR<GameRelationFilter, GameWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    transaction?: TransactionListRelationFilter
    order?: XOR<OrderRelationFilter, OrderWhereInput> | null
  }

  export type ShoppingCartOrderByWithRelationInput = {
    id?: SortOrder
    winningDate?: SortOrder
    isClaimed?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    game?: GameOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    transaction?: TransactionOrderByRelationAggregateInput
    order?: OrderOrderByWithRelationInput
  }

  export type ShoppingCartWhereUniqueInput = {
    id?: string
    gameId?: string
  }

  export type ShoppingCartOrderByWithAggregationInput = {
    id?: SortOrder
    winningDate?: SortOrder
    isClaimed?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShoppingCartCountOrderByAggregateInput
    _max?: ShoppingCartMaxOrderByAggregateInput
    _min?: ShoppingCartMinOrderByAggregateInput
  }

  export type ShoppingCartScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ShoppingCartScalarWhereWithAggregatesInput>
    OR?: Enumerable<ShoppingCartScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ShoppingCartScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    winningDate?: DateTimeWithAggregatesFilter | Date | string
    isClaimed?: BoolNullableWithAggregatesFilter | boolean | null
    gameId?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type TransactionWhereInput = {
    AND?: Enumerable<TransactionWhereInput>
    OR?: Enumerable<TransactionWhereInput>
    NOT?: Enumerable<TransactionWhereInput>
    id?: StringFilter | string
    type?: EnumEnumTypeTransactionFilter | EnumTypeTransaction
    date?: DateTimeFilter | Date | string
    amount?: FloatFilter | number
    status?: EnumEnumStatusTransactionFilter | EnumStatusTransaction
    boxId?: StringNullableFilter | string | null
    walletId?: StringFilter | string
    offerId?: StringNullableFilter | string | null
    shoppingCartId?: StringNullableFilter | string | null
    bankId?: StringNullableFilter | string | null
    gameId?: StringNullableFilter | string | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    box?: XOR<BoxRelationFilter, BoxWhereInput> | null
    wallet?: XOR<WalletRelationFilter, WalletWhereInput>
    offer?: XOR<OfferRelationFilter, OfferWhereInput> | null
    shoppingCart?: XOR<ShoppingCartRelationFilter, ShoppingCartWhereInput> | null
    bank?: XOR<BankRelationFilter, BankWhereInput> | null
    game?: XOR<GameRelationFilter, GameWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    boxId?: SortOrder
    walletId?: SortOrder
    offerId?: SortOrder
    shoppingCartId?: SortOrder
    bankId?: SortOrder
    gameId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    box?: BoxOrderByWithRelationInput
    wallet?: WalletOrderByWithRelationInput
    offer?: OfferOrderByWithRelationInput
    shoppingCart?: ShoppingCartOrderByWithRelationInput
    bank?: BankOrderByWithRelationInput
    game?: GameOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = {
    id?: string
  }

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    boxId?: SortOrder
    walletId?: SortOrder
    offerId?: SortOrder
    shoppingCartId?: SortOrder
    bankId?: SortOrder
    gameId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TransactionScalarWhereWithAggregatesInput>
    OR?: Enumerable<TransactionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TransactionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: EnumEnumTypeTransactionWithAggregatesFilter | EnumTypeTransaction
    date?: DateTimeWithAggregatesFilter | Date | string
    amount?: FloatWithAggregatesFilter | number
    status?: EnumEnumStatusTransactionWithAggregatesFilter | EnumStatusTransaction
    boxId?: StringNullableWithAggregatesFilter | string | null
    walletId?: StringWithAggregatesFilter | string
    offerId?: StringNullableWithAggregatesFilter | string | null
    shoppingCartId?: StringNullableWithAggregatesFilter | string | null
    bankId?: StringNullableWithAggregatesFilter | string | null
    gameId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type BankWhereInput = {
    AND?: Enumerable<BankWhereInput>
    OR?: Enumerable<BankWhereInput>
    NOT?: Enumerable<BankWhereInput>
    id?: StringFilter | string
    accountNumber?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    transaction?: TransactionListRelationFilter
  }

  export type BankOrderByWithRelationInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transaction?: TransactionOrderByRelationAggregateInput
  }

  export type BankWhereUniqueInput = {
    id?: string
  }

  export type BankOrderByWithAggregationInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankCountOrderByAggregateInput
    _max?: BankMaxOrderByAggregateInput
    _min?: BankMinOrderByAggregateInput
  }

  export type BankScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BankScalarWhereWithAggregatesInput>
    OR?: Enumerable<BankScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BankScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    accountNumber?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type UserBoxWhereInput = {
    AND?: Enumerable<UserBoxWhereInput>
    OR?: Enumerable<UserBoxWhereInput>
    NOT?: Enumerable<UserBoxWhereInput>
    id?: StringFilter | string
    type?: EnumEnumUserBoxTypeFilter | EnumUserBoxType
    duration?: DateTimeNullableFilter | Date | string | null
    dayNumber?: IntNullableFilter | number | null
    isPlayed?: BoolNullableFilter | boolean | null
    isLocked?: BoolNullableFilter | boolean | null
    playedDate?: DateTimeNullableFilter | Date | string | null
    activationDate?: DateTimeNullableFilter | Date | string | null
    deactivationDate?: DateTimeNullableFilter | Date | string | null
    orderNumber?: IntNullableFilter | number | null
    name?: StringNullableFilter | string | null
    unlockThreshold?: FloatNullableFilter | number | null
    description?: StringNullableFilter | string | null
    userId?: StringFilter | string
    boxId?: StringFilter | string
    lot?: IntNullableFilter | number | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    box?: XOR<BoxRelationFilter, BoxWhereInput>
    game?: GameListRelationFilter
  }

  export type UserBoxOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    duration?: SortOrder
    dayNumber?: SortOrder
    isPlayed?: SortOrder
    isLocked?: SortOrder
    playedDate?: SortOrder
    activationDate?: SortOrder
    deactivationDate?: SortOrder
    orderNumber?: SortOrder
    name?: SortOrder
    unlockThreshold?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    boxId?: SortOrder
    lot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    box?: BoxOrderByWithRelationInput
    game?: GameOrderByRelationAggregateInput
  }

  export type UserBoxWhereUniqueInput = {
    id?: string
  }

  export type UserBoxOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    duration?: SortOrder
    dayNumber?: SortOrder
    isPlayed?: SortOrder
    isLocked?: SortOrder
    playedDate?: SortOrder
    activationDate?: SortOrder
    deactivationDate?: SortOrder
    orderNumber?: SortOrder
    name?: SortOrder
    unlockThreshold?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    boxId?: SortOrder
    lot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserBoxCountOrderByAggregateInput
    _avg?: UserBoxAvgOrderByAggregateInput
    _max?: UserBoxMaxOrderByAggregateInput
    _min?: UserBoxMinOrderByAggregateInput
    _sum?: UserBoxSumOrderByAggregateInput
  }

  export type UserBoxScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserBoxScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserBoxScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserBoxScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: EnumEnumUserBoxTypeWithAggregatesFilter | EnumUserBoxType
    duration?: DateTimeNullableWithAggregatesFilter | Date | string | null
    dayNumber?: IntNullableWithAggregatesFilter | number | null
    isPlayed?: BoolNullableWithAggregatesFilter | boolean | null
    isLocked?: BoolNullableWithAggregatesFilter | boolean | null
    playedDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    activationDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    deactivationDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    orderNumber?: IntNullableWithAggregatesFilter | number | null
    name?: StringNullableWithAggregatesFilter | string | null
    unlockThreshold?: FloatNullableWithAggregatesFilter | number | null
    description?: StringNullableWithAggregatesFilter | string | null
    userId?: StringWithAggregatesFilter | string
    boxId?: StringWithAggregatesFilter | string
    lot?: IntNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type BannerImageWhereInput = {
    AND?: Enumerable<BannerImageWhereInput>
    OR?: Enumerable<BannerImageWhereInput>
    NOT?: Enumerable<BannerImageWhereInput>
    id?: StringFilter | string
    bannerImgUrl?: StringFilter | string
    bannerLink?: StringNullableFilter | string | null
    type?: EnumBannerImageTypeNullableFilter | BannerImageType | null
    boxId?: StringNullableFilter | string | null
    offerId?: StringNullableFilter | string | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    box?: XOR<BoxRelationFilter, BoxWhereInput> | null
    offer?: XOR<OfferRelationFilter, OfferWhereInput> | null
  }

  export type BannerImageOrderByWithRelationInput = {
    id?: SortOrder
    bannerImgUrl?: SortOrder
    bannerLink?: SortOrder
    type?: SortOrder
    boxId?: SortOrder
    offerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    box?: BoxOrderByWithRelationInput
    offer?: OfferOrderByWithRelationInput
  }

  export type BannerImageWhereUniqueInput = {
    id?: string
  }

  export type BannerImageOrderByWithAggregationInput = {
    id?: SortOrder
    bannerImgUrl?: SortOrder
    bannerLink?: SortOrder
    type?: SortOrder
    boxId?: SortOrder
    offerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BannerImageCountOrderByAggregateInput
    _max?: BannerImageMaxOrderByAggregateInput
    _min?: BannerImageMinOrderByAggregateInput
  }

  export type BannerImageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BannerImageScalarWhereWithAggregatesInput>
    OR?: Enumerable<BannerImageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BannerImageScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    bannerImgUrl?: StringWithAggregatesFilter | string
    bannerLink?: StringNullableWithAggregatesFilter | string | null
    type?: EnumBannerImageTypeNullableWithAggregatesFilter | BannerImageType | null
    boxId?: StringNullableWithAggregatesFilter | string | null
    offerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type BoxParamsWhereInput = {
    AND?: Enumerable<BoxParamsWhereInput>
    OR?: Enumerable<BoxParamsWhereInput>
    NOT?: Enumerable<BoxParamsWhereInput>
    id?: StringFilter | string
    isBestSelling?: BoolFilter | boolean
    isRecommended?: BoolFilter | boolean
    isNew?: BoolFilter | boolean
    isBigPrice?: BoolFilter | boolean
    isSubsciptionBonus?: BoolFilter | boolean
    boxId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    box?: XOR<BoxRelationFilter, BoxWhereInput> | null
  }

  export type BoxParamsOrderByWithRelationInput = {
    id?: SortOrder
    isBestSelling?: SortOrder
    isRecommended?: SortOrder
    isNew?: SortOrder
    isBigPrice?: SortOrder
    isSubsciptionBonus?: SortOrder
    boxId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    box?: BoxOrderByWithRelationInput
  }

  export type BoxParamsWhereUniqueInput = {
    id?: string
    boxId?: string
  }

  export type BoxParamsOrderByWithAggregationInput = {
    id?: SortOrder
    isBestSelling?: SortOrder
    isRecommended?: SortOrder
    isNew?: SortOrder
    isBigPrice?: SortOrder
    isSubsciptionBonus?: SortOrder
    boxId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BoxParamsCountOrderByAggregateInput
    _max?: BoxParamsMaxOrderByAggregateInput
    _min?: BoxParamsMinOrderByAggregateInput
  }

  export type BoxParamsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BoxParamsScalarWhereWithAggregatesInput>
    OR?: Enumerable<BoxParamsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BoxParamsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    isBestSelling?: BoolWithAggregatesFilter | boolean
    isRecommended?: BoolWithAggregatesFilter | boolean
    isNew?: BoolWithAggregatesFilter | boolean
    isBigPrice?: BoolWithAggregatesFilter | boolean
    isSubsciptionBonus?: BoolWithAggregatesFilter | boolean
    boxId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type HistoricalWhereInput = {
    AND?: Enumerable<HistoricalWhereInput>
    OR?: Enumerable<HistoricalWhereInput>
    NOT?: Enumerable<HistoricalWhereInput>
    id?: StringFilter | string
    date?: DateTimeFilter | Date | string
    description?: StringFilter | string
    userId?: StringFilter | string
    action?: EnumEnumHistoricalActionFilter | EnumHistoricalAction
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type HistoricalOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type HistoricalWhereUniqueInput = {
    id?: string
  }

  export type HistoricalOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HistoricalCountOrderByAggregateInput
    _max?: HistoricalMaxOrderByAggregateInput
    _min?: HistoricalMinOrderByAggregateInput
  }

  export type HistoricalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HistoricalScalarWhereWithAggregatesInput>
    OR?: Enumerable<HistoricalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HistoricalScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    date?: DateTimeWithAggregatesFilter | Date | string
    description?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    action?: EnumEnumHistoricalActionWithAggregatesFilter | EnumHistoricalAction
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type MessageWhereInput = {
    AND?: Enumerable<MessageWhereInput>
    OR?: Enumerable<MessageWhereInput>
    NOT?: Enumerable<MessageWhereInput>
    id?: StringFilter | string
    message?: StringFilter | string
    sendingDate?: DateTimeFilter | Date | string
    senderId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    sender?: XOR<UserRelationFilter, UserWhereInput>
    receiver?: ReceiverListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    message?: SortOrder
    sendingDate?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sender?: UserOrderByWithRelationInput
    receiver?: ReceiverOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = {
    id?: string
  }

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    message?: SortOrder
    sendingDate?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<MessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MessageScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    message?: StringWithAggregatesFilter | string
    sendingDate?: DateTimeWithAggregatesFilter | Date | string
    senderId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ReceiverWhereInput = {
    AND?: Enumerable<ReceiverWhereInput>
    OR?: Enumerable<ReceiverWhereInput>
    NOT?: Enumerable<ReceiverWhereInput>
    id?: StringFilter | string
    readingDate?: DateTimeFilter | Date | string
    receiverId?: StringFilter | string
    messageId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    receiver?: XOR<UserRelationFilter, UserWhereInput>
    message?: XOR<MessageRelationFilter, MessageWhereInput>
  }

  export type ReceiverOrderByWithRelationInput = {
    id?: SortOrder
    readingDate?: SortOrder
    receiverId?: SortOrder
    messageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    receiver?: UserOrderByWithRelationInput
    message?: MessageOrderByWithRelationInput
  }

  export type ReceiverWhereUniqueInput = {
    id?: string
  }

  export type ReceiverOrderByWithAggregationInput = {
    id?: SortOrder
    readingDate?: SortOrder
    receiverId?: SortOrder
    messageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReceiverCountOrderByAggregateInput
    _max?: ReceiverMaxOrderByAggregateInput
    _min?: ReceiverMinOrderByAggregateInput
  }

  export type ReceiverScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReceiverScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReceiverScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReceiverScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    readingDate?: DateTimeWithAggregatesFilter | Date | string
    receiverId?: StringWithAggregatesFilter | string
    messageId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type NewsLetterWhereInput = {
    AND?: Enumerable<NewsLetterWhereInput>
    OR?: Enumerable<NewsLetterWhereInput>
    NOT?: Enumerable<NewsLetterWhereInput>
    id?: StringFilter | string
    email?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type NewsLetterOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsLetterWhereUniqueInput = {
    id?: string
  }

  export type NewsLetterOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NewsLetterCountOrderByAggregateInput
    _max?: NewsLetterMaxOrderByAggregateInput
    _min?: NewsLetterMinOrderByAggregateInput
  }

  export type NewsLetterScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NewsLetterScalarWhereWithAggregatesInput>
    OR?: Enumerable<NewsLetterScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NewsLetterScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type TemoignageWhereInput = {
    AND?: Enumerable<TemoignageWhereInput>
    OR?: Enumerable<TemoignageWhereInput>
    NOT?: Enumerable<TemoignageWhereInput>
    id?: StringFilter | string
    comment?: StringFilter | string
    rating?: IntFilter | number
    commentDate?: DateTimeFilter | Date | string
    isToShow?: BoolFilter | boolean
    userId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TemoignageOrderByWithRelationInput = {
    id?: SortOrder
    comment?: SortOrder
    rating?: SortOrder
    commentDate?: SortOrder
    isToShow?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TemoignageWhereUniqueInput = {
    id?: string
  }

  export type TemoignageOrderByWithAggregationInput = {
    id?: SortOrder
    comment?: SortOrder
    rating?: SortOrder
    commentDate?: SortOrder
    isToShow?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TemoignageCountOrderByAggregateInput
    _avg?: TemoignageAvgOrderByAggregateInput
    _max?: TemoignageMaxOrderByAggregateInput
    _min?: TemoignageMinOrderByAggregateInput
    _sum?: TemoignageSumOrderByAggregateInput
  }

  export type TemoignageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TemoignageScalarWhereWithAggregatesInput>
    OR?: Enumerable<TemoignageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TemoignageScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    comment?: StringWithAggregatesFilter | string
    rating?: IntWithAggregatesFilter | number
    commentDate?: DateTimeWithAggregatesFilter | Date | string
    isToShow?: BoolWithAggregatesFilter | boolean
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type OfferWhereInput = {
    AND?: Enumerable<OfferWhereInput>
    OR?: Enumerable<OfferWhereInput>
    NOT?: Enumerable<OfferWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    price?: FloatFilter | number
    priceThreeMonth?: FloatNullableFilter | number | null
    color?: StringNullableFilter | string | null
    numberMysteryBoxBronze?: IntFilter | number
    numberMysteryBoxSylver?: IntFilter | number
    numberMysteryBoxGold?: IntFilter | number
    isAwardLevelActive?: BoolFilter | boolean
    isWeeklyAwardActive?: BoolFilter | boolean
    isStandardSupportActive?: BoolFilter | boolean
    isVIPSupportActive?: BoolFilter | boolean
    duration?: FloatNullableFilter | number | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    subscription?: SubscriptionListRelationFilter
    bannerImage?: BannerImageListRelationFilter
    transaction?: TransactionListRelationFilter
  }

  export type OfferOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    priceThreeMonth?: SortOrder
    color?: SortOrder
    numberMysteryBoxBronze?: SortOrder
    numberMysteryBoxSylver?: SortOrder
    numberMysteryBoxGold?: SortOrder
    isAwardLevelActive?: SortOrder
    isWeeklyAwardActive?: SortOrder
    isStandardSupportActive?: SortOrder
    isVIPSupportActive?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscription?: SubscriptionOrderByRelationAggregateInput
    bannerImage?: BannerImageOrderByRelationAggregateInput
    transaction?: TransactionOrderByRelationAggregateInput
  }

  export type OfferWhereUniqueInput = {
    id?: string
  }

  export type OfferOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    priceThreeMonth?: SortOrder
    color?: SortOrder
    numberMysteryBoxBronze?: SortOrder
    numberMysteryBoxSylver?: SortOrder
    numberMysteryBoxGold?: SortOrder
    isAwardLevelActive?: SortOrder
    isWeeklyAwardActive?: SortOrder
    isStandardSupportActive?: SortOrder
    isVIPSupportActive?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OfferCountOrderByAggregateInput
    _avg?: OfferAvgOrderByAggregateInput
    _max?: OfferMaxOrderByAggregateInput
    _min?: OfferMinOrderByAggregateInput
    _sum?: OfferSumOrderByAggregateInput
  }

  export type OfferScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OfferScalarWhereWithAggregatesInput>
    OR?: Enumerable<OfferScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OfferScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    priceThreeMonth?: FloatNullableWithAggregatesFilter | number | null
    color?: StringNullableWithAggregatesFilter | string | null
    numberMysteryBoxBronze?: IntWithAggregatesFilter | number
    numberMysteryBoxSylver?: IntWithAggregatesFilter | number
    numberMysteryBoxGold?: IntWithAggregatesFilter | number
    isAwardLevelActive?: BoolWithAggregatesFilter | boolean
    isWeeklyAwardActive?: BoolWithAggregatesFilter | boolean
    isStandardSupportActive?: BoolWithAggregatesFilter | boolean
    isVIPSupportActive?: BoolWithAggregatesFilter | boolean
    duration?: FloatNullableWithAggregatesFilter | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type SubscriptionWhereInput = {
    AND?: Enumerable<SubscriptionWhereInput>
    OR?: Enumerable<SubscriptionWhereInput>
    NOT?: Enumerable<SubscriptionWhereInput>
    id?: StringFilter | string
    startDate?: DateTimeFilter | Date | string
    endDate?: DateTimeFilter | Date | string
    durationType?: EnumEnumPriceSubscriptionNullableFilter | EnumPriceSubscription | null
    status?: EnumEnumStatusSubscriptionNullableFilter | EnumStatusSubscription | null
    autoRenewal?: BoolFilter | boolean
    userId?: StringFilter | string
    offerId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    offer?: XOR<OfferRelationFilter, OfferWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    durationType?: SortOrder
    status?: SortOrder
    autoRenewal?: SortOrder
    userId?: SortOrder
    offerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    offer?: OfferOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = {
    id?: string
  }

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    durationType?: SortOrder
    status?: SortOrder
    autoRenewal?: SortOrder
    userId?: SortOrder
    offerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubscriptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubscriptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubscriptionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    startDate?: DateTimeWithAggregatesFilter | Date | string
    endDate?: DateTimeWithAggregatesFilter | Date | string
    durationType?: EnumEnumPriceSubscriptionNullableWithAggregatesFilter | EnumPriceSubscription | null
    status?: EnumEnumStatusSubscriptionNullableWithAggregatesFilter | EnumStatusSubscription | null
    autoRenewal?: BoolWithAggregatesFilter | boolean
    userId?: StringWithAggregatesFilter | string
    offerId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type GameWhereInput = {
    AND?: Enumerable<GameWhereInput>
    OR?: Enumerable<GameWhereInput>
    NOT?: Enumerable<GameWhereInput>
    id?: StringFilter | string
    reference?: StringFilter | string
    startDate?: DateTimeFilter | Date | string
    endDate?: DateTimeNullableFilter | Date | string | null
    status?: EnumEnumStatusGameFilter | EnumStatusGame
    version?: EnumEnumVersionGameNullableFilter | EnumVersionGame | null
    type?: EnumEnumTypeGameNullableFilter | EnumTypeGame | null
    userBoxId?: StringNullableFilter | string | null
    patronageId?: StringNullableFilter | string | null
    gainPercentage?: FloatNullableFilter | number | null
    gainDraw?: FloatNullableFilter | number | null
    articleId?: StringNullableFilter | string | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    userBox?: XOR<UserBoxRelationFilter, UserBoxWhereInput> | null
    patronage?: XOR<PatronageRelationFilter, PatronageWhereInput> | null
    article?: XOR<ArticleRelationFilter, ArticleWhereInput> | null
    shoppingCart?: XOR<ShoppingCartRelationFilter, ShoppingCartWhereInput> | null
    transaction?: TransactionListRelationFilter
  }

  export type GameOrderByWithRelationInput = {
    id?: SortOrder
    reference?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    version?: SortOrder
    type?: SortOrder
    userBoxId?: SortOrder
    patronageId?: SortOrder
    gainPercentage?: SortOrder
    gainDraw?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userBox?: UserBoxOrderByWithRelationInput
    patronage?: PatronageOrderByWithRelationInput
    article?: ArticleOrderByWithRelationInput
    shoppingCart?: ShoppingCartOrderByWithRelationInput
    transaction?: TransactionOrderByRelationAggregateInput
  }

  export type GameWhereUniqueInput = {
    id?: string
    reference?: string
  }

  export type GameOrderByWithAggregationInput = {
    id?: SortOrder
    reference?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    version?: SortOrder
    type?: SortOrder
    userBoxId?: SortOrder
    patronageId?: SortOrder
    gainPercentage?: SortOrder
    gainDraw?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GameCountOrderByAggregateInput
    _avg?: GameAvgOrderByAggregateInput
    _max?: GameMaxOrderByAggregateInput
    _min?: GameMinOrderByAggregateInput
    _sum?: GameSumOrderByAggregateInput
  }

  export type GameScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GameScalarWhereWithAggregatesInput>
    OR?: Enumerable<GameScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GameScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    reference?: StringWithAggregatesFilter | string
    startDate?: DateTimeWithAggregatesFilter | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    status?: EnumEnumStatusGameWithAggregatesFilter | EnumStatusGame
    version?: EnumEnumVersionGameNullableWithAggregatesFilter | EnumVersionGame | null
    type?: EnumEnumTypeGameNullableWithAggregatesFilter | EnumTypeGame | null
    userBoxId?: StringNullableWithAggregatesFilter | string | null
    patronageId?: StringNullableWithAggregatesFilter | string | null
    gainPercentage?: FloatNullableWithAggregatesFilter | number | null
    gainDraw?: FloatNullableWithAggregatesFilter | number | null
    articleId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeCustomerId?: string | null
    rule?: RuleCreateNestedOneWithoutUserInput
    address?: AddressCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartCreateNestedManyWithoutUserInput
    userBox?: UserBoxCreateNestedManyWithoutUserInput
    historical?: HistoricalCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    receiver?: ReceiverCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedManyWithoutUserInput
    patronage?: PatronageCreateNestedManyWithoutUserParentInput
    userChild?: PatronageCreateNestedOneWithoutUserChildInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ruleId?: string | null
    stripeCustomerId?: string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUserInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutUserInput
    historical?: HistoricalUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receiver?: ReceiverUncheckedCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    patronage?: PatronageUncheckedCreateNestedManyWithoutUserParentInput
    userChild?: PatronageUncheckedCreateNestedOneWithoutUserChildInput
  }

  export type UserUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    rule?: RuleUpdateOneWithoutUserNestedInput
    address?: AddressUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUpdateManyWithoutUserNestedInput
    historical?: HistoricalUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    patronage?: PatronageUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUpdateOneWithoutUserChildNestedInput
  }

  export type UserUncheckedUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ruleId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutUserNestedInput
    historical?: HistoricalUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUncheckedUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    patronage?: PatronageUncheckedUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUncheckedUpdateOneWithoutUserChildNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ruleId?: string | null
    stripeCustomerId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ruleId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatronageCreateInput = {
    id?: string
    gainPercentage?: number | null
    discountPercentage?: number | null
    status?: EnumStatusPatronage | null
    bonusEndDate?: Date | string | null
    bonusCollect?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    userParent: UserCreateNestedOneWithoutPatronageInput
    userChild: UserCreateNestedOneWithoutUserChildInput
    game?: GameCreateNestedManyWithoutPatronageInput
  }

  export type PatronageUncheckedCreateInput = {
    id?: string
    gainPercentage?: number | null
    discountPercentage?: number | null
    status?: EnumStatusPatronage | null
    bonusEndDate?: Date | string | null
    userParentId: string
    userChildId: string
    bonusCollect?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    game?: GameUncheckedCreateNestedManyWithoutPatronageInput
  }

  export type PatronageUpdateInput = {
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumEnumStatusPatronageFieldUpdateOperationsInput | EnumStatusPatronage | null
    bonusEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bonusCollect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userParent?: UserUpdateOneRequiredWithoutPatronageNestedInput
    userChild?: UserUpdateOneRequiredWithoutUserChildNestedInput
    game?: GameUpdateManyWithoutPatronageNestedInput
  }

  export type PatronageUncheckedUpdateInput = {
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumEnumStatusPatronageFieldUpdateOperationsInput | EnumStatusPatronage | null
    bonusEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userParentId?: StringFieldUpdateOperationsInput | string
    userChildId?: StringFieldUpdateOperationsInput | string
    bonusCollect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    game?: GameUncheckedUpdateManyWithoutPatronageNestedInput
  }

  export type PatronageCreateManyInput = {
    id?: string
    gainPercentage?: number | null
    discountPercentage?: number | null
    status?: EnumStatusPatronage | null
    bonusEndDate?: Date | string | null
    userParentId: string
    userChildId: string
    bonusCollect?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PatronageUpdateManyMutationInput = {
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumEnumStatusPatronageFieldUpdateOperationsInput | EnumStatusPatronage | null
    bonusEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bonusCollect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PatronageUncheckedUpdateManyInput = {
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumEnumStatusPatronageFieldUpdateOperationsInput | EnumStatusPatronage | null
    bonusEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userParentId?: StringFieldUpdateOperationsInput | string
    userChildId?: StringFieldUpdateOperationsInput | string
    bonusCollect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CodeConfirmLoginCreateInput = {
    id?: string
    uuid: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutCodeConfirmLoginInput
  }

  export type CodeConfirmLoginUncheckedCreateInput = {
    id?: string
    uuid: string
    useId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CodeConfirmLoginUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCodeConfirmLoginNestedInput
  }

  export type CodeConfirmLoginUncheckedUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    useId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CodeConfirmLoginCreateManyInput = {
    id?: string
    uuid: string
    useId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CodeConfirmLoginUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CodeConfirmLoginUncheckedUpdateManyInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    useId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CodeConfirmMailCreateInput = {
    id?: string
    uuid: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutCodeConfirmMailInput
  }

  export type CodeConfirmMailUncheckedCreateInput = {
    id?: string
    uuid: string
    useId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CodeConfirmMailUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCodeConfirmMailNestedInput
  }

  export type CodeConfirmMailUncheckedUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    useId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CodeConfirmMailCreateManyInput = {
    id?: string
    uuid: string
    useId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CodeConfirmMailUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CodeConfirmMailUncheckedUpdateManyInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    useId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TokenBlackListCreateInput = {
    id?: string
    token: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TokenBlackListUncheckedCreateInput = {
    id?: string
    token: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TokenBlackListUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TokenBlackListUncheckedUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TokenBlackListCreateManyInput = {
    id?: string
    token: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TokenBlackListUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TokenBlackListUncheckedUpdateManyInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RuleCreateInput = {
    id?: string
    name: string
    keyword: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user?: UserCreateNestedManyWithoutRuleInput
    permissions?: PermissionCreateNestedManyWithoutRulesInput
  }

  export type RuleUncheckedCreateInput = {
    id?: string
    name: string
    keyword: string
    permissionIDs?: RuleCreatepermissionIDsInput | Enumerable<string>
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user?: UserUncheckedCreateNestedManyWithoutRuleInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutRulesInput
  }

  export type RuleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateManyWithoutRuleNestedInput
    permissions?: PermissionUpdateManyWithoutRulesNestedInput
  }

  export type RuleUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    permissionIDs?: RuleUpdatepermissionIDsInput | Enumerable<string>
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUncheckedUpdateManyWithoutRuleNestedInput
    permissions?: PermissionUncheckedUpdateManyWithoutRulesNestedInput
  }

  export type RuleCreateManyInput = {
    id?: string
    name: string
    keyword: string
    permissionIDs?: RuleCreatepermissionIDsInput | Enumerable<string>
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RuleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RuleUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    permissionIDs?: RuleUpdatepermissionIDsInput | Enumerable<string>
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PermissionCreateInput = {
    id?: string
    name: EnumPermission
    keyword: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    rules?: RuleCreateNestedManyWithoutPermissionsInput
    models?: ModelCreateNestedManyWithoutPermissionsInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    name: EnumPermission
    keyword: string
    rulesIDs?: PermissionCreaterulesIDsInput | Enumerable<string>
    modelsIDs?: PermissionCreatemodelsIDsInput | Enumerable<string>
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    rules?: RuleUncheckedCreateNestedManyWithoutPermissionsInput
    models?: ModelUncheckedCreateNestedManyWithoutPermissionsInput
  }

  export type PermissionUpdateInput = {
    name?: EnumEnumPermissionFieldUpdateOperationsInput | EnumPermission
    keyword?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rules?: RuleUpdateManyWithoutPermissionsNestedInput
    models?: ModelUpdateManyWithoutPermissionsNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    name?: EnumEnumPermissionFieldUpdateOperationsInput | EnumPermission
    keyword?: StringFieldUpdateOperationsInput | string
    rulesIDs?: PermissionUpdaterulesIDsInput | Enumerable<string>
    modelsIDs?: PermissionUpdatemodelsIDsInput | Enumerable<string>
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rules?: RuleUncheckedUpdateManyWithoutPermissionsNestedInput
    models?: ModelUncheckedUpdateManyWithoutPermissionsNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: string
    name: EnumPermission
    keyword: string
    rulesIDs?: PermissionCreaterulesIDsInput | Enumerable<string>
    modelsIDs?: PermissionCreatemodelsIDsInput | Enumerable<string>
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PermissionUpdateManyMutationInput = {
    name?: EnumEnumPermissionFieldUpdateOperationsInput | EnumPermission
    keyword?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PermissionUncheckedUpdateManyInput = {
    name?: EnumEnumPermissionFieldUpdateOperationsInput | EnumPermission
    keyword?: StringFieldUpdateOperationsInput | string
    rulesIDs?: PermissionUpdaterulesIDsInput | Enumerable<string>
    modelsIDs?: PermissionUpdatemodelsIDsInput | Enumerable<string>
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelCreateInput = {
    id?: string
    name: string
    keyword: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    permissions?: PermissionCreateNestedManyWithoutModelsInput
  }

  export type ModelUncheckedCreateInput = {
    id?: string
    name: string
    keyword: string
    permissionIDs?: ModelCreatepermissionIDsInput | Enumerable<string>
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    permissions?: PermissionUncheckedCreateNestedManyWithoutModelsInput
  }

  export type ModelUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: PermissionUpdateManyWithoutModelsNestedInput
  }

  export type ModelUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    permissionIDs?: ModelUpdatepermissionIDsInput | Enumerable<string>
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: PermissionUncheckedUpdateManyWithoutModelsNestedInput
  }

  export type ModelCreateManyInput = {
    id?: string
    name: string
    keyword: string
    permissionIDs?: ModelCreatepermissionIDsInput | Enumerable<string>
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    permissionIDs?: ModelUpdatepermissionIDsInput | Enumerable<string>
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AddressCreateInput = {
    id?: string
    firstAdress: string
    secondAdress?: string | null
    zipCode: string
    city: string
    region: string
    country: string
    additionnalInformation?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: string
    firstAdress: string
    secondAdress?: string | null
    zipCode: string
    city: string
    region: string
    country: string
    additionnalInformation?: string | null
    userId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AddressUpdateInput = {
    firstAdress?: StringFieldUpdateOperationsInput | string
    secondAdress?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    additionnalInformation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    firstAdress?: StringFieldUpdateOperationsInput | string
    secondAdress?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    additionnalInformation?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AddressCreateManyInput = {
    id?: string
    firstAdress: string
    secondAdress?: string | null
    zipCode: string
    city: string
    region: string
    country: string
    additionnalInformation?: string | null
    userId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AddressUpdateManyMutationInput = {
    firstAdress?: StringFieldUpdateOperationsInput | string
    secondAdress?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    additionnalInformation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AddressUncheckedUpdateManyInput = {
    firstAdress?: StringFieldUpdateOperationsInput | string
    secondAdress?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    additionnalInformation?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WalletCreateInput = {
    id?: string
    balance: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutWalletInput
    transaction?: TransactionCreateNestedManyWithoutWalletInput
  }

  export type WalletUncheckedCreateInput = {
    id?: string
    balance: number
    userId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
  }

  export type WalletUpdateInput = {
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutWalletNestedInput
    transaction?: TransactionUpdateManyWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateInput = {
    balance?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction?: TransactionUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type WalletCreateManyInput = {
    id?: string
    balance: number
    userId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type WalletUpdateManyMutationInput = {
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WalletUncheckedUpdateManyInput = {
    balance?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxTypeCreateInput = {
    id?: string
    reference: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    box?: BoxCreateNestedManyWithoutBoxTypeInput
  }

  export type BoxTypeUncheckedCreateInput = {
    id?: string
    reference: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    box?: BoxUncheckedCreateNestedManyWithoutBoxTypeInput
  }

  export type BoxTypeUpdateInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    box?: BoxUpdateManyWithoutBoxTypeNestedInput
  }

  export type BoxTypeUncheckedUpdateInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    box?: BoxUncheckedUpdateManyWithoutBoxTypeNestedInput
  }

  export type BoxTypeCreateManyInput = {
    id?: string
    reference: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BoxTypeUpdateManyMutationInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxTypeUncheckedUpdateManyInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxCreateInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    boxImage?: BoxImageCreateNestedManyWithoutBoxInput
    article?: ArticleCreateNestedManyWithoutBoxInput
    transaction?: TransactionCreateNestedManyWithoutBoxInput
    userBox?: UserBoxCreateNestedManyWithoutBoxInput
    bannerImage?: BannerImageCreateNestedManyWithoutBoxInput
    boxParams?: BoxParamsCreateNestedOneWithoutBoxInput
    boxType?: BoxTypeCreateNestedOneWithoutBoxInput
    boxArticle?: BoxArticleCreateNestedManyWithoutBoxInput
    dailyReward?: DailyRewardCreateNestedManyWithoutBoxInput
    boxRewardLevel?: BoxRewardLevelCreateNestedManyWithoutBoxInput
  }

  export type BoxUncheckedCreateInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    boxTypeId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    boxImage?: BoxImageUncheckedCreateNestedManyWithoutBoxInput
    article?: ArticleUncheckedCreateNestedManyWithoutBoxInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutBoxInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutBoxInput
    bannerImage?: BannerImageUncheckedCreateNestedManyWithoutBoxInput
    boxParams?: BoxParamsUncheckedCreateNestedOneWithoutBoxInput
    boxArticle?: BoxArticleUncheckedCreateNestedManyWithoutBoxInput
    dailyReward?: DailyRewardUncheckedCreateNestedManyWithoutBoxInput
    boxRewardLevel?: BoxRewardLevelUncheckedCreateNestedManyWithoutBoxInput
  }

  export type BoxUpdateInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    boxImage?: BoxImageUpdateManyWithoutBoxNestedInput
    article?: ArticleUpdateManyWithoutBoxNestedInput
    transaction?: TransactionUpdateManyWithoutBoxNestedInput
    userBox?: UserBoxUpdateManyWithoutBoxNestedInput
    bannerImage?: BannerImageUpdateManyWithoutBoxNestedInput
    boxParams?: BoxParamsUpdateOneWithoutBoxNestedInput
    boxType?: BoxTypeUpdateOneWithoutBoxNestedInput
    boxArticle?: BoxArticleUpdateManyWithoutBoxNestedInput
    dailyReward?: DailyRewardUpdateManyWithoutBoxNestedInput
    boxRewardLevel?: BoxRewardLevelUpdateManyWithoutBoxNestedInput
  }

  export type BoxUncheckedUpdateInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    boxTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    boxImage?: BoxImageUncheckedUpdateManyWithoutBoxNestedInput
    article?: ArticleUncheckedUpdateManyWithoutBoxNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutBoxNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutBoxNestedInput
    bannerImage?: BannerImageUncheckedUpdateManyWithoutBoxNestedInput
    boxParams?: BoxParamsUncheckedUpdateOneWithoutBoxNestedInput
    boxArticle?: BoxArticleUncheckedUpdateManyWithoutBoxNestedInput
    dailyReward?: DailyRewardUncheckedUpdateManyWithoutBoxNestedInput
    boxRewardLevel?: BoxRewardLevelUncheckedUpdateManyWithoutBoxNestedInput
  }

  export type BoxCreateManyInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    boxTypeId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BoxUpdateManyMutationInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxUncheckedUpdateManyInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    boxTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DailyRewardCreateInput = {
    id?: string
    number: number
    box: BoxCreateNestedOneWithoutDailyRewardInput
  }

  export type DailyRewardUncheckedCreateInput = {
    id?: string
    number: number
    boxId: string
  }

  export type DailyRewardUpdateInput = {
    number?: IntFieldUpdateOperationsInput | number
    box?: BoxUpdateOneRequiredWithoutDailyRewardNestedInput
  }

  export type DailyRewardUncheckedUpdateInput = {
    number?: IntFieldUpdateOperationsInput | number
    boxId?: StringFieldUpdateOperationsInput | string
  }

  export type DailyRewardCreateManyInput = {
    id?: string
    number: number
    boxId: string
  }

  export type DailyRewardUpdateManyMutationInput = {
    number?: IntFieldUpdateOperationsInput | number
  }

  export type DailyRewardUncheckedUpdateManyInput = {
    number?: IntFieldUpdateOperationsInput | number
    boxId?: StringFieldUpdateOperationsInput | string
  }

  export type BoxRewardLevelCreateInput = {
    id?: string
    box: BoxCreateNestedOneWithoutBoxRewardLevelInput
    rewardLevel: RewardLevelCreateNestedOneWithoutBoxRewardLevelInput
  }

  export type BoxRewardLevelUncheckedCreateInput = {
    id?: string
    boxId: string
    rewardLevelId: string
  }

  export type BoxRewardLevelUpdateInput = {
    box?: BoxUpdateOneRequiredWithoutBoxRewardLevelNestedInput
    rewardLevel?: RewardLevelUpdateOneRequiredWithoutBoxRewardLevelNestedInput
  }

  export type BoxRewardLevelUncheckedUpdateInput = {
    boxId?: StringFieldUpdateOperationsInput | string
    rewardLevelId?: StringFieldUpdateOperationsInput | string
  }

  export type BoxRewardLevelCreateManyInput = {
    id?: string
    boxId: string
    rewardLevelId: string
  }

  export type BoxRewardLevelUpdateManyMutationInput = {

  }

  export type BoxRewardLevelUncheckedUpdateManyInput = {
    boxId?: StringFieldUpdateOperationsInput | string
    rewardLevelId?: StringFieldUpdateOperationsInput | string
  }

  export type RewardLevelCreateInput = {
    id?: string
    orderNumber: number
    name: string
    unlockThreshold: number
    description?: string | null
    boxRewardLevel?: BoxRewardLevelCreateNestedManyWithoutRewardLevelInput
  }

  export type RewardLevelUncheckedCreateInput = {
    id?: string
    orderNumber: number
    name: string
    unlockThreshold: number
    description?: string | null
    boxRewardLevel?: BoxRewardLevelUncheckedCreateNestedManyWithoutRewardLevelInput
  }

  export type RewardLevelUpdateInput = {
    orderNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unlockThreshold?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    boxRewardLevel?: BoxRewardLevelUpdateManyWithoutRewardLevelNestedInput
  }

  export type RewardLevelUncheckedUpdateInput = {
    orderNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unlockThreshold?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    boxRewardLevel?: BoxRewardLevelUncheckedUpdateManyWithoutRewardLevelNestedInput
  }

  export type RewardLevelCreateManyInput = {
    id?: string
    orderNumber: number
    name: string
    unlockThreshold: number
    description?: string | null
  }

  export type RewardLevelUpdateManyMutationInput = {
    orderNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unlockThreshold?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RewardLevelUncheckedUpdateManyInput = {
    orderNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unlockThreshold?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BoxImageCreateInput = {
    id?: string
    photoUrl: string
    status: EnumBoxImageStatus
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    box: BoxCreateNestedOneWithoutBoxImageInput
  }

  export type BoxImageUncheckedCreateInput = {
    id?: string
    photoUrl: string
    status: EnumBoxImageStatus
    boxId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BoxImageUpdateInput = {
    photoUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumEnumBoxImageStatusFieldUpdateOperationsInput | EnumBoxImageStatus
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    box?: BoxUpdateOneRequiredWithoutBoxImageNestedInput
  }

  export type BoxImageUncheckedUpdateInput = {
    photoUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumEnumBoxImageStatusFieldUpdateOperationsInput | EnumBoxImageStatus
    boxId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxImageCreateManyInput = {
    id?: string
    photoUrl: string
    status: EnumBoxImageStatus
    boxId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BoxImageUpdateManyMutationInput = {
    photoUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumEnumBoxImageStatusFieldUpdateOperationsInput | EnumBoxImageStatus
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxImageUncheckedUpdateManyInput = {
    photoUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumEnumBoxImageStatusFieldUpdateOperationsInput | EnumBoxImageStatus
    boxId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderCreateInput = {
    id?: string
    reference: string
    companyName: string
    address?: string | null
    phone?: string | null
    webSite?: string | null
    logo?: string | null
    isPinned?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    article?: ArticleCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateInput = {
    id?: string
    reference: string
    companyName: string
    address?: string | null
    phone?: string | null
    webSite?: string | null
    logo?: string | null
    isPinned?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    article?: ArticleUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderUpdateInput = {
    reference?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    webSite?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    article?: ArticleUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateInput = {
    reference?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    webSite?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    article?: ArticleUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ProviderCreateManyInput = {
    id?: string
    reference: string
    companyName: string
    address?: string | null
    phone?: string | null
    webSite?: string | null
    logo?: string | null
    isPinned?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ProviderUpdateManyMutationInput = {
    reference?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    webSite?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderUncheckedUpdateManyInput = {
    reference?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    webSite?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryCreateInput = {
    id?: string
    reference: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    subCategory?: SubCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    reference: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    subCategory?: SubCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subCategory?: SubCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subCategory?: SubCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    reference: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CategoryUpdateManyMutationInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryUncheckedUpdateManyInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubCategoryCreateInput = {
    id?: string
    reference: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutSubCategoryInput
    article?: ArticleCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryUncheckedCreateInput = {
    id?: string
    reference: string
    name: string
    categoryId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    article?: ArticleUncheckedCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryUpdateInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutSubCategoryNestedInput
    article?: ArticleUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryUncheckedUpdateInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    article?: ArticleUncheckedUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryCreateManyInput = {
    id?: string
    reference: string
    name: string
    categoryId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubCategoryUpdateManyMutationInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubCategoryUncheckedUpdateManyInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitySizeCreateInput = {
    id?: string
    name: string
    abbreviation: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    article?: ArticleCreateNestedManyWithoutUnitySizeInput
  }

  export type UnitySizeUncheckedCreateInput = {
    id?: string
    name: string
    abbreviation: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    article?: ArticleUncheckedCreateNestedManyWithoutUnitySizeInput
  }

  export type UnitySizeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    article?: ArticleUpdateManyWithoutUnitySizeNestedInput
  }

  export type UnitySizeUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    article?: ArticleUncheckedUpdateManyWithoutUnitySizeNestedInput
  }

  export type UnitySizeCreateManyInput = {
    id?: string
    name: string
    abbreviation: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UnitySizeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitySizeUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArticleCreateInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    provider?: ProviderCreateNestedOneWithoutArticleInput
    unitySize?: UnitySizeCreateNestedOneWithoutArticleInput
    subCategory?: SubCategoryCreateNestedOneWithoutArticleInput
    box?: BoxCreateNestedOneWithoutArticleInput
    articlePhoto?: ArticlePhotoCreateNestedManyWithoutArticleInput
    post?: PostCreateNestedManyWithoutArticleInput
    price?: PriceCreateNestedOneWithoutArticleInput
    boxArticle?: BoxArticleCreateNestedManyWithoutArticleInput
    game?: GameCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    providerId?: string | null
    unitySizeId?: string | null
    subCategoryId: string
    boxId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    articlePhoto?: ArticlePhotoUncheckedCreateNestedManyWithoutArticleInput
    post?: PostUncheckedCreateNestedManyWithoutArticleInput
    price?: PriceUncheckedCreateNestedOneWithoutArticleInput
    boxArticle?: BoxArticleUncheckedCreateNestedManyWithoutArticleInput
    game?: GameUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleUpdateInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: ProviderUpdateOneWithoutArticleNestedInput
    unitySize?: UnitySizeUpdateOneWithoutArticleNestedInput
    subCategory?: SubCategoryUpdateOneWithoutArticleNestedInput
    box?: BoxUpdateOneWithoutArticleNestedInput
    articlePhoto?: ArticlePhotoUpdateManyWithoutArticleNestedInput
    post?: PostUpdateManyWithoutArticleNestedInput
    price?: PriceUpdateOneWithoutArticleNestedInput
    boxArticle?: BoxArticleUpdateManyWithoutArticleNestedInput
    game?: GameUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    unitySizeId?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: StringFieldUpdateOperationsInput | string
    boxId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    articlePhoto?: ArticlePhotoUncheckedUpdateManyWithoutArticleNestedInput
    post?: PostUncheckedUpdateManyWithoutArticleNestedInput
    price?: PriceUncheckedUpdateOneWithoutArticleNestedInput
    boxArticle?: BoxArticleUncheckedUpdateManyWithoutArticleNestedInput
    game?: GameUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleCreateManyInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    providerId?: string | null
    unitySizeId?: string | null
    subCategoryId: string
    boxId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ArticleUpdateManyMutationInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArticleUncheckedUpdateManyInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    unitySizeId?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: StringFieldUpdateOperationsInput | string
    boxId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxArticleCreateInput = {
    id?: string
    winningChance: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    box: BoxCreateNestedOneWithoutBoxArticleInput
    article: ArticleCreateNestedOneWithoutBoxArticleInput
  }

  export type BoxArticleUncheckedCreateInput = {
    id?: string
    winningChance: number
    boxId: string
    articleId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BoxArticleUpdateInput = {
    winningChance?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    box?: BoxUpdateOneRequiredWithoutBoxArticleNestedInput
    article?: ArticleUpdateOneRequiredWithoutBoxArticleNestedInput
  }

  export type BoxArticleUncheckedUpdateInput = {
    winningChance?: FloatFieldUpdateOperationsInput | number
    boxId?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxArticleCreateManyInput = {
    id?: string
    winningChance: number
    boxId: string
    articleId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BoxArticleUpdateManyMutationInput = {
    winningChance?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxArticleUncheckedUpdateManyInput = {
    winningChance?: FloatFieldUpdateOperationsInput | number
    boxId?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArticlePhotoCreateInput = {
    id?: string
    photoUrl: string
    status?: ArticlePhotoStatus | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    article: ArticleCreateNestedOneWithoutArticlePhotoInput
  }

  export type ArticlePhotoUncheckedCreateInput = {
    id?: string
    photoUrl: string
    status?: ArticlePhotoStatus | null
    articleId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ArticlePhotoUpdateInput = {
    photoUrl?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumArticlePhotoStatusFieldUpdateOperationsInput | ArticlePhotoStatus | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    article?: ArticleUpdateOneRequiredWithoutArticlePhotoNestedInput
  }

  export type ArticlePhotoUncheckedUpdateInput = {
    photoUrl?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumArticlePhotoStatusFieldUpdateOperationsInput | ArticlePhotoStatus | null
    articleId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArticlePhotoCreateManyInput = {
    id?: string
    photoUrl: string
    status?: ArticlePhotoStatus | null
    articleId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ArticlePhotoUpdateManyMutationInput = {
    photoUrl?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumArticlePhotoStatusFieldUpdateOperationsInput | ArticlePhotoStatus | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArticlePhotoUncheckedUpdateManyInput = {
    photoUrl?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumArticlePhotoStatusFieldUpdateOperationsInput | ArticlePhotoStatus | null
    articleId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostCreateInput = {
    id?: string
    title: string
    content: string
    postUrl: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    article: ArticleCreateNestedOneWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    postUrl: string
    articleId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PostUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    article?: ArticleUpdateOneRequiredWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postUrl?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostCreateManyInput = {
    id?: string
    title: string
    content: string
    postUrl: string
    articleId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PostUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postUrl?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PriceCreateInput = {
    id?: string
    reference?: string | null
    currentPrice: number
    oldPrice?: number | null
    rate?: number | null
    reduction?: number | null
    sellingPrice?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    article: ArticleCreateNestedOneWithoutPriceInput
  }

  export type PriceUncheckedCreateInput = {
    id?: string
    reference?: string | null
    currentPrice: number
    oldPrice?: number | null
    rate?: number | null
    reduction?: number | null
    sellingPrice?: number | null
    articleId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PriceUpdateInput = {
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    oldPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    reduction?: NullableFloatFieldUpdateOperationsInput | number | null
    sellingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    article?: ArticleUpdateOneRequiredWithoutPriceNestedInput
  }

  export type PriceUncheckedUpdateInput = {
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    oldPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    reduction?: NullableFloatFieldUpdateOperationsInput | number | null
    sellingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    articleId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PriceCreateManyInput = {
    id?: string
    reference?: string | null
    currentPrice: number
    oldPrice?: number | null
    rate?: number | null
    reduction?: number | null
    sellingPrice?: number | null
    articleId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PriceUpdateManyMutationInput = {
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    oldPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    reduction?: NullableFloatFieldUpdateOperationsInput | number | null
    sellingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PriceUncheckedUpdateManyInput = {
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    oldPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    reduction?: NullableFloatFieldUpdateOperationsInput | number | null
    sellingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    articleId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderCreateInput = {
    id?: string
    status?: EnumOrderStatus
    followedLink?: string | null
    orderNumber?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    shoppingCart: ShoppingCartCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    status?: EnumOrderStatus
    followedLink?: string | null
    orderNumber?: string | null
    shoppingCartId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrderUpdateInput = {
    status?: EnumEnumOrderStatusFieldUpdateOperationsInput | EnumOrderStatus
    followedLink?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shoppingCart?: ShoppingCartUpdateOneRequiredWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    status?: EnumEnumOrderStatusFieldUpdateOperationsInput | EnumOrderStatus
    followedLink?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingCartId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderCreateManyInput = {
    id?: string
    status?: EnumOrderStatus
    followedLink?: string | null
    orderNumber?: string | null
    shoppingCartId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrderUpdateManyMutationInput = {
    status?: EnumEnumOrderStatusFieldUpdateOperationsInput | EnumOrderStatus
    followedLink?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    status?: EnumEnumOrderStatusFieldUpdateOperationsInput | EnumOrderStatus
    followedLink?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingCartId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShoppingCartCreateInput = {
    id?: string
    winningDate: Date | string
    isClaimed?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    game: GameCreateNestedOneWithoutShoppingCartInput
    user: UserCreateNestedOneWithoutShoppingCartInput
    transaction?: TransactionCreateNestedManyWithoutShoppingCartInput
    order?: OrderCreateNestedOneWithoutShoppingCartInput
  }

  export type ShoppingCartUncheckedCreateInput = {
    id?: string
    winningDate: Date | string
    isClaimed?: boolean | null
    gameId: string
    userId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    transaction?: TransactionUncheckedCreateNestedManyWithoutShoppingCartInput
    order?: OrderUncheckedCreateNestedOneWithoutShoppingCartInput
  }

  export type ShoppingCartUpdateInput = {
    winningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    game?: GameUpdateOneRequiredWithoutShoppingCartNestedInput
    user?: UserUpdateOneRequiredWithoutShoppingCartNestedInput
    transaction?: TransactionUpdateManyWithoutShoppingCartNestedInput
    order?: OrderUpdateOneWithoutShoppingCartNestedInput
  }

  export type ShoppingCartUncheckedUpdateInput = {
    winningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction?: TransactionUncheckedUpdateManyWithoutShoppingCartNestedInput
    order?: OrderUncheckedUpdateOneWithoutShoppingCartNestedInput
  }

  export type ShoppingCartCreateManyInput = {
    id?: string
    winningDate: Date | string
    isClaimed?: boolean | null
    gameId: string
    userId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ShoppingCartUpdateManyMutationInput = {
    winningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShoppingCartUncheckedUpdateManyInput = {
    winningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionCreateInput = {
    id?: string
    type: EnumTypeTransaction
    date: Date | string
    amount: number
    status: EnumStatusTransaction
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    box?: BoxCreateNestedOneWithoutTransactionInput
    wallet: WalletCreateNestedOneWithoutTransactionInput
    offer?: OfferCreateNestedOneWithoutTransactionInput
    shoppingCart?: ShoppingCartCreateNestedOneWithoutTransactionInput
    bank?: BankCreateNestedOneWithoutTransactionInput
    game?: GameCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    type: EnumTypeTransaction
    date: Date | string
    amount: number
    status: EnumStatusTransaction
    boxId?: string | null
    walletId: string
    offerId?: string | null
    shoppingCartId?: string | null
    bankId?: string | null
    gameId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TransactionUpdateInput = {
    type?: EnumEnumTypeTransactionFieldUpdateOperationsInput | EnumTypeTransaction
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumEnumStatusTransactionFieldUpdateOperationsInput | EnumStatusTransaction
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    box?: BoxUpdateOneWithoutTransactionNestedInput
    wallet?: WalletUpdateOneRequiredWithoutTransactionNestedInput
    offer?: OfferUpdateOneWithoutTransactionNestedInput
    shoppingCart?: ShoppingCartUpdateOneWithoutTransactionNestedInput
    bank?: BankUpdateOneWithoutTransactionNestedInput
    game?: GameUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    type?: EnumEnumTypeTransactionFieldUpdateOperationsInput | EnumTypeTransaction
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumEnumStatusTransactionFieldUpdateOperationsInput | EnumStatusTransaction
    boxId?: NullableStringFieldUpdateOperationsInput | string | null
    walletId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingCartId?: NullableStringFieldUpdateOperationsInput | string | null
    bankId?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionCreateManyInput = {
    id?: string
    type: EnumTypeTransaction
    date: Date | string
    amount: number
    status: EnumStatusTransaction
    boxId?: string | null
    walletId: string
    offerId?: string | null
    shoppingCartId?: string | null
    bankId?: string | null
    gameId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TransactionUpdateManyMutationInput = {
    type?: EnumEnumTypeTransactionFieldUpdateOperationsInput | EnumTypeTransaction
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumEnumStatusTransactionFieldUpdateOperationsInput | EnumStatusTransaction
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUncheckedUpdateManyInput = {
    type?: EnumEnumTypeTransactionFieldUpdateOperationsInput | EnumTypeTransaction
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumEnumStatusTransactionFieldUpdateOperationsInput | EnumStatusTransaction
    boxId?: NullableStringFieldUpdateOperationsInput | string | null
    walletId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingCartId?: NullableStringFieldUpdateOperationsInput | string | null
    bankId?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BankCreateInput = {
    id?: string
    accountNumber: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    transaction?: TransactionCreateNestedManyWithoutBankInput
  }

  export type BankUncheckedCreateInput = {
    id?: string
    accountNumber: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    transaction?: TransactionUncheckedCreateNestedManyWithoutBankInput
  }

  export type BankUpdateInput = {
    accountNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction?: TransactionUpdateManyWithoutBankNestedInput
  }

  export type BankUncheckedUpdateInput = {
    accountNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction?: TransactionUncheckedUpdateManyWithoutBankNestedInput
  }

  export type BankCreateManyInput = {
    id?: string
    accountNumber: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BankUpdateManyMutationInput = {
    accountNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BankUncheckedUpdateManyInput = {
    accountNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserBoxCreateInput = {
    id?: string
    type: EnumUserBoxType
    duration?: Date | string | null
    dayNumber?: number | null
    isPlayed?: boolean | null
    isLocked?: boolean | null
    playedDate?: Date | string | null
    activationDate?: Date | string | null
    deactivationDate?: Date | string | null
    orderNumber?: number | null
    name?: string | null
    unlockThreshold?: number | null
    description?: string | null
    lot?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutUserBoxInput
    box: BoxCreateNestedOneWithoutUserBoxInput
    game?: GameCreateNestedManyWithoutUserBoxInput
  }

  export type UserBoxUncheckedCreateInput = {
    id?: string
    type: EnumUserBoxType
    duration?: Date | string | null
    dayNumber?: number | null
    isPlayed?: boolean | null
    isLocked?: boolean | null
    playedDate?: Date | string | null
    activationDate?: Date | string | null
    deactivationDate?: Date | string | null
    orderNumber?: number | null
    name?: string | null
    unlockThreshold?: number | null
    description?: string | null
    userId: string
    boxId: string
    lot?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    game?: GameUncheckedCreateNestedManyWithoutUserBoxInput
  }

  export type UserBoxUpdateInput = {
    type?: EnumEnumUserBoxTypeFieldUpdateOperationsInput | EnumUserBoxType
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isPlayed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    playedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderNumber?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unlockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lot?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserBoxNestedInput
    box?: BoxUpdateOneRequiredWithoutUserBoxNestedInput
    game?: GameUpdateManyWithoutUserBoxNestedInput
  }

  export type UserBoxUncheckedUpdateInput = {
    type?: EnumEnumUserBoxTypeFieldUpdateOperationsInput | EnumUserBoxType
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isPlayed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    playedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderNumber?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unlockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    boxId?: StringFieldUpdateOperationsInput | string
    lot?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    game?: GameUncheckedUpdateManyWithoutUserBoxNestedInput
  }

  export type UserBoxCreateManyInput = {
    id?: string
    type: EnumUserBoxType
    duration?: Date | string | null
    dayNumber?: number | null
    isPlayed?: boolean | null
    isLocked?: boolean | null
    playedDate?: Date | string | null
    activationDate?: Date | string | null
    deactivationDate?: Date | string | null
    orderNumber?: number | null
    name?: string | null
    unlockThreshold?: number | null
    description?: string | null
    userId: string
    boxId: string
    lot?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UserBoxUpdateManyMutationInput = {
    type?: EnumEnumUserBoxTypeFieldUpdateOperationsInput | EnumUserBoxType
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isPlayed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    playedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderNumber?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unlockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lot?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserBoxUncheckedUpdateManyInput = {
    type?: EnumEnumUserBoxTypeFieldUpdateOperationsInput | EnumUserBoxType
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isPlayed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    playedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderNumber?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unlockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    boxId?: StringFieldUpdateOperationsInput | string
    lot?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BannerImageCreateInput = {
    id?: string
    bannerImgUrl: string
    bannerLink?: string | null
    type?: BannerImageType | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    box?: BoxCreateNestedOneWithoutBannerImageInput
    offer?: OfferCreateNestedOneWithoutBannerImageInput
  }

  export type BannerImageUncheckedCreateInput = {
    id?: string
    bannerImgUrl: string
    bannerLink?: string | null
    type?: BannerImageType | null
    boxId?: string | null
    offerId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BannerImageUpdateInput = {
    bannerImgUrl?: StringFieldUpdateOperationsInput | string
    bannerLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumBannerImageTypeFieldUpdateOperationsInput | BannerImageType | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    box?: BoxUpdateOneWithoutBannerImageNestedInput
    offer?: OfferUpdateOneWithoutBannerImageNestedInput
  }

  export type BannerImageUncheckedUpdateInput = {
    bannerImgUrl?: StringFieldUpdateOperationsInput | string
    bannerLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumBannerImageTypeFieldUpdateOperationsInput | BannerImageType | null
    boxId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BannerImageCreateManyInput = {
    id?: string
    bannerImgUrl: string
    bannerLink?: string | null
    type?: BannerImageType | null
    boxId?: string | null
    offerId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BannerImageUpdateManyMutationInput = {
    bannerImgUrl?: StringFieldUpdateOperationsInput | string
    bannerLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumBannerImageTypeFieldUpdateOperationsInput | BannerImageType | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BannerImageUncheckedUpdateManyInput = {
    bannerImgUrl?: StringFieldUpdateOperationsInput | string
    bannerLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumBannerImageTypeFieldUpdateOperationsInput | BannerImageType | null
    boxId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxParamsCreateInput = {
    id?: string
    isBestSelling?: boolean
    isRecommended?: boolean
    isNew?: boolean
    isBigPrice?: boolean
    isSubsciptionBonus?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    box?: BoxCreateNestedOneWithoutBoxParamsInput
  }

  export type BoxParamsUncheckedCreateInput = {
    id?: string
    isBestSelling?: boolean
    isRecommended?: boolean
    isNew?: boolean
    isBigPrice?: boolean
    isSubsciptionBonus?: boolean
    boxId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BoxParamsUpdateInput = {
    isBestSelling?: BoolFieldUpdateOperationsInput | boolean
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isBigPrice?: BoolFieldUpdateOperationsInput | boolean
    isSubsciptionBonus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    box?: BoxUpdateOneWithoutBoxParamsNestedInput
  }

  export type BoxParamsUncheckedUpdateInput = {
    isBestSelling?: BoolFieldUpdateOperationsInput | boolean
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isBigPrice?: BoolFieldUpdateOperationsInput | boolean
    isSubsciptionBonus?: BoolFieldUpdateOperationsInput | boolean
    boxId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxParamsCreateManyInput = {
    id?: string
    isBestSelling?: boolean
    isRecommended?: boolean
    isNew?: boolean
    isBigPrice?: boolean
    isSubsciptionBonus?: boolean
    boxId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BoxParamsUpdateManyMutationInput = {
    isBestSelling?: BoolFieldUpdateOperationsInput | boolean
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isBigPrice?: BoolFieldUpdateOperationsInput | boolean
    isSubsciptionBonus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxParamsUncheckedUpdateManyInput = {
    isBestSelling?: BoolFieldUpdateOperationsInput | boolean
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isBigPrice?: BoolFieldUpdateOperationsInput | boolean
    isSubsciptionBonus?: BoolFieldUpdateOperationsInput | boolean
    boxId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HistoricalCreateInput = {
    id?: string
    date: Date | string
    description: string
    action: EnumHistoricalAction
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutHistoricalInput
  }

  export type HistoricalUncheckedCreateInput = {
    id?: string
    date: Date | string
    description: string
    userId: string
    action: EnumHistoricalAction
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type HistoricalUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    action?: EnumEnumHistoricalActionFieldUpdateOperationsInput | EnumHistoricalAction
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutHistoricalNestedInput
  }

  export type HistoricalUncheckedUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: EnumEnumHistoricalActionFieldUpdateOperationsInput | EnumHistoricalAction
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HistoricalCreateManyInput = {
    id?: string
    date: Date | string
    description: string
    userId: string
    action: EnumHistoricalAction
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type HistoricalUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    action?: EnumEnumHistoricalActionFieldUpdateOperationsInput | EnumHistoricalAction
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HistoricalUncheckedUpdateManyInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: EnumEnumHistoricalActionFieldUpdateOperationsInput | EnumHistoricalAction
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateInput = {
    id?: string
    message: string
    sendingDate: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sender: UserCreateNestedOneWithoutMessageInput
    receiver?: ReceiverCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    message: string
    sendingDate: Date | string
    senderId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    receiver?: ReceiverUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    sendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender?: UserUpdateOneRequiredWithoutMessageNestedInput
    receiver?: ReceiverUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    sendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiver?: ReceiverUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    message: string
    sendingDate: Date | string
    senderId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MessageUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    sendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUncheckedUpdateManyInput = {
    message?: StringFieldUpdateOperationsInput | string
    sendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReceiverCreateInput = {
    id?: string
    readingDate: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    receiver: UserCreateNestedOneWithoutReceiverInput
    message: MessageCreateNestedOneWithoutReceiverInput
  }

  export type ReceiverUncheckedCreateInput = {
    id?: string
    readingDate: Date | string
    receiverId: string
    messageId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ReceiverUpdateInput = {
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiver?: UserUpdateOneRequiredWithoutReceiverNestedInput
    message?: MessageUpdateOneRequiredWithoutReceiverNestedInput
  }

  export type ReceiverUncheckedUpdateInput = {
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReceiverCreateManyInput = {
    id?: string
    readingDate: Date | string
    receiverId: string
    messageId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ReceiverUpdateManyMutationInput = {
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReceiverUncheckedUpdateManyInput = {
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsLetterCreateInput = {
    id?: string
    email: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type NewsLetterUncheckedCreateInput = {
    id?: string
    email: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type NewsLetterUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsLetterUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsLetterCreateManyInput = {
    id?: string
    email: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type NewsLetterUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NewsLetterUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TemoignageCreateInput = {
    id?: string
    comment: string
    rating: number
    commentDate: Date | string
    isToShow?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutTemoignageInput
  }

  export type TemoignageUncheckedCreateInput = {
    id?: string
    comment: string
    rating: number
    commentDate: Date | string
    isToShow?: boolean
    userId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TemoignageUpdateInput = {
    comment?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    commentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isToShow?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTemoignageNestedInput
  }

  export type TemoignageUncheckedUpdateInput = {
    comment?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    commentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isToShow?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TemoignageCreateManyInput = {
    id?: string
    comment: string
    rating: number
    commentDate: Date | string
    isToShow?: boolean
    userId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TemoignageUpdateManyMutationInput = {
    comment?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    commentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isToShow?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TemoignageUncheckedUpdateManyInput = {
    comment?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    commentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isToShow?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfferCreateInput = {
    id?: string
    name: string
    price: number
    priceThreeMonth?: number | null
    color?: string | null
    numberMysteryBoxBronze?: number
    numberMysteryBoxSylver?: number
    numberMysteryBoxGold?: number
    isAwardLevelActive?: boolean
    isWeeklyAwardActive?: boolean
    isStandardSupportActive?: boolean
    isVIPSupportActive?: boolean
    duration?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    subscription?: SubscriptionCreateNestedManyWithoutOfferInput
    bannerImage?: BannerImageCreateNestedManyWithoutOfferInput
    transaction?: TransactionCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateInput = {
    id?: string
    name: string
    price: number
    priceThreeMonth?: number | null
    color?: string | null
    numberMysteryBoxBronze?: number
    numberMysteryBoxSylver?: number
    numberMysteryBoxGold?: number
    isAwardLevelActive?: boolean
    isWeeklyAwardActive?: boolean
    isStandardSupportActive?: boolean
    isVIPSupportActive?: boolean
    duration?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutOfferInput
    bannerImage?: BannerImageUncheckedCreateNestedManyWithoutOfferInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceThreeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    numberMysteryBoxBronze?: IntFieldUpdateOperationsInput | number
    numberMysteryBoxSylver?: IntFieldUpdateOperationsInput | number
    numberMysteryBoxGold?: IntFieldUpdateOperationsInput | number
    isAwardLevelActive?: BoolFieldUpdateOperationsInput | boolean
    isWeeklyAwardActive?: BoolFieldUpdateOperationsInput | boolean
    isStandardSupportActive?: BoolFieldUpdateOperationsInput | boolean
    isVIPSupportActive?: BoolFieldUpdateOperationsInput | boolean
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription?: SubscriptionUpdateManyWithoutOfferNestedInput
    bannerImage?: BannerImageUpdateManyWithoutOfferNestedInput
    transaction?: TransactionUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceThreeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    numberMysteryBoxBronze?: IntFieldUpdateOperationsInput | number
    numberMysteryBoxSylver?: IntFieldUpdateOperationsInput | number
    numberMysteryBoxGold?: IntFieldUpdateOperationsInput | number
    isAwardLevelActive?: BoolFieldUpdateOperationsInput | boolean
    isWeeklyAwardActive?: BoolFieldUpdateOperationsInput | boolean
    isStandardSupportActive?: BoolFieldUpdateOperationsInput | boolean
    isVIPSupportActive?: BoolFieldUpdateOperationsInput | boolean
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutOfferNestedInput
    bannerImage?: BannerImageUncheckedUpdateManyWithoutOfferNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type OfferCreateManyInput = {
    id?: string
    name: string
    price: number
    priceThreeMonth?: number | null
    color?: string | null
    numberMysteryBoxBronze?: number
    numberMysteryBoxSylver?: number
    numberMysteryBoxGold?: number
    isAwardLevelActive?: boolean
    isWeeklyAwardActive?: boolean
    isStandardSupportActive?: boolean
    isVIPSupportActive?: boolean
    duration?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OfferUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceThreeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    numberMysteryBoxBronze?: IntFieldUpdateOperationsInput | number
    numberMysteryBoxSylver?: IntFieldUpdateOperationsInput | number
    numberMysteryBoxGold?: IntFieldUpdateOperationsInput | number
    isAwardLevelActive?: BoolFieldUpdateOperationsInput | boolean
    isWeeklyAwardActive?: BoolFieldUpdateOperationsInput | boolean
    isStandardSupportActive?: BoolFieldUpdateOperationsInput | boolean
    isVIPSupportActive?: BoolFieldUpdateOperationsInput | boolean
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfferUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceThreeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    numberMysteryBoxBronze?: IntFieldUpdateOperationsInput | number
    numberMysteryBoxSylver?: IntFieldUpdateOperationsInput | number
    numberMysteryBoxGold?: IntFieldUpdateOperationsInput | number
    isAwardLevelActive?: BoolFieldUpdateOperationsInput | boolean
    isWeeklyAwardActive?: BoolFieldUpdateOperationsInput | boolean
    isStandardSupportActive?: BoolFieldUpdateOperationsInput | boolean
    isVIPSupportActive?: BoolFieldUpdateOperationsInput | boolean
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    durationType?: EnumPriceSubscription | null
    status?: EnumStatusSubscription | null
    autoRenewal?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutSubscriptionInput
    offer: OfferCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    durationType?: EnumPriceSubscription | null
    status?: EnumStatusSubscription | null
    autoRenewal?: boolean
    userId: string
    offerId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubscriptionUpdateInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationType?: NullableEnumEnumPriceSubscriptionFieldUpdateOperationsInput | EnumPriceSubscription | null
    status?: NullableEnumEnumStatusSubscriptionFieldUpdateOperationsInput | EnumStatusSubscription | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
    offer?: OfferUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationType?: NullableEnumEnumPriceSubscriptionFieldUpdateOperationsInput | EnumPriceSubscription | null
    status?: NullableEnumEnumStatusSubscriptionFieldUpdateOperationsInput | EnumStatusSubscription | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    durationType?: EnumPriceSubscription | null
    status?: EnumStatusSubscription | null
    autoRenewal?: boolean
    userId: string
    offerId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubscriptionUpdateManyMutationInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationType?: NullableEnumEnumPriceSubscriptionFieldUpdateOperationsInput | EnumPriceSubscription | null
    status?: NullableEnumEnumStatusSubscriptionFieldUpdateOperationsInput | EnumStatusSubscription | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationType?: NullableEnumEnumPriceSubscriptionFieldUpdateOperationsInput | EnumPriceSubscription | null
    status?: NullableEnumEnumStatusSubscriptionFieldUpdateOperationsInput | EnumStatusSubscription | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameCreateInput = {
    id?: string
    reference: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: EnumStatusGame
    version?: EnumVersionGame | null
    type?: EnumTypeGame | null
    gainPercentage?: number | null
    gainDraw?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    userBox?: UserBoxCreateNestedOneWithoutGameInput
    patronage?: PatronageCreateNestedOneWithoutGameInput
    article?: ArticleCreateNestedOneWithoutGameInput
    shoppingCart?: ShoppingCartCreateNestedOneWithoutGameInput
    transaction?: TransactionCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateInput = {
    id?: string
    reference: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: EnumStatusGame
    version?: EnumVersionGame | null
    type?: EnumTypeGame | null
    userBoxId?: string | null
    patronageId?: string | null
    gainPercentage?: number | null
    gainDraw?: number | null
    articleId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    shoppingCart?: ShoppingCartUncheckedCreateNestedOneWithoutGameInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameUpdateInput = {
    reference?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEnumStatusGameFieldUpdateOperationsInput | EnumStatusGame
    version?: NullableEnumEnumVersionGameFieldUpdateOperationsInput | EnumVersionGame | null
    type?: NullableEnumEnumTypeGameFieldUpdateOperationsInput | EnumTypeGame | null
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gainDraw?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userBox?: UserBoxUpdateOneWithoutGameNestedInput
    patronage?: PatronageUpdateOneWithoutGameNestedInput
    article?: ArticleUpdateOneWithoutGameNestedInput
    shoppingCart?: ShoppingCartUpdateOneWithoutGameNestedInput
    transaction?: TransactionUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateInput = {
    reference?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEnumStatusGameFieldUpdateOperationsInput | EnumStatusGame
    version?: NullableEnumEnumVersionGameFieldUpdateOperationsInput | EnumVersionGame | null
    type?: NullableEnumEnumTypeGameFieldUpdateOperationsInput | EnumTypeGame | null
    userBoxId?: NullableStringFieldUpdateOperationsInput | string | null
    patronageId?: NullableStringFieldUpdateOperationsInput | string | null
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gainDraw?: NullableFloatFieldUpdateOperationsInput | number | null
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shoppingCart?: ShoppingCartUncheckedUpdateOneWithoutGameNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameCreateManyInput = {
    id?: string
    reference: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: EnumStatusGame
    version?: EnumVersionGame | null
    type?: EnumTypeGame | null
    userBoxId?: string | null
    patronageId?: string | null
    gainPercentage?: number | null
    gainDraw?: number | null
    articleId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type GameUpdateManyMutationInput = {
    reference?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEnumStatusGameFieldUpdateOperationsInput | EnumStatusGame
    version?: NullableEnumEnumVersionGameFieldUpdateOperationsInput | EnumVersionGame | null
    type?: NullableEnumEnumTypeGameFieldUpdateOperationsInput | EnumTypeGame | null
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gainDraw?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameUncheckedUpdateManyInput = {
    reference?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEnumStatusGameFieldUpdateOperationsInput | EnumStatusGame
    version?: NullableEnumEnumVersionGameFieldUpdateOperationsInput | EnumVersionGame | null
    type?: NullableEnumEnumTypeGameFieldUpdateOperationsInput | EnumTypeGame | null
    userBoxId?: NullableStringFieldUpdateOperationsInput | string | null
    patronageId?: NullableStringFieldUpdateOperationsInput | string | null
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gainDraw?: NullableFloatFieldUpdateOperationsInput | number | null
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
    isSet?: boolean
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type EnumEnumGenderNullableFilter = {
    equals?: EnumGender | null
    in?: Enumerable<EnumGender> | null
    notIn?: Enumerable<EnumGender> | null
    not?: NestedEnumEnumGenderNullableFilter | EnumGender | null
    isSet?: boolean
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
    isSet?: boolean
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
    isSet?: boolean
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
    isSet?: boolean
  }

  export type RuleRelationFilter = {
    is?: RuleWhereInput | null
    isNot?: RuleWhereInput | null
  }

  export type AddressRelationFilter = {
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
  }

  export type CodeConfirmLoginListRelationFilter = {
    every?: CodeConfirmLoginWhereInput
    some?: CodeConfirmLoginWhereInput
    none?: CodeConfirmLoginWhereInput
  }

  export type CodeConfirmMailListRelationFilter = {
    every?: CodeConfirmMailWhereInput
    some?: CodeConfirmMailWhereInput
    none?: CodeConfirmMailWhereInput
  }

  export type WalletRelationFilter = {
    is?: WalletWhereInput
    isNot?: WalletWhereInput
  }

  export type ShoppingCartListRelationFilter = {
    every?: ShoppingCartWhereInput
    some?: ShoppingCartWhereInput
    none?: ShoppingCartWhereInput
  }

  export type UserBoxListRelationFilter = {
    every?: UserBoxWhereInput
    some?: UserBoxWhereInput
    none?: UserBoxWhereInput
  }

  export type HistoricalListRelationFilter = {
    every?: HistoricalWhereInput
    some?: HistoricalWhereInput
    none?: HistoricalWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ReceiverListRelationFilter = {
    every?: ReceiverWhereInput
    some?: ReceiverWhereInput
    none?: ReceiverWhereInput
  }

  export type TemoignageListRelationFilter = {
    every?: TemoignageWhereInput
    some?: TemoignageWhereInput
    none?: TemoignageWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type PatronageListRelationFilter = {
    every?: PatronageWhereInput
    some?: PatronageWhereInput
    none?: PatronageWhereInput
  }

  export type PatronageRelationFilter = {
    is?: PatronageWhereInput | null
    isNot?: PatronageWhereInput | null
  }

  export type CodeConfirmLoginOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CodeConfirmMailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShoppingCartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBoxOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HistoricalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReceiverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemoignageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatronageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    photoUrl?: SortOrder
    email?: SortOrder
    isActif?: SortOrder
    isMember?: SortOrder
    isAdmin?: SortOrder
    emailIsVerified?: SortOrder
    twoAuthIsActive?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    password?: SortOrder
    socketId?: SortOrder
    refreshToken?: SortOrder
    supportingDocumentUrl?: SortOrder
    isValideSupportingDocument?: SortOrder
    registrationBonus?: SortOrder
    latestConnectedDate?: SortOrder
    signInCount?: SortOrder
    lotCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ruleId?: SortOrder
    stripeCustomerId?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    registrationBonus?: SortOrder
    signInCount?: SortOrder
    lotCount?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    photoUrl?: SortOrder
    email?: SortOrder
    isActif?: SortOrder
    isMember?: SortOrder
    isAdmin?: SortOrder
    emailIsVerified?: SortOrder
    twoAuthIsActive?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    password?: SortOrder
    socketId?: SortOrder
    refreshToken?: SortOrder
    supportingDocumentUrl?: SortOrder
    isValideSupportingDocument?: SortOrder
    registrationBonus?: SortOrder
    latestConnectedDate?: SortOrder
    signInCount?: SortOrder
    lotCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ruleId?: SortOrder
    stripeCustomerId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    photoUrl?: SortOrder
    email?: SortOrder
    isActif?: SortOrder
    isMember?: SortOrder
    isAdmin?: SortOrder
    emailIsVerified?: SortOrder
    twoAuthIsActive?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    password?: SortOrder
    socketId?: SortOrder
    refreshToken?: SortOrder
    supportingDocumentUrl?: SortOrder
    isValideSupportingDocument?: SortOrder
    registrationBonus?: SortOrder
    latestConnectedDate?: SortOrder
    signInCount?: SortOrder
    lotCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ruleId?: SortOrder
    stripeCustomerId?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    registrationBonus?: SortOrder
    signInCount?: SortOrder
    lotCount?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    isSet?: boolean
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type EnumEnumGenderNullableWithAggregatesFilter = {
    equals?: EnumGender | null
    in?: Enumerable<EnumGender> | null
    notIn?: Enumerable<EnumGender> | null
    not?: NestedEnumEnumGenderNullableWithAggregatesFilter | EnumGender | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumEnumGenderNullableFilter
    _max?: NestedEnumEnumGenderNullableFilter
    isSet?: boolean
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    isSet?: boolean
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
    isSet?: boolean
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    isSet?: boolean
  }

  export type EnumEnumStatusPatronageNullableFilter = {
    equals?: EnumStatusPatronage | null
    in?: Enumerable<EnumStatusPatronage> | null
    notIn?: Enumerable<EnumStatusPatronage> | null
    not?: NestedEnumEnumStatusPatronageNullableFilter | EnumStatusPatronage | null
    isSet?: boolean
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
    isSet?: boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type GameListRelationFilter = {
    every?: GameWhereInput
    some?: GameWhereInput
    none?: GameWhereInput
  }

  export type GameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatronageCountOrderByAggregateInput = {
    id?: SortOrder
    gainPercentage?: SortOrder
    discountPercentage?: SortOrder
    status?: SortOrder
    bonusEndDate?: SortOrder
    userParentId?: SortOrder
    userChildId?: SortOrder
    bonusCollect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatronageAvgOrderByAggregateInput = {
    gainPercentage?: SortOrder
    discountPercentage?: SortOrder
  }

  export type PatronageMaxOrderByAggregateInput = {
    id?: SortOrder
    gainPercentage?: SortOrder
    discountPercentage?: SortOrder
    status?: SortOrder
    bonusEndDate?: SortOrder
    userParentId?: SortOrder
    userChildId?: SortOrder
    bonusCollect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatronageMinOrderByAggregateInput = {
    id?: SortOrder
    gainPercentage?: SortOrder
    discountPercentage?: SortOrder
    status?: SortOrder
    bonusEndDate?: SortOrder
    userParentId?: SortOrder
    userChildId?: SortOrder
    bonusCollect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatronageSumOrderByAggregateInput = {
    gainPercentage?: SortOrder
    discountPercentage?: SortOrder
  }

  export type EnumEnumStatusPatronageNullableWithAggregatesFilter = {
    equals?: EnumStatusPatronage | null
    in?: Enumerable<EnumStatusPatronage> | null
    notIn?: Enumerable<EnumStatusPatronage> | null
    not?: NestedEnumEnumStatusPatronageNullableWithAggregatesFilter | EnumStatusPatronage | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumEnumStatusPatronageNullableFilter
    _max?: NestedEnumEnumStatusPatronageNullableFilter
    isSet?: boolean
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
    isSet?: boolean
  }

  export type CodeConfirmLoginCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    useId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CodeConfirmLoginMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    useId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CodeConfirmLoginMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    useId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CodeConfirmMailCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    useId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CodeConfirmMailMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    useId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CodeConfirmMailMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    useId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TokenBlackListCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TokenBlackListMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TokenBlackListMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type PermissionListRelationFilter = {
    every?: PermissionWhereInput
    some?: PermissionWhereInput
    none?: PermissionWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RuleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    keyword?: SortOrder
    permissionIDs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RuleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    keyword?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RuleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    keyword?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEnumPermissionFilter = {
    equals?: EnumPermission
    in?: Enumerable<EnumPermission>
    notIn?: Enumerable<EnumPermission>
    not?: NestedEnumEnumPermissionFilter | EnumPermission
  }

  export type RuleListRelationFilter = {
    every?: RuleWhereInput
    some?: RuleWhereInput
    none?: RuleWhereInput
  }

  export type ModelListRelationFilter = {
    every?: ModelWhereInput
    some?: ModelWhereInput
    none?: ModelWhereInput
  }

  export type RuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    keyword?: SortOrder
    rulesIDs?: SortOrder
    modelsIDs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    keyword?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    keyword?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEnumPermissionWithAggregatesFilter = {
    equals?: EnumPermission
    in?: Enumerable<EnumPermission>
    notIn?: Enumerable<EnumPermission>
    not?: NestedEnumEnumPermissionWithAggregatesFilter | EnumPermission
    _count?: NestedIntFilter
    _min?: NestedEnumEnumPermissionFilter
    _max?: NestedEnumEnumPermissionFilter
  }

  export type ModelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    keyword?: SortOrder
    permissionIDs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    keyword?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    keyword?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    firstAdress?: SortOrder
    secondAdress?: SortOrder
    zipCode?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    additionnalInformation?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    firstAdress?: SortOrder
    secondAdress?: SortOrder
    zipCode?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    additionnalInformation?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    firstAdress?: SortOrder
    secondAdress?: SortOrder
    zipCode?: SortOrder
    city?: SortOrder
    region?: SortOrder
    country?: SortOrder
    additionnalInformation?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletCountOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type WalletMaxOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletMinOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type BoxListRelationFilter = {
    every?: BoxWhereInput
    some?: BoxWhereInput
    none?: BoxWhereInput
  }

  export type BoxOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoxTypeCountOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoxTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoxTypeMinOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type EnumEnumBadgeBoxNullableFilter = {
    equals?: EnumBadgeBox | null
    in?: Enumerable<EnumBadgeBox> | null
    notIn?: Enumerable<EnumBadgeBox> | null
    not?: NestedEnumEnumBadgeBoxNullableFilter | EnumBadgeBox | null
    isSet?: boolean
  }

  export type BoxImageListRelationFilter = {
    every?: BoxImageWhereInput
    some?: BoxImageWhereInput
    none?: BoxImageWhereInput
  }

  export type ArticleListRelationFilter = {
    every?: ArticleWhereInput
    some?: ArticleWhereInput
    none?: ArticleWhereInput
  }

  export type BannerImageListRelationFilter = {
    every?: BannerImageWhereInput
    some?: BannerImageWhereInput
    none?: BannerImageWhereInput
  }

  export type BoxParamsRelationFilter = {
    is?: BoxParamsWhereInput | null
    isNot?: BoxParamsWhereInput | null
  }

  export type BoxTypeRelationFilter = {
    is?: BoxTypeWhereInput | null
    isNot?: BoxTypeWhereInput | null
  }

  export type BoxArticleListRelationFilter = {
    every?: BoxArticleWhereInput
    some?: BoxArticleWhereInput
    none?: BoxArticleWhereInput
  }

  export type DailyRewardListRelationFilter = {
    every?: DailyRewardWhereInput
    some?: DailyRewardWhereInput
    none?: DailyRewardWhereInput
  }

  export type BoxRewardLevelListRelationFilter = {
    every?: BoxRewardLevelWhereInput
    some?: BoxRewardLevelWhereInput
    none?: BoxRewardLevelWhereInput
  }

  export type BoxImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BannerImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoxArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyRewardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoxRewardLevelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoxCountOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    name?: SortOrder
    price?: SortOrder
    number?: SortOrder
    description?: SortOrder
    badge?: SortOrder
    boxTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoxAvgOrderByAggregateInput = {
    price?: SortOrder
    number?: SortOrder
  }

  export type BoxMaxOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    name?: SortOrder
    price?: SortOrder
    number?: SortOrder
    description?: SortOrder
    badge?: SortOrder
    boxTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoxMinOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    name?: SortOrder
    price?: SortOrder
    number?: SortOrder
    description?: SortOrder
    badge?: SortOrder
    boxTypeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoxSumOrderByAggregateInput = {
    price?: SortOrder
    number?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type EnumEnumBadgeBoxNullableWithAggregatesFilter = {
    equals?: EnumBadgeBox | null
    in?: Enumerable<EnumBadgeBox> | null
    notIn?: Enumerable<EnumBadgeBox> | null
    not?: NestedEnumEnumBadgeBoxNullableWithAggregatesFilter | EnumBadgeBox | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumEnumBadgeBoxNullableFilter
    _max?: NestedEnumEnumBadgeBoxNullableFilter
    isSet?: boolean
  }

  export type BoxRelationFilter = {
    is?: BoxWhereInput
    isNot?: BoxWhereInput
  }

  export type DailyRewardCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    boxId?: SortOrder
  }

  export type DailyRewardAvgOrderByAggregateInput = {
    number?: SortOrder
  }

  export type DailyRewardMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    boxId?: SortOrder
  }

  export type DailyRewardMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    boxId?: SortOrder
  }

  export type DailyRewardSumOrderByAggregateInput = {
    number?: SortOrder
  }

  export type RewardLevelRelationFilter = {
    is?: RewardLevelWhereInput
    isNot?: RewardLevelWhereInput
  }

  export type BoxRewardLevelCountOrderByAggregateInput = {
    id?: SortOrder
    boxId?: SortOrder
    rewardLevelId?: SortOrder
  }

  export type BoxRewardLevelMaxOrderByAggregateInput = {
    id?: SortOrder
    boxId?: SortOrder
    rewardLevelId?: SortOrder
  }

  export type BoxRewardLevelMinOrderByAggregateInput = {
    id?: SortOrder
    boxId?: SortOrder
    rewardLevelId?: SortOrder
  }

  export type RewardLevelCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    name?: SortOrder
    unlockThreshold?: SortOrder
    description?: SortOrder
  }

  export type RewardLevelAvgOrderByAggregateInput = {
    orderNumber?: SortOrder
    unlockThreshold?: SortOrder
  }

  export type RewardLevelMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    name?: SortOrder
    unlockThreshold?: SortOrder
    description?: SortOrder
  }

  export type RewardLevelMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    name?: SortOrder
    unlockThreshold?: SortOrder
    description?: SortOrder
  }

  export type RewardLevelSumOrderByAggregateInput = {
    orderNumber?: SortOrder
    unlockThreshold?: SortOrder
  }

  export type EnumEnumBoxImageStatusFilter = {
    equals?: EnumBoxImageStatus
    in?: Enumerable<EnumBoxImageStatus>
    notIn?: Enumerable<EnumBoxImageStatus>
    not?: NestedEnumEnumBoxImageStatusFilter | EnumBoxImageStatus
  }

  export type BoxImageCountOrderByAggregateInput = {
    id?: SortOrder
    photoUrl?: SortOrder
    status?: SortOrder
    boxId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoxImageMaxOrderByAggregateInput = {
    id?: SortOrder
    photoUrl?: SortOrder
    status?: SortOrder
    boxId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoxImageMinOrderByAggregateInput = {
    id?: SortOrder
    photoUrl?: SortOrder
    status?: SortOrder
    boxId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEnumBoxImageStatusWithAggregatesFilter = {
    equals?: EnumBoxImageStatus
    in?: Enumerable<EnumBoxImageStatus>
    notIn?: Enumerable<EnumBoxImageStatus>
    not?: NestedEnumEnumBoxImageStatusWithAggregatesFilter | EnumBoxImageStatus
    _count?: NestedIntFilter
    _min?: NestedEnumEnumBoxImageStatusFilter
    _max?: NestedEnumEnumBoxImageStatusFilter
  }

  export type ProviderCountOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    companyName?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    webSite?: SortOrder
    logo?: SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    companyName?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    webSite?: SortOrder
    logo?: SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProviderMinOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    companyName?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    webSite?: SortOrder
    logo?: SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubCategoryListRelationFilter = {
    every?: SubCategoryWhereInput
    some?: SubCategoryWhereInput
    none?: SubCategoryWhereInput
  }

  export type SubCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type SubCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitySizeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitySizeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitySizeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEnumTypeModeNullableFilter = {
    equals?: EnumTypeMode | null
    in?: Enumerable<EnumTypeMode> | null
    notIn?: Enumerable<EnumTypeMode> | null
    not?: NestedEnumEnumTypeModeNullableFilter | EnumTypeMode | null
    isSet?: boolean
  }

  export type ProviderRelationFilter = {
    is?: ProviderWhereInput | null
    isNot?: ProviderWhereInput | null
  }

  export type UnitySizeRelationFilter = {
    is?: UnitySizeWhereInput | null
    isNot?: UnitySizeWhereInput | null
  }

  export type SubCategoryRelationFilter = {
    is?: SubCategoryWhereInput | null
    isNot?: SubCategoryWhereInput | null
  }

  export type ArticlePhotoListRelationFilter = {
    every?: ArticlePhotoWhereInput
    some?: ArticlePhotoWhereInput
    none?: ArticlePhotoWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type PriceRelationFilter = {
    is?: PriceWhereInput | null
    isNot?: PriceWhereInput | null
  }

  export type ArticlePhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArticleCountOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    designation?: SortOrder
    type?: SortOrder
    size?: SortOrder
    color?: SortOrder
    productUrl?: SortOrder
    observation?: SortOrder
    winningChance?: SortOrder
    providerId?: SortOrder
    unitySizeId?: SortOrder
    subCategoryId?: SortOrder
    boxId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleAvgOrderByAggregateInput = {
    winningChance?: SortOrder
  }

  export type ArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    designation?: SortOrder
    type?: SortOrder
    size?: SortOrder
    color?: SortOrder
    productUrl?: SortOrder
    observation?: SortOrder
    winningChance?: SortOrder
    providerId?: SortOrder
    unitySizeId?: SortOrder
    subCategoryId?: SortOrder
    boxId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleMinOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    designation?: SortOrder
    type?: SortOrder
    size?: SortOrder
    color?: SortOrder
    productUrl?: SortOrder
    observation?: SortOrder
    winningChance?: SortOrder
    providerId?: SortOrder
    unitySizeId?: SortOrder
    subCategoryId?: SortOrder
    boxId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticleSumOrderByAggregateInput = {
    winningChance?: SortOrder
  }

  export type EnumEnumTypeModeNullableWithAggregatesFilter = {
    equals?: EnumTypeMode | null
    in?: Enumerable<EnumTypeMode> | null
    notIn?: Enumerable<EnumTypeMode> | null
    not?: NestedEnumEnumTypeModeNullableWithAggregatesFilter | EnumTypeMode | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumEnumTypeModeNullableFilter
    _max?: NestedEnumEnumTypeModeNullableFilter
    isSet?: boolean
  }

  export type ArticleRelationFilter = {
    is?: ArticleWhereInput
    isNot?: ArticleWhereInput
  }

  export type BoxArticleCountOrderByAggregateInput = {
    id?: SortOrder
    winningChance?: SortOrder
    boxId?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoxArticleAvgOrderByAggregateInput = {
    winningChance?: SortOrder
  }

  export type BoxArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    winningChance?: SortOrder
    boxId?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoxArticleMinOrderByAggregateInput = {
    id?: SortOrder
    winningChance?: SortOrder
    boxId?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoxArticleSumOrderByAggregateInput = {
    winningChance?: SortOrder
  }

  export type EnumArticlePhotoStatusNullableFilter = {
    equals?: ArticlePhotoStatus | null
    in?: Enumerable<ArticlePhotoStatus> | null
    notIn?: Enumerable<ArticlePhotoStatus> | null
    not?: NestedEnumArticlePhotoStatusNullableFilter | ArticlePhotoStatus | null
    isSet?: boolean
  }

  export type ArticlePhotoCountOrderByAggregateInput = {
    id?: SortOrder
    photoUrl?: SortOrder
    status?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticlePhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    photoUrl?: SortOrder
    status?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArticlePhotoMinOrderByAggregateInput = {
    id?: SortOrder
    photoUrl?: SortOrder
    status?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumArticlePhotoStatusNullableWithAggregatesFilter = {
    equals?: ArticlePhotoStatus | null
    in?: Enumerable<ArticlePhotoStatus> | null
    notIn?: Enumerable<ArticlePhotoStatus> | null
    not?: NestedEnumArticlePhotoStatusNullableWithAggregatesFilter | ArticlePhotoStatus | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumArticlePhotoStatusNullableFilter
    _max?: NestedEnumArticlePhotoStatusNullableFilter
    isSet?: boolean
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    postUrl?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    postUrl?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    postUrl?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceCountOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    currentPrice?: SortOrder
    oldPrice?: SortOrder
    rate?: SortOrder
    reduction?: SortOrder
    sellingPrice?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceAvgOrderByAggregateInput = {
    currentPrice?: SortOrder
    oldPrice?: SortOrder
    rate?: SortOrder
    reduction?: SortOrder
    sellingPrice?: SortOrder
  }

  export type PriceMaxOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    currentPrice?: SortOrder
    oldPrice?: SortOrder
    rate?: SortOrder
    reduction?: SortOrder
    sellingPrice?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceMinOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    currentPrice?: SortOrder
    oldPrice?: SortOrder
    rate?: SortOrder
    reduction?: SortOrder
    sellingPrice?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceSumOrderByAggregateInput = {
    currentPrice?: SortOrder
    oldPrice?: SortOrder
    rate?: SortOrder
    reduction?: SortOrder
    sellingPrice?: SortOrder
  }

  export type EnumEnumOrderStatusFilter = {
    equals?: EnumOrderStatus
    in?: Enumerable<EnumOrderStatus>
    notIn?: Enumerable<EnumOrderStatus>
    not?: NestedEnumEnumOrderStatusFilter | EnumOrderStatus
  }

  export type ShoppingCartRelationFilter = {
    is?: ShoppingCartWhereInput
    isNot?: ShoppingCartWhereInput
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    followedLink?: SortOrder
    orderNumber?: SortOrder
    shoppingCartId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    followedLink?: SortOrder
    orderNumber?: SortOrder
    shoppingCartId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    followedLink?: SortOrder
    orderNumber?: SortOrder
    shoppingCartId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEnumOrderStatusWithAggregatesFilter = {
    equals?: EnumOrderStatus
    in?: Enumerable<EnumOrderStatus>
    notIn?: Enumerable<EnumOrderStatus>
    not?: NestedEnumEnumOrderStatusWithAggregatesFilter | EnumOrderStatus
    _count?: NestedIntFilter
    _min?: NestedEnumEnumOrderStatusFilter
    _max?: NestedEnumEnumOrderStatusFilter
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type GameRelationFilter = {
    is?: GameWhereInput
    isNot?: GameWhereInput
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type ShoppingCartCountOrderByAggregateInput = {
    id?: SortOrder
    winningDate?: SortOrder
    isClaimed?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShoppingCartMaxOrderByAggregateInput = {
    id?: SortOrder
    winningDate?: SortOrder
    isClaimed?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShoppingCartMinOrderByAggregateInput = {
    id?: SortOrder
    winningDate?: SortOrder
    isClaimed?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type EnumEnumTypeTransactionFilter = {
    equals?: EnumTypeTransaction
    in?: Enumerable<EnumTypeTransaction>
    notIn?: Enumerable<EnumTypeTransaction>
    not?: NestedEnumEnumTypeTransactionFilter | EnumTypeTransaction
  }

  export type EnumEnumStatusTransactionFilter = {
    equals?: EnumStatusTransaction
    in?: Enumerable<EnumStatusTransaction>
    notIn?: Enumerable<EnumStatusTransaction>
    not?: NestedEnumEnumStatusTransactionFilter | EnumStatusTransaction
  }

  export type OfferRelationFilter = {
    is?: OfferWhereInput
    isNot?: OfferWhereInput
  }

  export type BankRelationFilter = {
    is?: BankWhereInput | null
    isNot?: BankWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    boxId?: SortOrder
    walletId?: SortOrder
    offerId?: SortOrder
    shoppingCartId?: SortOrder
    bankId?: SortOrder
    gameId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    boxId?: SortOrder
    walletId?: SortOrder
    offerId?: SortOrder
    shoppingCartId?: SortOrder
    bankId?: SortOrder
    gameId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    date?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    boxId?: SortOrder
    walletId?: SortOrder
    offerId?: SortOrder
    shoppingCartId?: SortOrder
    bankId?: SortOrder
    gameId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumEnumTypeTransactionWithAggregatesFilter = {
    equals?: EnumTypeTransaction
    in?: Enumerable<EnumTypeTransaction>
    notIn?: Enumerable<EnumTypeTransaction>
    not?: NestedEnumEnumTypeTransactionWithAggregatesFilter | EnumTypeTransaction
    _count?: NestedIntFilter
    _min?: NestedEnumEnumTypeTransactionFilter
    _max?: NestedEnumEnumTypeTransactionFilter
  }

  export type EnumEnumStatusTransactionWithAggregatesFilter = {
    equals?: EnumStatusTransaction
    in?: Enumerable<EnumStatusTransaction>
    notIn?: Enumerable<EnumStatusTransaction>
    not?: NestedEnumEnumStatusTransactionWithAggregatesFilter | EnumStatusTransaction
    _count?: NestedIntFilter
    _min?: NestedEnumEnumStatusTransactionFilter
    _max?: NestedEnumEnumStatusTransactionFilter
  }

  export type BankCountOrderByAggregateInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankMaxOrderByAggregateInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankMinOrderByAggregateInput = {
    id?: SortOrder
    accountNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEnumUserBoxTypeFilter = {
    equals?: EnumUserBoxType
    in?: Enumerable<EnumUserBoxType>
    notIn?: Enumerable<EnumUserBoxType>
    not?: NestedEnumEnumUserBoxTypeFilter | EnumUserBoxType
  }

  export type UserBoxCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    duration?: SortOrder
    dayNumber?: SortOrder
    isPlayed?: SortOrder
    isLocked?: SortOrder
    playedDate?: SortOrder
    activationDate?: SortOrder
    deactivationDate?: SortOrder
    orderNumber?: SortOrder
    name?: SortOrder
    unlockThreshold?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    boxId?: SortOrder
    lot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBoxAvgOrderByAggregateInput = {
    dayNumber?: SortOrder
    orderNumber?: SortOrder
    unlockThreshold?: SortOrder
    lot?: SortOrder
  }

  export type UserBoxMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    duration?: SortOrder
    dayNumber?: SortOrder
    isPlayed?: SortOrder
    isLocked?: SortOrder
    playedDate?: SortOrder
    activationDate?: SortOrder
    deactivationDate?: SortOrder
    orderNumber?: SortOrder
    name?: SortOrder
    unlockThreshold?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    boxId?: SortOrder
    lot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBoxMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    duration?: SortOrder
    dayNumber?: SortOrder
    isPlayed?: SortOrder
    isLocked?: SortOrder
    playedDate?: SortOrder
    activationDate?: SortOrder
    deactivationDate?: SortOrder
    orderNumber?: SortOrder
    name?: SortOrder
    unlockThreshold?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    boxId?: SortOrder
    lot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserBoxSumOrderByAggregateInput = {
    dayNumber?: SortOrder
    orderNumber?: SortOrder
    unlockThreshold?: SortOrder
    lot?: SortOrder
  }

  export type EnumEnumUserBoxTypeWithAggregatesFilter = {
    equals?: EnumUserBoxType
    in?: Enumerable<EnumUserBoxType>
    notIn?: Enumerable<EnumUserBoxType>
    not?: NestedEnumEnumUserBoxTypeWithAggregatesFilter | EnumUserBoxType
    _count?: NestedIntFilter
    _min?: NestedEnumEnumUserBoxTypeFilter
    _max?: NestedEnumEnumUserBoxTypeFilter
  }

  export type EnumBannerImageTypeNullableFilter = {
    equals?: BannerImageType | null
    in?: Enumerable<BannerImageType> | null
    notIn?: Enumerable<BannerImageType> | null
    not?: NestedEnumBannerImageTypeNullableFilter | BannerImageType | null
    isSet?: boolean
  }

  export type BannerImageCountOrderByAggregateInput = {
    id?: SortOrder
    bannerImgUrl?: SortOrder
    bannerLink?: SortOrder
    type?: SortOrder
    boxId?: SortOrder
    offerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerImageMaxOrderByAggregateInput = {
    id?: SortOrder
    bannerImgUrl?: SortOrder
    bannerLink?: SortOrder
    type?: SortOrder
    boxId?: SortOrder
    offerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BannerImageMinOrderByAggregateInput = {
    id?: SortOrder
    bannerImgUrl?: SortOrder
    bannerLink?: SortOrder
    type?: SortOrder
    boxId?: SortOrder
    offerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBannerImageTypeNullableWithAggregatesFilter = {
    equals?: BannerImageType | null
    in?: Enumerable<BannerImageType> | null
    notIn?: Enumerable<BannerImageType> | null
    not?: NestedEnumBannerImageTypeNullableWithAggregatesFilter | BannerImageType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumBannerImageTypeNullableFilter
    _max?: NestedEnumBannerImageTypeNullableFilter
    isSet?: boolean
  }

  export type BoxParamsCountOrderByAggregateInput = {
    id?: SortOrder
    isBestSelling?: SortOrder
    isRecommended?: SortOrder
    isNew?: SortOrder
    isBigPrice?: SortOrder
    isSubsciptionBonus?: SortOrder
    boxId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoxParamsMaxOrderByAggregateInput = {
    id?: SortOrder
    isBestSelling?: SortOrder
    isRecommended?: SortOrder
    isNew?: SortOrder
    isBigPrice?: SortOrder
    isSubsciptionBonus?: SortOrder
    boxId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoxParamsMinOrderByAggregateInput = {
    id?: SortOrder
    isBestSelling?: SortOrder
    isRecommended?: SortOrder
    isNew?: SortOrder
    isBigPrice?: SortOrder
    isSubsciptionBonus?: SortOrder
    boxId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEnumHistoricalActionFilter = {
    equals?: EnumHistoricalAction
    in?: Enumerable<EnumHistoricalAction>
    notIn?: Enumerable<EnumHistoricalAction>
    not?: NestedEnumEnumHistoricalActionFilter | EnumHistoricalAction
  }

  export type HistoricalCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HistoricalMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HistoricalMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEnumHistoricalActionWithAggregatesFilter = {
    equals?: EnumHistoricalAction
    in?: Enumerable<EnumHistoricalAction>
    notIn?: Enumerable<EnumHistoricalAction>
    not?: NestedEnumEnumHistoricalActionWithAggregatesFilter | EnumHistoricalAction
    _count?: NestedIntFilter
    _min?: NestedEnumEnumHistoricalActionFilter
    _max?: NestedEnumEnumHistoricalActionFilter
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    sendingDate?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    sendingDate?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    sendingDate?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type ReceiverCountOrderByAggregateInput = {
    id?: SortOrder
    readingDate?: SortOrder
    receiverId?: SortOrder
    messageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceiverMaxOrderByAggregateInput = {
    id?: SortOrder
    readingDate?: SortOrder
    receiverId?: SortOrder
    messageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceiverMinOrderByAggregateInput = {
    id?: SortOrder
    readingDate?: SortOrder
    receiverId?: SortOrder
    messageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsLetterCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsLetterMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NewsLetterMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemoignageCountOrderByAggregateInput = {
    id?: SortOrder
    comment?: SortOrder
    rating?: SortOrder
    commentDate?: SortOrder
    isToShow?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemoignageAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type TemoignageMaxOrderByAggregateInput = {
    id?: SortOrder
    comment?: SortOrder
    rating?: SortOrder
    commentDate?: SortOrder
    isToShow?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemoignageMinOrderByAggregateInput = {
    id?: SortOrder
    comment?: SortOrder
    rating?: SortOrder
    commentDate?: SortOrder
    isToShow?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemoignageSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type OfferCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    priceThreeMonth?: SortOrder
    color?: SortOrder
    numberMysteryBoxBronze?: SortOrder
    numberMysteryBoxSylver?: SortOrder
    numberMysteryBoxGold?: SortOrder
    isAwardLevelActive?: SortOrder
    isWeeklyAwardActive?: SortOrder
    isStandardSupportActive?: SortOrder
    isVIPSupportActive?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferAvgOrderByAggregateInput = {
    price?: SortOrder
    priceThreeMonth?: SortOrder
    numberMysteryBoxBronze?: SortOrder
    numberMysteryBoxSylver?: SortOrder
    numberMysteryBoxGold?: SortOrder
    duration?: SortOrder
  }

  export type OfferMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    priceThreeMonth?: SortOrder
    color?: SortOrder
    numberMysteryBoxBronze?: SortOrder
    numberMysteryBoxSylver?: SortOrder
    numberMysteryBoxGold?: SortOrder
    isAwardLevelActive?: SortOrder
    isWeeklyAwardActive?: SortOrder
    isStandardSupportActive?: SortOrder
    isVIPSupportActive?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    priceThreeMonth?: SortOrder
    color?: SortOrder
    numberMysteryBoxBronze?: SortOrder
    numberMysteryBoxSylver?: SortOrder
    numberMysteryBoxGold?: SortOrder
    isAwardLevelActive?: SortOrder
    isWeeklyAwardActive?: SortOrder
    isStandardSupportActive?: SortOrder
    isVIPSupportActive?: SortOrder
    duration?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferSumOrderByAggregateInput = {
    price?: SortOrder
    priceThreeMonth?: SortOrder
    numberMysteryBoxBronze?: SortOrder
    numberMysteryBoxSylver?: SortOrder
    numberMysteryBoxGold?: SortOrder
    duration?: SortOrder
  }

  export type EnumEnumPriceSubscriptionNullableFilter = {
    equals?: EnumPriceSubscription | null
    in?: Enumerable<EnumPriceSubscription> | null
    notIn?: Enumerable<EnumPriceSubscription> | null
    not?: NestedEnumEnumPriceSubscriptionNullableFilter | EnumPriceSubscription | null
    isSet?: boolean
  }

  export type EnumEnumStatusSubscriptionNullableFilter = {
    equals?: EnumStatusSubscription | null
    in?: Enumerable<EnumStatusSubscription> | null
    notIn?: Enumerable<EnumStatusSubscription> | null
    not?: NestedEnumEnumStatusSubscriptionNullableFilter | EnumStatusSubscription | null
    isSet?: boolean
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    durationType?: SortOrder
    status?: SortOrder
    autoRenewal?: SortOrder
    userId?: SortOrder
    offerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    durationType?: SortOrder
    status?: SortOrder
    autoRenewal?: SortOrder
    userId?: SortOrder
    offerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    durationType?: SortOrder
    status?: SortOrder
    autoRenewal?: SortOrder
    userId?: SortOrder
    offerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEnumPriceSubscriptionNullableWithAggregatesFilter = {
    equals?: EnumPriceSubscription | null
    in?: Enumerable<EnumPriceSubscription> | null
    notIn?: Enumerable<EnumPriceSubscription> | null
    not?: NestedEnumEnumPriceSubscriptionNullableWithAggregatesFilter | EnumPriceSubscription | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumEnumPriceSubscriptionNullableFilter
    _max?: NestedEnumEnumPriceSubscriptionNullableFilter
    isSet?: boolean
  }

  export type EnumEnumStatusSubscriptionNullableWithAggregatesFilter = {
    equals?: EnumStatusSubscription | null
    in?: Enumerable<EnumStatusSubscription> | null
    notIn?: Enumerable<EnumStatusSubscription> | null
    not?: NestedEnumEnumStatusSubscriptionNullableWithAggregatesFilter | EnumStatusSubscription | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumEnumStatusSubscriptionNullableFilter
    _max?: NestedEnumEnumStatusSubscriptionNullableFilter
    isSet?: boolean
  }

  export type EnumEnumStatusGameFilter = {
    equals?: EnumStatusGame
    in?: Enumerable<EnumStatusGame>
    notIn?: Enumerable<EnumStatusGame>
    not?: NestedEnumEnumStatusGameFilter | EnumStatusGame
  }

  export type EnumEnumVersionGameNullableFilter = {
    equals?: EnumVersionGame | null
    in?: Enumerable<EnumVersionGame> | null
    notIn?: Enumerable<EnumVersionGame> | null
    not?: NestedEnumEnumVersionGameNullableFilter | EnumVersionGame | null
    isSet?: boolean
  }

  export type EnumEnumTypeGameNullableFilter = {
    equals?: EnumTypeGame | null
    in?: Enumerable<EnumTypeGame> | null
    notIn?: Enumerable<EnumTypeGame> | null
    not?: NestedEnumEnumTypeGameNullableFilter | EnumTypeGame | null
    isSet?: boolean
  }

  export type UserBoxRelationFilter = {
    is?: UserBoxWhereInput | null
    isNot?: UserBoxWhereInput | null
  }

  export type GameCountOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    version?: SortOrder
    type?: SortOrder
    userBoxId?: SortOrder
    patronageId?: SortOrder
    gainPercentage?: SortOrder
    gainDraw?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameAvgOrderByAggregateInput = {
    gainPercentage?: SortOrder
    gainDraw?: SortOrder
  }

  export type GameMaxOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    version?: SortOrder
    type?: SortOrder
    userBoxId?: SortOrder
    patronageId?: SortOrder
    gainPercentage?: SortOrder
    gainDraw?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameMinOrderByAggregateInput = {
    id?: SortOrder
    reference?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    version?: SortOrder
    type?: SortOrder
    userBoxId?: SortOrder
    patronageId?: SortOrder
    gainPercentage?: SortOrder
    gainDraw?: SortOrder
    articleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameSumOrderByAggregateInput = {
    gainPercentage?: SortOrder
    gainDraw?: SortOrder
  }

  export type EnumEnumStatusGameWithAggregatesFilter = {
    equals?: EnumStatusGame
    in?: Enumerable<EnumStatusGame>
    notIn?: Enumerable<EnumStatusGame>
    not?: NestedEnumEnumStatusGameWithAggregatesFilter | EnumStatusGame
    _count?: NestedIntFilter
    _min?: NestedEnumEnumStatusGameFilter
    _max?: NestedEnumEnumStatusGameFilter
  }

  export type EnumEnumVersionGameNullableWithAggregatesFilter = {
    equals?: EnumVersionGame | null
    in?: Enumerable<EnumVersionGame> | null
    notIn?: Enumerable<EnumVersionGame> | null
    not?: NestedEnumEnumVersionGameNullableWithAggregatesFilter | EnumVersionGame | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumEnumVersionGameNullableFilter
    _max?: NestedEnumEnumVersionGameNullableFilter
    isSet?: boolean
  }

  export type EnumEnumTypeGameNullableWithAggregatesFilter = {
    equals?: EnumTypeGame | null
    in?: Enumerable<EnumTypeGame> | null
    notIn?: Enumerable<EnumTypeGame> | null
    not?: NestedEnumEnumTypeGameNullableWithAggregatesFilter | EnumTypeGame | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumEnumTypeGameNullableFilter
    _max?: NestedEnumEnumTypeGameNullableFilter
    isSet?: boolean
  }

  export type RuleCreateNestedOneWithoutUserInput = {
    create?: XOR<RuleCreateWithoutUserInput, RuleUncheckedCreateWithoutUserInput>
    connectOrCreate?: RuleCreateOrConnectWithoutUserInput
    connect?: RuleWhereUniqueInput
  }

  export type AddressCreateNestedOneWithoutUserInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput
    connect?: AddressWhereUniqueInput
  }

  export type CodeConfirmLoginCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CodeConfirmLoginCreateWithoutUserInput>, Enumerable<CodeConfirmLoginUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeConfirmLoginCreateOrConnectWithoutUserInput>
    createMany?: CodeConfirmLoginCreateManyUserInputEnvelope
    connect?: Enumerable<CodeConfirmLoginWhereUniqueInput>
  }

  export type CodeConfirmMailCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CodeConfirmMailCreateWithoutUserInput>, Enumerable<CodeConfirmMailUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeConfirmMailCreateOrConnectWithoutUserInput>
    createMany?: CodeConfirmMailCreateManyUserInputEnvelope
    connect?: Enumerable<CodeConfirmMailWhereUniqueInput>
  }

  export type WalletCreateNestedOneWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    connect?: WalletWhereUniqueInput
  }

  export type ShoppingCartCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ShoppingCartCreateWithoutUserInput>, Enumerable<ShoppingCartUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ShoppingCartCreateOrConnectWithoutUserInput>
    createMany?: ShoppingCartCreateManyUserInputEnvelope
    connect?: Enumerable<ShoppingCartWhereUniqueInput>
  }

  export type UserBoxCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserBoxCreateWithoutUserInput>, Enumerable<UserBoxUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserBoxCreateOrConnectWithoutUserInput>
    createMany?: UserBoxCreateManyUserInputEnvelope
    connect?: Enumerable<UserBoxWhereUniqueInput>
  }

  export type HistoricalCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<HistoricalCreateWithoutUserInput>, Enumerable<HistoricalUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HistoricalCreateOrConnectWithoutUserInput>
    createMany?: HistoricalCreateManyUserInputEnvelope
    connect?: Enumerable<HistoricalWhereUniqueInput>
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<Enumerable<MessageCreateWithoutSenderInput>, Enumerable<MessageUncheckedCreateWithoutSenderInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutSenderInput>
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type ReceiverCreateNestedManyWithoutReceiverInput = {
    create?: XOR<Enumerable<ReceiverCreateWithoutReceiverInput>, Enumerable<ReceiverUncheckedCreateWithoutReceiverInput>>
    connectOrCreate?: Enumerable<ReceiverCreateOrConnectWithoutReceiverInput>
    createMany?: ReceiverCreateManyReceiverInputEnvelope
    connect?: Enumerable<ReceiverWhereUniqueInput>
  }

  export type TemoignageCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TemoignageCreateWithoutUserInput>, Enumerable<TemoignageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TemoignageCreateOrConnectWithoutUserInput>
    createMany?: TemoignageCreateManyUserInputEnvelope
    connect?: Enumerable<TemoignageWhereUniqueInput>
  }

  export type SubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutUserInput>, Enumerable<SubscriptionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutUserInput>
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: Enumerable<SubscriptionWhereUniqueInput>
  }

  export type PatronageCreateNestedManyWithoutUserParentInput = {
    create?: XOR<Enumerable<PatronageCreateWithoutUserParentInput>, Enumerable<PatronageUncheckedCreateWithoutUserParentInput>>
    connectOrCreate?: Enumerable<PatronageCreateOrConnectWithoutUserParentInput>
    createMany?: PatronageCreateManyUserParentInputEnvelope
    connect?: Enumerable<PatronageWhereUniqueInput>
  }

  export type PatronageCreateNestedOneWithoutUserChildInput = {
    create?: XOR<PatronageCreateWithoutUserChildInput, PatronageUncheckedCreateWithoutUserChildInput>
    connectOrCreate?: PatronageCreateOrConnectWithoutUserChildInput
    connect?: PatronageWhereUniqueInput
  }

  export type AddressUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput
    connect?: AddressWhereUniqueInput
  }

  export type CodeConfirmLoginUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CodeConfirmLoginCreateWithoutUserInput>, Enumerable<CodeConfirmLoginUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeConfirmLoginCreateOrConnectWithoutUserInput>
    createMany?: CodeConfirmLoginCreateManyUserInputEnvelope
    connect?: Enumerable<CodeConfirmLoginWhereUniqueInput>
  }

  export type CodeConfirmMailUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CodeConfirmMailCreateWithoutUserInput>, Enumerable<CodeConfirmMailUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeConfirmMailCreateOrConnectWithoutUserInput>
    createMany?: CodeConfirmMailCreateManyUserInputEnvelope
    connect?: Enumerable<CodeConfirmMailWhereUniqueInput>
  }

  export type WalletUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    connect?: WalletWhereUniqueInput
  }

  export type ShoppingCartUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ShoppingCartCreateWithoutUserInput>, Enumerable<ShoppingCartUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ShoppingCartCreateOrConnectWithoutUserInput>
    createMany?: ShoppingCartCreateManyUserInputEnvelope
    connect?: Enumerable<ShoppingCartWhereUniqueInput>
  }

  export type UserBoxUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserBoxCreateWithoutUserInput>, Enumerable<UserBoxUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserBoxCreateOrConnectWithoutUserInput>
    createMany?: UserBoxCreateManyUserInputEnvelope
    connect?: Enumerable<UserBoxWhereUniqueInput>
  }

  export type HistoricalUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<HistoricalCreateWithoutUserInput>, Enumerable<HistoricalUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HistoricalCreateOrConnectWithoutUserInput>
    createMany?: HistoricalCreateManyUserInputEnvelope
    connect?: Enumerable<HistoricalWhereUniqueInput>
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<Enumerable<MessageCreateWithoutSenderInput>, Enumerable<MessageUncheckedCreateWithoutSenderInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutSenderInput>
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: Enumerable<MessageWhereUniqueInput>
  }

  export type ReceiverUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<Enumerable<ReceiverCreateWithoutReceiverInput>, Enumerable<ReceiverUncheckedCreateWithoutReceiverInput>>
    connectOrCreate?: Enumerable<ReceiverCreateOrConnectWithoutReceiverInput>
    createMany?: ReceiverCreateManyReceiverInputEnvelope
    connect?: Enumerable<ReceiverWhereUniqueInput>
  }

  export type TemoignageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TemoignageCreateWithoutUserInput>, Enumerable<TemoignageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TemoignageCreateOrConnectWithoutUserInput>
    createMany?: TemoignageCreateManyUserInputEnvelope
    connect?: Enumerable<TemoignageWhereUniqueInput>
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutUserInput>, Enumerable<SubscriptionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutUserInput>
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: Enumerable<SubscriptionWhereUniqueInput>
  }

  export type PatronageUncheckedCreateNestedManyWithoutUserParentInput = {
    create?: XOR<Enumerable<PatronageCreateWithoutUserParentInput>, Enumerable<PatronageUncheckedCreateWithoutUserParentInput>>
    connectOrCreate?: Enumerable<PatronageCreateOrConnectWithoutUserParentInput>
    createMany?: PatronageCreateManyUserParentInputEnvelope
    connect?: Enumerable<PatronageWhereUniqueInput>
  }

  export type PatronageUncheckedCreateNestedOneWithoutUserChildInput = {
    create?: XOR<PatronageCreateWithoutUserChildInput, PatronageUncheckedCreateWithoutUserChildInput>
    connectOrCreate?: PatronageCreateOrConnectWithoutUserChildInput
    connect?: PatronageWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableEnumEnumGenderFieldUpdateOperationsInput = {
    set?: EnumGender | null
    unset?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type RuleUpdateOneWithoutUserNestedInput = {
    create?: XOR<RuleCreateWithoutUserInput, RuleUncheckedCreateWithoutUserInput>
    connectOrCreate?: RuleCreateOrConnectWithoutUserInput
    upsert?: RuleUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: RuleWhereUniqueInput
    update?: XOR<RuleUpdateWithoutUserInput, RuleUncheckedUpdateWithoutUserInput>
  }

  export type AddressUpdateOneWithoutUserNestedInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput
    upsert?: AddressUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
  }

  export type CodeConfirmLoginUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CodeConfirmLoginCreateWithoutUserInput>, Enumerable<CodeConfirmLoginUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeConfirmLoginCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CodeConfirmLoginUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CodeConfirmLoginCreateManyUserInputEnvelope
    set?: Enumerable<CodeConfirmLoginWhereUniqueInput>
    disconnect?: Enumerable<CodeConfirmLoginWhereUniqueInput>
    delete?: Enumerable<CodeConfirmLoginWhereUniqueInput>
    connect?: Enumerable<CodeConfirmLoginWhereUniqueInput>
    update?: Enumerable<CodeConfirmLoginUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CodeConfirmLoginUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CodeConfirmLoginScalarWhereInput>
  }

  export type CodeConfirmMailUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CodeConfirmMailCreateWithoutUserInput>, Enumerable<CodeConfirmMailUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeConfirmMailCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CodeConfirmMailUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CodeConfirmMailCreateManyUserInputEnvelope
    set?: Enumerable<CodeConfirmMailWhereUniqueInput>
    disconnect?: Enumerable<CodeConfirmMailWhereUniqueInput>
    delete?: Enumerable<CodeConfirmMailWhereUniqueInput>
    connect?: Enumerable<CodeConfirmMailWhereUniqueInput>
    update?: Enumerable<CodeConfirmMailUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CodeConfirmMailUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CodeConfirmMailScalarWhereInput>
  }

  export type WalletUpdateOneWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    upsert?: WalletUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
  }

  export type ShoppingCartUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ShoppingCartCreateWithoutUserInput>, Enumerable<ShoppingCartUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ShoppingCartCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ShoppingCartUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ShoppingCartCreateManyUserInputEnvelope
    set?: Enumerable<ShoppingCartWhereUniqueInput>
    disconnect?: Enumerable<ShoppingCartWhereUniqueInput>
    delete?: Enumerable<ShoppingCartWhereUniqueInput>
    connect?: Enumerable<ShoppingCartWhereUniqueInput>
    update?: Enumerable<ShoppingCartUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ShoppingCartUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ShoppingCartScalarWhereInput>
  }

  export type UserBoxUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserBoxCreateWithoutUserInput>, Enumerable<UserBoxUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserBoxCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserBoxUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserBoxCreateManyUserInputEnvelope
    set?: Enumerable<UserBoxWhereUniqueInput>
    disconnect?: Enumerable<UserBoxWhereUniqueInput>
    delete?: Enumerable<UserBoxWhereUniqueInput>
    connect?: Enumerable<UserBoxWhereUniqueInput>
    update?: Enumerable<UserBoxUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserBoxUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserBoxScalarWhereInput>
  }

  export type HistoricalUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<HistoricalCreateWithoutUserInput>, Enumerable<HistoricalUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HistoricalCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<HistoricalUpsertWithWhereUniqueWithoutUserInput>
    createMany?: HistoricalCreateManyUserInputEnvelope
    set?: Enumerable<HistoricalWhereUniqueInput>
    disconnect?: Enumerable<HistoricalWhereUniqueInput>
    delete?: Enumerable<HistoricalWhereUniqueInput>
    connect?: Enumerable<HistoricalWhereUniqueInput>
    update?: Enumerable<HistoricalUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<HistoricalUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<HistoricalScalarWhereInput>
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<Enumerable<MessageCreateWithoutSenderInput>, Enumerable<MessageUncheckedCreateWithoutSenderInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutSenderInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutSenderInput>
    createMany?: MessageCreateManySenderInputEnvelope
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    connect?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutSenderInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutSenderInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type ReceiverUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<Enumerable<ReceiverCreateWithoutReceiverInput>, Enumerable<ReceiverUncheckedCreateWithoutReceiverInput>>
    connectOrCreate?: Enumerable<ReceiverCreateOrConnectWithoutReceiverInput>
    upsert?: Enumerable<ReceiverUpsertWithWhereUniqueWithoutReceiverInput>
    createMany?: ReceiverCreateManyReceiverInputEnvelope
    set?: Enumerable<ReceiverWhereUniqueInput>
    disconnect?: Enumerable<ReceiverWhereUniqueInput>
    delete?: Enumerable<ReceiverWhereUniqueInput>
    connect?: Enumerable<ReceiverWhereUniqueInput>
    update?: Enumerable<ReceiverUpdateWithWhereUniqueWithoutReceiverInput>
    updateMany?: Enumerable<ReceiverUpdateManyWithWhereWithoutReceiverInput>
    deleteMany?: Enumerable<ReceiverScalarWhereInput>
  }

  export type TemoignageUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TemoignageCreateWithoutUserInput>, Enumerable<TemoignageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TemoignageCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TemoignageUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TemoignageCreateManyUserInputEnvelope
    set?: Enumerable<TemoignageWhereUniqueInput>
    disconnect?: Enumerable<TemoignageWhereUniqueInput>
    delete?: Enumerable<TemoignageWhereUniqueInput>
    connect?: Enumerable<TemoignageWhereUniqueInput>
    update?: Enumerable<TemoignageUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TemoignageUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TemoignageScalarWhereInput>
  }

  export type SubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutUserInput>, Enumerable<SubscriptionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: Enumerable<SubscriptionWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionWhereUniqueInput>
    delete?: Enumerable<SubscriptionWhereUniqueInput>
    connect?: Enumerable<SubscriptionWhereUniqueInput>
    update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SubscriptionScalarWhereInput>
  }

  export type PatronageUpdateManyWithoutUserParentNestedInput = {
    create?: XOR<Enumerable<PatronageCreateWithoutUserParentInput>, Enumerable<PatronageUncheckedCreateWithoutUserParentInput>>
    connectOrCreate?: Enumerable<PatronageCreateOrConnectWithoutUserParentInput>
    upsert?: Enumerable<PatronageUpsertWithWhereUniqueWithoutUserParentInput>
    createMany?: PatronageCreateManyUserParentInputEnvelope
    set?: Enumerable<PatronageWhereUniqueInput>
    disconnect?: Enumerable<PatronageWhereUniqueInput>
    delete?: Enumerable<PatronageWhereUniqueInput>
    connect?: Enumerable<PatronageWhereUniqueInput>
    update?: Enumerable<PatronageUpdateWithWhereUniqueWithoutUserParentInput>
    updateMany?: Enumerable<PatronageUpdateManyWithWhereWithoutUserParentInput>
    deleteMany?: Enumerable<PatronageScalarWhereInput>
  }

  export type PatronageUpdateOneWithoutUserChildNestedInput = {
    create?: XOR<PatronageCreateWithoutUserChildInput, PatronageUncheckedCreateWithoutUserChildInput>
    connectOrCreate?: PatronageCreateOrConnectWithoutUserChildInput
    upsert?: PatronageUpsertWithoutUserChildInput
    disconnect?: boolean
    delete?: boolean
    connect?: PatronageWhereUniqueInput
    update?: XOR<PatronageUpdateWithoutUserChildInput, PatronageUncheckedUpdateWithoutUserChildInput>
  }

  export type AddressUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput
    upsert?: AddressUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
  }

  export type CodeConfirmLoginUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CodeConfirmLoginCreateWithoutUserInput>, Enumerable<CodeConfirmLoginUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeConfirmLoginCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CodeConfirmLoginUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CodeConfirmLoginCreateManyUserInputEnvelope
    set?: Enumerable<CodeConfirmLoginWhereUniqueInput>
    disconnect?: Enumerable<CodeConfirmLoginWhereUniqueInput>
    delete?: Enumerable<CodeConfirmLoginWhereUniqueInput>
    connect?: Enumerable<CodeConfirmLoginWhereUniqueInput>
    update?: Enumerable<CodeConfirmLoginUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CodeConfirmLoginUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CodeConfirmLoginScalarWhereInput>
  }

  export type CodeConfirmMailUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CodeConfirmMailCreateWithoutUserInput>, Enumerable<CodeConfirmMailUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CodeConfirmMailCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CodeConfirmMailUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CodeConfirmMailCreateManyUserInputEnvelope
    set?: Enumerable<CodeConfirmMailWhereUniqueInput>
    disconnect?: Enumerable<CodeConfirmMailWhereUniqueInput>
    delete?: Enumerable<CodeConfirmMailWhereUniqueInput>
    connect?: Enumerable<CodeConfirmMailWhereUniqueInput>
    update?: Enumerable<CodeConfirmMailUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CodeConfirmMailUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CodeConfirmMailScalarWhereInput>
  }

  export type WalletUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    upsert?: WalletUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
  }

  export type ShoppingCartUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ShoppingCartCreateWithoutUserInput>, Enumerable<ShoppingCartUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ShoppingCartCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ShoppingCartUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ShoppingCartCreateManyUserInputEnvelope
    set?: Enumerable<ShoppingCartWhereUniqueInput>
    disconnect?: Enumerable<ShoppingCartWhereUniqueInput>
    delete?: Enumerable<ShoppingCartWhereUniqueInput>
    connect?: Enumerable<ShoppingCartWhereUniqueInput>
    update?: Enumerable<ShoppingCartUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ShoppingCartUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ShoppingCartScalarWhereInput>
  }

  export type UserBoxUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserBoxCreateWithoutUserInput>, Enumerable<UserBoxUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserBoxCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserBoxUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserBoxCreateManyUserInputEnvelope
    set?: Enumerable<UserBoxWhereUniqueInput>
    disconnect?: Enumerable<UserBoxWhereUniqueInput>
    delete?: Enumerable<UserBoxWhereUniqueInput>
    connect?: Enumerable<UserBoxWhereUniqueInput>
    update?: Enumerable<UserBoxUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserBoxUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserBoxScalarWhereInput>
  }

  export type HistoricalUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<HistoricalCreateWithoutUserInput>, Enumerable<HistoricalUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HistoricalCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<HistoricalUpsertWithWhereUniqueWithoutUserInput>
    createMany?: HistoricalCreateManyUserInputEnvelope
    set?: Enumerable<HistoricalWhereUniqueInput>
    disconnect?: Enumerable<HistoricalWhereUniqueInput>
    delete?: Enumerable<HistoricalWhereUniqueInput>
    connect?: Enumerable<HistoricalWhereUniqueInput>
    update?: Enumerable<HistoricalUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<HistoricalUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<HistoricalScalarWhereInput>
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<Enumerable<MessageCreateWithoutSenderInput>, Enumerable<MessageUncheckedCreateWithoutSenderInput>>
    connectOrCreate?: Enumerable<MessageCreateOrConnectWithoutSenderInput>
    upsert?: Enumerable<MessageUpsertWithWhereUniqueWithoutSenderInput>
    createMany?: MessageCreateManySenderInputEnvelope
    set?: Enumerable<MessageWhereUniqueInput>
    disconnect?: Enumerable<MessageWhereUniqueInput>
    delete?: Enumerable<MessageWhereUniqueInput>
    connect?: Enumerable<MessageWhereUniqueInput>
    update?: Enumerable<MessageUpdateWithWhereUniqueWithoutSenderInput>
    updateMany?: Enumerable<MessageUpdateManyWithWhereWithoutSenderInput>
    deleteMany?: Enumerable<MessageScalarWhereInput>
  }

  export type ReceiverUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<Enumerable<ReceiverCreateWithoutReceiverInput>, Enumerable<ReceiverUncheckedCreateWithoutReceiverInput>>
    connectOrCreate?: Enumerable<ReceiverCreateOrConnectWithoutReceiverInput>
    upsert?: Enumerable<ReceiverUpsertWithWhereUniqueWithoutReceiverInput>
    createMany?: ReceiverCreateManyReceiverInputEnvelope
    set?: Enumerable<ReceiverWhereUniqueInput>
    disconnect?: Enumerable<ReceiverWhereUniqueInput>
    delete?: Enumerable<ReceiverWhereUniqueInput>
    connect?: Enumerable<ReceiverWhereUniqueInput>
    update?: Enumerable<ReceiverUpdateWithWhereUniqueWithoutReceiverInput>
    updateMany?: Enumerable<ReceiverUpdateManyWithWhereWithoutReceiverInput>
    deleteMany?: Enumerable<ReceiverScalarWhereInput>
  }

  export type TemoignageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<TemoignageCreateWithoutUserInput>, Enumerable<TemoignageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TemoignageCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TemoignageUpsertWithWhereUniqueWithoutUserInput>
    createMany?: TemoignageCreateManyUserInputEnvelope
    set?: Enumerable<TemoignageWhereUniqueInput>
    disconnect?: Enumerable<TemoignageWhereUniqueInput>
    delete?: Enumerable<TemoignageWhereUniqueInput>
    connect?: Enumerable<TemoignageWhereUniqueInput>
    update?: Enumerable<TemoignageUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TemoignageUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TemoignageScalarWhereInput>
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutUserInput>, Enumerable<SubscriptionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: Enumerable<SubscriptionWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionWhereUniqueInput>
    delete?: Enumerable<SubscriptionWhereUniqueInput>
    connect?: Enumerable<SubscriptionWhereUniqueInput>
    update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<SubscriptionScalarWhereInput>
  }

  export type PatronageUncheckedUpdateManyWithoutUserParentNestedInput = {
    create?: XOR<Enumerable<PatronageCreateWithoutUserParentInput>, Enumerable<PatronageUncheckedCreateWithoutUserParentInput>>
    connectOrCreate?: Enumerable<PatronageCreateOrConnectWithoutUserParentInput>
    upsert?: Enumerable<PatronageUpsertWithWhereUniqueWithoutUserParentInput>
    createMany?: PatronageCreateManyUserParentInputEnvelope
    set?: Enumerable<PatronageWhereUniqueInput>
    disconnect?: Enumerable<PatronageWhereUniqueInput>
    delete?: Enumerable<PatronageWhereUniqueInput>
    connect?: Enumerable<PatronageWhereUniqueInput>
    update?: Enumerable<PatronageUpdateWithWhereUniqueWithoutUserParentInput>
    updateMany?: Enumerable<PatronageUpdateManyWithWhereWithoutUserParentInput>
    deleteMany?: Enumerable<PatronageScalarWhereInput>
  }

  export type PatronageUncheckedUpdateOneWithoutUserChildNestedInput = {
    create?: XOR<PatronageCreateWithoutUserChildInput, PatronageUncheckedCreateWithoutUserChildInput>
    connectOrCreate?: PatronageCreateOrConnectWithoutUserChildInput
    upsert?: PatronageUpsertWithoutUserChildInput
    disconnect?: boolean
    delete?: boolean
    connect?: PatronageWhereUniqueInput
    update?: XOR<PatronageUpdateWithoutUserChildInput, PatronageUncheckedUpdateWithoutUserChildInput>
  }

  export type UserCreateNestedOneWithoutPatronageInput = {
    create?: XOR<UserCreateWithoutPatronageInput, UserUncheckedCreateWithoutPatronageInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatronageInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserChildInput = {
    create?: XOR<UserCreateWithoutUserChildInput, UserUncheckedCreateWithoutUserChildInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserChildInput
    connect?: UserWhereUniqueInput
  }

  export type GameCreateNestedManyWithoutPatronageInput = {
    create?: XOR<Enumerable<GameCreateWithoutPatronageInput>, Enumerable<GameUncheckedCreateWithoutPatronageInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutPatronageInput>
    createMany?: GameCreateManyPatronageInputEnvelope
    connect?: Enumerable<GameWhereUniqueInput>
  }

  export type GameUncheckedCreateNestedManyWithoutPatronageInput = {
    create?: XOR<Enumerable<GameCreateWithoutPatronageInput>, Enumerable<GameUncheckedCreateWithoutPatronageInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutPatronageInput>
    createMany?: GameCreateManyPatronageInputEnvelope
    connect?: Enumerable<GameWhereUniqueInput>
  }

  export type NullableEnumEnumStatusPatronageFieldUpdateOperationsInput = {
    set?: EnumStatusPatronage | null
    unset?: boolean
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
    unset?: boolean
  }

  export type UserUpdateOneRequiredWithoutPatronageNestedInput = {
    create?: XOR<UserCreateWithoutPatronageInput, UserUncheckedCreateWithoutPatronageInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatronageInput
    upsert?: UserUpsertWithoutPatronageInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPatronageInput, UserUncheckedUpdateWithoutPatronageInput>
  }

  export type UserUpdateOneRequiredWithoutUserChildNestedInput = {
    create?: XOR<UserCreateWithoutUserChildInput, UserUncheckedCreateWithoutUserChildInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserChildInput
    upsert?: UserUpsertWithoutUserChildInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserChildInput, UserUncheckedUpdateWithoutUserChildInput>
  }

  export type GameUpdateManyWithoutPatronageNestedInput = {
    create?: XOR<Enumerable<GameCreateWithoutPatronageInput>, Enumerable<GameUncheckedCreateWithoutPatronageInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutPatronageInput>
    upsert?: Enumerable<GameUpsertWithWhereUniqueWithoutPatronageInput>
    createMany?: GameCreateManyPatronageInputEnvelope
    set?: Enumerable<GameWhereUniqueInput>
    disconnect?: Enumerable<GameWhereUniqueInput>
    delete?: Enumerable<GameWhereUniqueInput>
    connect?: Enumerable<GameWhereUniqueInput>
    update?: Enumerable<GameUpdateWithWhereUniqueWithoutPatronageInput>
    updateMany?: Enumerable<GameUpdateManyWithWhereWithoutPatronageInput>
    deleteMany?: Enumerable<GameScalarWhereInput>
  }

  export type GameUncheckedUpdateManyWithoutPatronageNestedInput = {
    create?: XOR<Enumerable<GameCreateWithoutPatronageInput>, Enumerable<GameUncheckedCreateWithoutPatronageInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutPatronageInput>
    upsert?: Enumerable<GameUpsertWithWhereUniqueWithoutPatronageInput>
    createMany?: GameCreateManyPatronageInputEnvelope
    set?: Enumerable<GameWhereUniqueInput>
    disconnect?: Enumerable<GameWhereUniqueInput>
    delete?: Enumerable<GameWhereUniqueInput>
    connect?: Enumerable<GameWhereUniqueInput>
    update?: Enumerable<GameUpdateWithWhereUniqueWithoutPatronageInput>
    updateMany?: Enumerable<GameUpdateManyWithWhereWithoutPatronageInput>
    deleteMany?: Enumerable<GameScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutCodeConfirmLoginInput = {
    create?: XOR<UserCreateWithoutCodeConfirmLoginInput, UserUncheckedCreateWithoutCodeConfirmLoginInput>
    connectOrCreate?: UserCreateOrConnectWithoutCodeConfirmLoginInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCodeConfirmLoginNestedInput = {
    create?: XOR<UserCreateWithoutCodeConfirmLoginInput, UserUncheckedCreateWithoutCodeConfirmLoginInput>
    connectOrCreate?: UserCreateOrConnectWithoutCodeConfirmLoginInput
    upsert?: UserUpsertWithoutCodeConfirmLoginInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCodeConfirmLoginInput, UserUncheckedUpdateWithoutCodeConfirmLoginInput>
  }

  export type UserCreateNestedOneWithoutCodeConfirmMailInput = {
    create?: XOR<UserCreateWithoutCodeConfirmMailInput, UserUncheckedCreateWithoutCodeConfirmMailInput>
    connectOrCreate?: UserCreateOrConnectWithoutCodeConfirmMailInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCodeConfirmMailNestedInput = {
    create?: XOR<UserCreateWithoutCodeConfirmMailInput, UserUncheckedCreateWithoutCodeConfirmMailInput>
    connectOrCreate?: UserCreateOrConnectWithoutCodeConfirmMailInput
    upsert?: UserUpsertWithoutCodeConfirmMailInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCodeConfirmMailInput, UserUncheckedUpdateWithoutCodeConfirmMailInput>
  }

  export type UserCreateNestedManyWithoutRuleInput = {
    create?: XOR<Enumerable<UserCreateWithoutRuleInput>, Enumerable<UserUncheckedCreateWithoutRuleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRuleInput>
    createMany?: UserCreateManyRuleInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type PermissionCreateNestedManyWithoutRulesInput = {
    create?: XOR<Enumerable<PermissionCreateWithoutRulesInput>, Enumerable<PermissionUncheckedCreateWithoutRulesInput>>
    connectOrCreate?: Enumerable<PermissionCreateOrConnectWithoutRulesInput>
    connect?: Enumerable<PermissionWhereUniqueInput>
  }

  export type RuleCreatepermissionIDsInput = {
    set: Enumerable<string>
  }

  export type UserUncheckedCreateNestedManyWithoutRuleInput = {
    create?: XOR<Enumerable<UserCreateWithoutRuleInput>, Enumerable<UserUncheckedCreateWithoutRuleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRuleInput>
    createMany?: UserCreateManyRuleInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type PermissionUncheckedCreateNestedManyWithoutRulesInput = {
    create?: XOR<Enumerable<PermissionCreateWithoutRulesInput>, Enumerable<PermissionUncheckedCreateWithoutRulesInput>>
    connectOrCreate?: Enumerable<PermissionCreateOrConnectWithoutRulesInput>
    connect?: Enumerable<PermissionWhereUniqueInput>
  }

  export type UserUpdateManyWithoutRuleNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutRuleInput>, Enumerable<UserUncheckedCreateWithoutRuleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRuleInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRuleInput>
    createMany?: UserCreateManyRuleInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRuleInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutRuleInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type PermissionUpdateManyWithoutRulesNestedInput = {
    create?: XOR<Enumerable<PermissionCreateWithoutRulesInput>, Enumerable<PermissionUncheckedCreateWithoutRulesInput>>
    connectOrCreate?: Enumerable<PermissionCreateOrConnectWithoutRulesInput>
    upsert?: Enumerable<PermissionUpsertWithWhereUniqueWithoutRulesInput>
    set?: Enumerable<PermissionWhereUniqueInput>
    disconnect?: Enumerable<PermissionWhereUniqueInput>
    delete?: Enumerable<PermissionWhereUniqueInput>
    connect?: Enumerable<PermissionWhereUniqueInput>
    update?: Enumerable<PermissionUpdateWithWhereUniqueWithoutRulesInput>
    updateMany?: Enumerable<PermissionUpdateManyWithWhereWithoutRulesInput>
    deleteMany?: Enumerable<PermissionScalarWhereInput>
  }

  export type RuleUpdatepermissionIDsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type UserUncheckedUpdateManyWithoutRuleNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutRuleInput>, Enumerable<UserUncheckedCreateWithoutRuleInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRuleInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRuleInput>
    createMany?: UserCreateManyRuleInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRuleInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutRuleInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type PermissionUncheckedUpdateManyWithoutRulesNestedInput = {
    create?: XOR<Enumerable<PermissionCreateWithoutRulesInput>, Enumerable<PermissionUncheckedCreateWithoutRulesInput>>
    connectOrCreate?: Enumerable<PermissionCreateOrConnectWithoutRulesInput>
    upsert?: Enumerable<PermissionUpsertWithWhereUniqueWithoutRulesInput>
    set?: Enumerable<PermissionWhereUniqueInput>
    disconnect?: Enumerable<PermissionWhereUniqueInput>
    delete?: Enumerable<PermissionWhereUniqueInput>
    connect?: Enumerable<PermissionWhereUniqueInput>
    update?: Enumerable<PermissionUpdateWithWhereUniqueWithoutRulesInput>
    updateMany?: Enumerable<PermissionUpdateManyWithWhereWithoutRulesInput>
    deleteMany?: Enumerable<PermissionScalarWhereInput>
  }

  export type RuleCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<Enumerable<RuleCreateWithoutPermissionsInput>, Enumerable<RuleUncheckedCreateWithoutPermissionsInput>>
    connectOrCreate?: Enumerable<RuleCreateOrConnectWithoutPermissionsInput>
    connect?: Enumerable<RuleWhereUniqueInput>
  }

  export type ModelCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<Enumerable<ModelCreateWithoutPermissionsInput>, Enumerable<ModelUncheckedCreateWithoutPermissionsInput>>
    connectOrCreate?: Enumerable<ModelCreateOrConnectWithoutPermissionsInput>
    connect?: Enumerable<ModelWhereUniqueInput>
  }

  export type PermissionCreaterulesIDsInput = {
    set: Enumerable<string>
  }

  export type PermissionCreatemodelsIDsInput = {
    set: Enumerable<string>
  }

  export type RuleUncheckedCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<Enumerable<RuleCreateWithoutPermissionsInput>, Enumerable<RuleUncheckedCreateWithoutPermissionsInput>>
    connectOrCreate?: Enumerable<RuleCreateOrConnectWithoutPermissionsInput>
    connect?: Enumerable<RuleWhereUniqueInput>
  }

  export type ModelUncheckedCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<Enumerable<ModelCreateWithoutPermissionsInput>, Enumerable<ModelUncheckedCreateWithoutPermissionsInput>>
    connectOrCreate?: Enumerable<ModelCreateOrConnectWithoutPermissionsInput>
    connect?: Enumerable<ModelWhereUniqueInput>
  }

  export type EnumEnumPermissionFieldUpdateOperationsInput = {
    set?: EnumPermission
  }

  export type RuleUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<Enumerable<RuleCreateWithoutPermissionsInput>, Enumerable<RuleUncheckedCreateWithoutPermissionsInput>>
    connectOrCreate?: Enumerable<RuleCreateOrConnectWithoutPermissionsInput>
    upsert?: Enumerable<RuleUpsertWithWhereUniqueWithoutPermissionsInput>
    set?: Enumerable<RuleWhereUniqueInput>
    disconnect?: Enumerable<RuleWhereUniqueInput>
    delete?: Enumerable<RuleWhereUniqueInput>
    connect?: Enumerable<RuleWhereUniqueInput>
    update?: Enumerable<RuleUpdateWithWhereUniqueWithoutPermissionsInput>
    updateMany?: Enumerable<RuleUpdateManyWithWhereWithoutPermissionsInput>
    deleteMany?: Enumerable<RuleScalarWhereInput>
  }

  export type ModelUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<Enumerable<ModelCreateWithoutPermissionsInput>, Enumerable<ModelUncheckedCreateWithoutPermissionsInput>>
    connectOrCreate?: Enumerable<ModelCreateOrConnectWithoutPermissionsInput>
    upsert?: Enumerable<ModelUpsertWithWhereUniqueWithoutPermissionsInput>
    set?: Enumerable<ModelWhereUniqueInput>
    disconnect?: Enumerable<ModelWhereUniqueInput>
    delete?: Enumerable<ModelWhereUniqueInput>
    connect?: Enumerable<ModelWhereUniqueInput>
    update?: Enumerable<ModelUpdateWithWhereUniqueWithoutPermissionsInput>
    updateMany?: Enumerable<ModelUpdateManyWithWhereWithoutPermissionsInput>
    deleteMany?: Enumerable<ModelScalarWhereInput>
  }

  export type PermissionUpdaterulesIDsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type PermissionUpdatemodelsIDsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type RuleUncheckedUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<Enumerable<RuleCreateWithoutPermissionsInput>, Enumerable<RuleUncheckedCreateWithoutPermissionsInput>>
    connectOrCreate?: Enumerable<RuleCreateOrConnectWithoutPermissionsInput>
    upsert?: Enumerable<RuleUpsertWithWhereUniqueWithoutPermissionsInput>
    set?: Enumerable<RuleWhereUniqueInput>
    disconnect?: Enumerable<RuleWhereUniqueInput>
    delete?: Enumerable<RuleWhereUniqueInput>
    connect?: Enumerable<RuleWhereUniqueInput>
    update?: Enumerable<RuleUpdateWithWhereUniqueWithoutPermissionsInput>
    updateMany?: Enumerable<RuleUpdateManyWithWhereWithoutPermissionsInput>
    deleteMany?: Enumerable<RuleScalarWhereInput>
  }

  export type ModelUncheckedUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<Enumerable<ModelCreateWithoutPermissionsInput>, Enumerable<ModelUncheckedCreateWithoutPermissionsInput>>
    connectOrCreate?: Enumerable<ModelCreateOrConnectWithoutPermissionsInput>
    upsert?: Enumerable<ModelUpsertWithWhereUniqueWithoutPermissionsInput>
    set?: Enumerable<ModelWhereUniqueInput>
    disconnect?: Enumerable<ModelWhereUniqueInput>
    delete?: Enumerable<ModelWhereUniqueInput>
    connect?: Enumerable<ModelWhereUniqueInput>
    update?: Enumerable<ModelUpdateWithWhereUniqueWithoutPermissionsInput>
    updateMany?: Enumerable<ModelUpdateManyWithWhereWithoutPermissionsInput>
    deleteMany?: Enumerable<ModelScalarWhereInput>
  }

  export type PermissionCreateNestedManyWithoutModelsInput = {
    create?: XOR<Enumerable<PermissionCreateWithoutModelsInput>, Enumerable<PermissionUncheckedCreateWithoutModelsInput>>
    connectOrCreate?: Enumerable<PermissionCreateOrConnectWithoutModelsInput>
    connect?: Enumerable<PermissionWhereUniqueInput>
  }

  export type ModelCreatepermissionIDsInput = {
    set: Enumerable<string>
  }

  export type PermissionUncheckedCreateNestedManyWithoutModelsInput = {
    create?: XOR<Enumerable<PermissionCreateWithoutModelsInput>, Enumerable<PermissionUncheckedCreateWithoutModelsInput>>
    connectOrCreate?: Enumerable<PermissionCreateOrConnectWithoutModelsInput>
    connect?: Enumerable<PermissionWhereUniqueInput>
  }

  export type PermissionUpdateManyWithoutModelsNestedInput = {
    create?: XOR<Enumerable<PermissionCreateWithoutModelsInput>, Enumerable<PermissionUncheckedCreateWithoutModelsInput>>
    connectOrCreate?: Enumerable<PermissionCreateOrConnectWithoutModelsInput>
    upsert?: Enumerable<PermissionUpsertWithWhereUniqueWithoutModelsInput>
    set?: Enumerable<PermissionWhereUniqueInput>
    disconnect?: Enumerable<PermissionWhereUniqueInput>
    delete?: Enumerable<PermissionWhereUniqueInput>
    connect?: Enumerable<PermissionWhereUniqueInput>
    update?: Enumerable<PermissionUpdateWithWhereUniqueWithoutModelsInput>
    updateMany?: Enumerable<PermissionUpdateManyWithWhereWithoutModelsInput>
    deleteMany?: Enumerable<PermissionScalarWhereInput>
  }

  export type ModelUpdatepermissionIDsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type PermissionUncheckedUpdateManyWithoutModelsNestedInput = {
    create?: XOR<Enumerable<PermissionCreateWithoutModelsInput>, Enumerable<PermissionUncheckedCreateWithoutModelsInput>>
    connectOrCreate?: Enumerable<PermissionCreateOrConnectWithoutModelsInput>
    upsert?: Enumerable<PermissionUpsertWithWhereUniqueWithoutModelsInput>
    set?: Enumerable<PermissionWhereUniqueInput>
    disconnect?: Enumerable<PermissionWhereUniqueInput>
    delete?: Enumerable<PermissionWhereUniqueInput>
    connect?: Enumerable<PermissionWhereUniqueInput>
    update?: Enumerable<PermissionUpdateWithWhereUniqueWithoutModelsInput>
    updateMany?: Enumerable<PermissionUpdateManyWithWhereWithoutModelsInput>
    deleteMany?: Enumerable<PermissionScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutAddressInput = {
    create?: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAddressNestedInput = {
    create?: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressInput
    upsert?: UserUpsertWithoutAddressInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAddressInput, UserUncheckedUpdateWithoutAddressInput>
  }

  export type UserCreateNestedOneWithoutWalletInput = {
    create?: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutWalletInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutWalletInput>, Enumerable<TransactionUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutWalletInput>
    createMany?: TransactionCreateManyWalletInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type TransactionUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutWalletInput>, Enumerable<TransactionUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutWalletInput>
    createMany?: TransactionCreateManyWalletInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutWalletNestedInput = {
    create?: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletInput
    upsert?: UserUpsertWithoutWalletInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutWalletInput, UserUncheckedUpdateWithoutWalletInput>
  }

  export type TransactionUpdateManyWithoutWalletNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutWalletInput>, Enumerable<TransactionUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutWalletInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutWalletInput>
    createMany?: TransactionCreateManyWalletInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutWalletInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutWalletInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type TransactionUncheckedUpdateManyWithoutWalletNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutWalletInput>, Enumerable<TransactionUncheckedCreateWithoutWalletInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutWalletInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutWalletInput>
    createMany?: TransactionCreateManyWalletInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutWalletInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutWalletInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type BoxCreateNestedManyWithoutBoxTypeInput = {
    create?: XOR<Enumerable<BoxCreateWithoutBoxTypeInput>, Enumerable<BoxUncheckedCreateWithoutBoxTypeInput>>
    connectOrCreate?: Enumerable<BoxCreateOrConnectWithoutBoxTypeInput>
    createMany?: BoxCreateManyBoxTypeInputEnvelope
    connect?: Enumerable<BoxWhereUniqueInput>
  }

  export type BoxUncheckedCreateNestedManyWithoutBoxTypeInput = {
    create?: XOR<Enumerable<BoxCreateWithoutBoxTypeInput>, Enumerable<BoxUncheckedCreateWithoutBoxTypeInput>>
    connectOrCreate?: Enumerable<BoxCreateOrConnectWithoutBoxTypeInput>
    createMany?: BoxCreateManyBoxTypeInputEnvelope
    connect?: Enumerable<BoxWhereUniqueInput>
  }

  export type BoxUpdateManyWithoutBoxTypeNestedInput = {
    create?: XOR<Enumerable<BoxCreateWithoutBoxTypeInput>, Enumerable<BoxUncheckedCreateWithoutBoxTypeInput>>
    connectOrCreate?: Enumerable<BoxCreateOrConnectWithoutBoxTypeInput>
    upsert?: Enumerable<BoxUpsertWithWhereUniqueWithoutBoxTypeInput>
    createMany?: BoxCreateManyBoxTypeInputEnvelope
    set?: Enumerable<BoxWhereUniqueInput>
    disconnect?: Enumerable<BoxWhereUniqueInput>
    delete?: Enumerable<BoxWhereUniqueInput>
    connect?: Enumerable<BoxWhereUniqueInput>
    update?: Enumerable<BoxUpdateWithWhereUniqueWithoutBoxTypeInput>
    updateMany?: Enumerable<BoxUpdateManyWithWhereWithoutBoxTypeInput>
    deleteMany?: Enumerable<BoxScalarWhereInput>
  }

  export type BoxUncheckedUpdateManyWithoutBoxTypeNestedInput = {
    create?: XOR<Enumerable<BoxCreateWithoutBoxTypeInput>, Enumerable<BoxUncheckedCreateWithoutBoxTypeInput>>
    connectOrCreate?: Enumerable<BoxCreateOrConnectWithoutBoxTypeInput>
    upsert?: Enumerable<BoxUpsertWithWhereUniqueWithoutBoxTypeInput>
    createMany?: BoxCreateManyBoxTypeInputEnvelope
    set?: Enumerable<BoxWhereUniqueInput>
    disconnect?: Enumerable<BoxWhereUniqueInput>
    delete?: Enumerable<BoxWhereUniqueInput>
    connect?: Enumerable<BoxWhereUniqueInput>
    update?: Enumerable<BoxUpdateWithWhereUniqueWithoutBoxTypeInput>
    updateMany?: Enumerable<BoxUpdateManyWithWhereWithoutBoxTypeInput>
    deleteMany?: Enumerable<BoxScalarWhereInput>
  }

  export type BoxImageCreateNestedManyWithoutBoxInput = {
    create?: XOR<Enumerable<BoxImageCreateWithoutBoxInput>, Enumerable<BoxImageUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<BoxImageCreateOrConnectWithoutBoxInput>
    createMany?: BoxImageCreateManyBoxInputEnvelope
    connect?: Enumerable<BoxImageWhereUniqueInput>
  }

  export type ArticleCreateNestedManyWithoutBoxInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutBoxInput>, Enumerable<ArticleUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutBoxInput>
    createMany?: ArticleCreateManyBoxInputEnvelope
    connect?: Enumerable<ArticleWhereUniqueInput>
  }

  export type TransactionCreateNestedManyWithoutBoxInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutBoxInput>, Enumerable<TransactionUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutBoxInput>
    createMany?: TransactionCreateManyBoxInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type UserBoxCreateNestedManyWithoutBoxInput = {
    create?: XOR<Enumerable<UserBoxCreateWithoutBoxInput>, Enumerable<UserBoxUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<UserBoxCreateOrConnectWithoutBoxInput>
    createMany?: UserBoxCreateManyBoxInputEnvelope
    connect?: Enumerable<UserBoxWhereUniqueInput>
  }

  export type BannerImageCreateNestedManyWithoutBoxInput = {
    create?: XOR<Enumerable<BannerImageCreateWithoutBoxInput>, Enumerable<BannerImageUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<BannerImageCreateOrConnectWithoutBoxInput>
    createMany?: BannerImageCreateManyBoxInputEnvelope
    connect?: Enumerable<BannerImageWhereUniqueInput>
  }

  export type BoxParamsCreateNestedOneWithoutBoxInput = {
    create?: XOR<BoxParamsCreateWithoutBoxInput, BoxParamsUncheckedCreateWithoutBoxInput>
    connectOrCreate?: BoxParamsCreateOrConnectWithoutBoxInput
    connect?: BoxParamsWhereUniqueInput
  }

  export type BoxTypeCreateNestedOneWithoutBoxInput = {
    create?: XOR<BoxTypeCreateWithoutBoxInput, BoxTypeUncheckedCreateWithoutBoxInput>
    connectOrCreate?: BoxTypeCreateOrConnectWithoutBoxInput
    connect?: BoxTypeWhereUniqueInput
  }

  export type BoxArticleCreateNestedManyWithoutBoxInput = {
    create?: XOR<Enumerable<BoxArticleCreateWithoutBoxInput>, Enumerable<BoxArticleUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<BoxArticleCreateOrConnectWithoutBoxInput>
    createMany?: BoxArticleCreateManyBoxInputEnvelope
    connect?: Enumerable<BoxArticleWhereUniqueInput>
  }

  export type DailyRewardCreateNestedManyWithoutBoxInput = {
    create?: XOR<Enumerable<DailyRewardCreateWithoutBoxInput>, Enumerable<DailyRewardUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<DailyRewardCreateOrConnectWithoutBoxInput>
    createMany?: DailyRewardCreateManyBoxInputEnvelope
    connect?: Enumerable<DailyRewardWhereUniqueInput>
  }

  export type BoxRewardLevelCreateNestedManyWithoutBoxInput = {
    create?: XOR<Enumerable<BoxRewardLevelCreateWithoutBoxInput>, Enumerable<BoxRewardLevelUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<BoxRewardLevelCreateOrConnectWithoutBoxInput>
    createMany?: BoxRewardLevelCreateManyBoxInputEnvelope
    connect?: Enumerable<BoxRewardLevelWhereUniqueInput>
  }

  export type BoxImageUncheckedCreateNestedManyWithoutBoxInput = {
    create?: XOR<Enumerable<BoxImageCreateWithoutBoxInput>, Enumerable<BoxImageUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<BoxImageCreateOrConnectWithoutBoxInput>
    createMany?: BoxImageCreateManyBoxInputEnvelope
    connect?: Enumerable<BoxImageWhereUniqueInput>
  }

  export type ArticleUncheckedCreateNestedManyWithoutBoxInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutBoxInput>, Enumerable<ArticleUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutBoxInput>
    createMany?: ArticleCreateManyBoxInputEnvelope
    connect?: Enumerable<ArticleWhereUniqueInput>
  }

  export type TransactionUncheckedCreateNestedManyWithoutBoxInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutBoxInput>, Enumerable<TransactionUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutBoxInput>
    createMany?: TransactionCreateManyBoxInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type UserBoxUncheckedCreateNestedManyWithoutBoxInput = {
    create?: XOR<Enumerable<UserBoxCreateWithoutBoxInput>, Enumerable<UserBoxUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<UserBoxCreateOrConnectWithoutBoxInput>
    createMany?: UserBoxCreateManyBoxInputEnvelope
    connect?: Enumerable<UserBoxWhereUniqueInput>
  }

  export type BannerImageUncheckedCreateNestedManyWithoutBoxInput = {
    create?: XOR<Enumerable<BannerImageCreateWithoutBoxInput>, Enumerable<BannerImageUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<BannerImageCreateOrConnectWithoutBoxInput>
    createMany?: BannerImageCreateManyBoxInputEnvelope
    connect?: Enumerable<BannerImageWhereUniqueInput>
  }

  export type BoxParamsUncheckedCreateNestedOneWithoutBoxInput = {
    create?: XOR<BoxParamsCreateWithoutBoxInput, BoxParamsUncheckedCreateWithoutBoxInput>
    connectOrCreate?: BoxParamsCreateOrConnectWithoutBoxInput
    connect?: BoxParamsWhereUniqueInput
  }

  export type BoxArticleUncheckedCreateNestedManyWithoutBoxInput = {
    create?: XOR<Enumerable<BoxArticleCreateWithoutBoxInput>, Enumerable<BoxArticleUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<BoxArticleCreateOrConnectWithoutBoxInput>
    createMany?: BoxArticleCreateManyBoxInputEnvelope
    connect?: Enumerable<BoxArticleWhereUniqueInput>
  }

  export type DailyRewardUncheckedCreateNestedManyWithoutBoxInput = {
    create?: XOR<Enumerable<DailyRewardCreateWithoutBoxInput>, Enumerable<DailyRewardUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<DailyRewardCreateOrConnectWithoutBoxInput>
    createMany?: DailyRewardCreateManyBoxInputEnvelope
    connect?: Enumerable<DailyRewardWhereUniqueInput>
  }

  export type BoxRewardLevelUncheckedCreateNestedManyWithoutBoxInput = {
    create?: XOR<Enumerable<BoxRewardLevelCreateWithoutBoxInput>, Enumerable<BoxRewardLevelUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<BoxRewardLevelCreateOrConnectWithoutBoxInput>
    createMany?: BoxRewardLevelCreateManyBoxInputEnvelope
    connect?: Enumerable<BoxRewardLevelWhereUniqueInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumEnumBadgeBoxFieldUpdateOperationsInput = {
    set?: EnumBadgeBox | null
    unset?: boolean
  }

  export type BoxImageUpdateManyWithoutBoxNestedInput = {
    create?: XOR<Enumerable<BoxImageCreateWithoutBoxInput>, Enumerable<BoxImageUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<BoxImageCreateOrConnectWithoutBoxInput>
    upsert?: Enumerable<BoxImageUpsertWithWhereUniqueWithoutBoxInput>
    createMany?: BoxImageCreateManyBoxInputEnvelope
    set?: Enumerable<BoxImageWhereUniqueInput>
    disconnect?: Enumerable<BoxImageWhereUniqueInput>
    delete?: Enumerable<BoxImageWhereUniqueInput>
    connect?: Enumerable<BoxImageWhereUniqueInput>
    update?: Enumerable<BoxImageUpdateWithWhereUniqueWithoutBoxInput>
    updateMany?: Enumerable<BoxImageUpdateManyWithWhereWithoutBoxInput>
    deleteMany?: Enumerable<BoxImageScalarWhereInput>
  }

  export type ArticleUpdateManyWithoutBoxNestedInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutBoxInput>, Enumerable<ArticleUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutBoxInput>
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutBoxInput>
    createMany?: ArticleCreateManyBoxInputEnvelope
    set?: Enumerable<ArticleWhereUniqueInput>
    disconnect?: Enumerable<ArticleWhereUniqueInput>
    delete?: Enumerable<ArticleWhereUniqueInput>
    connect?: Enumerable<ArticleWhereUniqueInput>
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutBoxInput>
    updateMany?: Enumerable<ArticleUpdateManyWithWhereWithoutBoxInput>
    deleteMany?: Enumerable<ArticleScalarWhereInput>
  }

  export type TransactionUpdateManyWithoutBoxNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutBoxInput>, Enumerable<TransactionUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutBoxInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutBoxInput>
    createMany?: TransactionCreateManyBoxInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutBoxInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutBoxInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type UserBoxUpdateManyWithoutBoxNestedInput = {
    create?: XOR<Enumerable<UserBoxCreateWithoutBoxInput>, Enumerable<UserBoxUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<UserBoxCreateOrConnectWithoutBoxInput>
    upsert?: Enumerable<UserBoxUpsertWithWhereUniqueWithoutBoxInput>
    createMany?: UserBoxCreateManyBoxInputEnvelope
    set?: Enumerable<UserBoxWhereUniqueInput>
    disconnect?: Enumerable<UserBoxWhereUniqueInput>
    delete?: Enumerable<UserBoxWhereUniqueInput>
    connect?: Enumerable<UserBoxWhereUniqueInput>
    update?: Enumerable<UserBoxUpdateWithWhereUniqueWithoutBoxInput>
    updateMany?: Enumerable<UserBoxUpdateManyWithWhereWithoutBoxInput>
    deleteMany?: Enumerable<UserBoxScalarWhereInput>
  }

  export type BannerImageUpdateManyWithoutBoxNestedInput = {
    create?: XOR<Enumerable<BannerImageCreateWithoutBoxInput>, Enumerable<BannerImageUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<BannerImageCreateOrConnectWithoutBoxInput>
    upsert?: Enumerable<BannerImageUpsertWithWhereUniqueWithoutBoxInput>
    createMany?: BannerImageCreateManyBoxInputEnvelope
    set?: Enumerable<BannerImageWhereUniqueInput>
    disconnect?: Enumerable<BannerImageWhereUniqueInput>
    delete?: Enumerable<BannerImageWhereUniqueInput>
    connect?: Enumerable<BannerImageWhereUniqueInput>
    update?: Enumerable<BannerImageUpdateWithWhereUniqueWithoutBoxInput>
    updateMany?: Enumerable<BannerImageUpdateManyWithWhereWithoutBoxInput>
    deleteMany?: Enumerable<BannerImageScalarWhereInput>
  }

  export type BoxParamsUpdateOneWithoutBoxNestedInput = {
    create?: XOR<BoxParamsCreateWithoutBoxInput, BoxParamsUncheckedCreateWithoutBoxInput>
    connectOrCreate?: BoxParamsCreateOrConnectWithoutBoxInput
    upsert?: BoxParamsUpsertWithoutBoxInput
    disconnect?: boolean
    delete?: boolean
    connect?: BoxParamsWhereUniqueInput
    update?: XOR<BoxParamsUpdateWithoutBoxInput, BoxParamsUncheckedUpdateWithoutBoxInput>
  }

  export type BoxTypeUpdateOneWithoutBoxNestedInput = {
    create?: XOR<BoxTypeCreateWithoutBoxInput, BoxTypeUncheckedCreateWithoutBoxInput>
    connectOrCreate?: BoxTypeCreateOrConnectWithoutBoxInput
    upsert?: BoxTypeUpsertWithoutBoxInput
    disconnect?: boolean
    delete?: boolean
    connect?: BoxTypeWhereUniqueInput
    update?: XOR<BoxTypeUpdateWithoutBoxInput, BoxTypeUncheckedUpdateWithoutBoxInput>
  }

  export type BoxArticleUpdateManyWithoutBoxNestedInput = {
    create?: XOR<Enumerable<BoxArticleCreateWithoutBoxInput>, Enumerable<BoxArticleUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<BoxArticleCreateOrConnectWithoutBoxInput>
    upsert?: Enumerable<BoxArticleUpsertWithWhereUniqueWithoutBoxInput>
    createMany?: BoxArticleCreateManyBoxInputEnvelope
    set?: Enumerable<BoxArticleWhereUniqueInput>
    disconnect?: Enumerable<BoxArticleWhereUniqueInput>
    delete?: Enumerable<BoxArticleWhereUniqueInput>
    connect?: Enumerable<BoxArticleWhereUniqueInput>
    update?: Enumerable<BoxArticleUpdateWithWhereUniqueWithoutBoxInput>
    updateMany?: Enumerable<BoxArticleUpdateManyWithWhereWithoutBoxInput>
    deleteMany?: Enumerable<BoxArticleScalarWhereInput>
  }

  export type DailyRewardUpdateManyWithoutBoxNestedInput = {
    create?: XOR<Enumerable<DailyRewardCreateWithoutBoxInput>, Enumerable<DailyRewardUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<DailyRewardCreateOrConnectWithoutBoxInput>
    upsert?: Enumerable<DailyRewardUpsertWithWhereUniqueWithoutBoxInput>
    createMany?: DailyRewardCreateManyBoxInputEnvelope
    set?: Enumerable<DailyRewardWhereUniqueInput>
    disconnect?: Enumerable<DailyRewardWhereUniqueInput>
    delete?: Enumerable<DailyRewardWhereUniqueInput>
    connect?: Enumerable<DailyRewardWhereUniqueInput>
    update?: Enumerable<DailyRewardUpdateWithWhereUniqueWithoutBoxInput>
    updateMany?: Enumerable<DailyRewardUpdateManyWithWhereWithoutBoxInput>
    deleteMany?: Enumerable<DailyRewardScalarWhereInput>
  }

  export type BoxRewardLevelUpdateManyWithoutBoxNestedInput = {
    create?: XOR<Enumerable<BoxRewardLevelCreateWithoutBoxInput>, Enumerable<BoxRewardLevelUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<BoxRewardLevelCreateOrConnectWithoutBoxInput>
    upsert?: Enumerable<BoxRewardLevelUpsertWithWhereUniqueWithoutBoxInput>
    createMany?: BoxRewardLevelCreateManyBoxInputEnvelope
    set?: Enumerable<BoxRewardLevelWhereUniqueInput>
    disconnect?: Enumerable<BoxRewardLevelWhereUniqueInput>
    delete?: Enumerable<BoxRewardLevelWhereUniqueInput>
    connect?: Enumerable<BoxRewardLevelWhereUniqueInput>
    update?: Enumerable<BoxRewardLevelUpdateWithWhereUniqueWithoutBoxInput>
    updateMany?: Enumerable<BoxRewardLevelUpdateManyWithWhereWithoutBoxInput>
    deleteMany?: Enumerable<BoxRewardLevelScalarWhereInput>
  }

  export type BoxImageUncheckedUpdateManyWithoutBoxNestedInput = {
    create?: XOR<Enumerable<BoxImageCreateWithoutBoxInput>, Enumerable<BoxImageUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<BoxImageCreateOrConnectWithoutBoxInput>
    upsert?: Enumerable<BoxImageUpsertWithWhereUniqueWithoutBoxInput>
    createMany?: BoxImageCreateManyBoxInputEnvelope
    set?: Enumerable<BoxImageWhereUniqueInput>
    disconnect?: Enumerable<BoxImageWhereUniqueInput>
    delete?: Enumerable<BoxImageWhereUniqueInput>
    connect?: Enumerable<BoxImageWhereUniqueInput>
    update?: Enumerable<BoxImageUpdateWithWhereUniqueWithoutBoxInput>
    updateMany?: Enumerable<BoxImageUpdateManyWithWhereWithoutBoxInput>
    deleteMany?: Enumerable<BoxImageScalarWhereInput>
  }

  export type ArticleUncheckedUpdateManyWithoutBoxNestedInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutBoxInput>, Enumerable<ArticleUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutBoxInput>
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutBoxInput>
    createMany?: ArticleCreateManyBoxInputEnvelope
    set?: Enumerable<ArticleWhereUniqueInput>
    disconnect?: Enumerable<ArticleWhereUniqueInput>
    delete?: Enumerable<ArticleWhereUniqueInput>
    connect?: Enumerable<ArticleWhereUniqueInput>
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutBoxInput>
    updateMany?: Enumerable<ArticleUpdateManyWithWhereWithoutBoxInput>
    deleteMany?: Enumerable<ArticleScalarWhereInput>
  }

  export type TransactionUncheckedUpdateManyWithoutBoxNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutBoxInput>, Enumerable<TransactionUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutBoxInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutBoxInput>
    createMany?: TransactionCreateManyBoxInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutBoxInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutBoxInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type UserBoxUncheckedUpdateManyWithoutBoxNestedInput = {
    create?: XOR<Enumerable<UserBoxCreateWithoutBoxInput>, Enumerable<UserBoxUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<UserBoxCreateOrConnectWithoutBoxInput>
    upsert?: Enumerable<UserBoxUpsertWithWhereUniqueWithoutBoxInput>
    createMany?: UserBoxCreateManyBoxInputEnvelope
    set?: Enumerable<UserBoxWhereUniqueInput>
    disconnect?: Enumerable<UserBoxWhereUniqueInput>
    delete?: Enumerable<UserBoxWhereUniqueInput>
    connect?: Enumerable<UserBoxWhereUniqueInput>
    update?: Enumerable<UserBoxUpdateWithWhereUniqueWithoutBoxInput>
    updateMany?: Enumerable<UserBoxUpdateManyWithWhereWithoutBoxInput>
    deleteMany?: Enumerable<UserBoxScalarWhereInput>
  }

  export type BannerImageUncheckedUpdateManyWithoutBoxNestedInput = {
    create?: XOR<Enumerable<BannerImageCreateWithoutBoxInput>, Enumerable<BannerImageUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<BannerImageCreateOrConnectWithoutBoxInput>
    upsert?: Enumerable<BannerImageUpsertWithWhereUniqueWithoutBoxInput>
    createMany?: BannerImageCreateManyBoxInputEnvelope
    set?: Enumerable<BannerImageWhereUniqueInput>
    disconnect?: Enumerable<BannerImageWhereUniqueInput>
    delete?: Enumerable<BannerImageWhereUniqueInput>
    connect?: Enumerable<BannerImageWhereUniqueInput>
    update?: Enumerable<BannerImageUpdateWithWhereUniqueWithoutBoxInput>
    updateMany?: Enumerable<BannerImageUpdateManyWithWhereWithoutBoxInput>
    deleteMany?: Enumerable<BannerImageScalarWhereInput>
  }

  export type BoxParamsUncheckedUpdateOneWithoutBoxNestedInput = {
    create?: XOR<BoxParamsCreateWithoutBoxInput, BoxParamsUncheckedCreateWithoutBoxInput>
    connectOrCreate?: BoxParamsCreateOrConnectWithoutBoxInput
    upsert?: BoxParamsUpsertWithoutBoxInput
    disconnect?: boolean
    delete?: boolean
    connect?: BoxParamsWhereUniqueInput
    update?: XOR<BoxParamsUpdateWithoutBoxInput, BoxParamsUncheckedUpdateWithoutBoxInput>
  }

  export type BoxArticleUncheckedUpdateManyWithoutBoxNestedInput = {
    create?: XOR<Enumerable<BoxArticleCreateWithoutBoxInput>, Enumerable<BoxArticleUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<BoxArticleCreateOrConnectWithoutBoxInput>
    upsert?: Enumerable<BoxArticleUpsertWithWhereUniqueWithoutBoxInput>
    createMany?: BoxArticleCreateManyBoxInputEnvelope
    set?: Enumerable<BoxArticleWhereUniqueInput>
    disconnect?: Enumerable<BoxArticleWhereUniqueInput>
    delete?: Enumerable<BoxArticleWhereUniqueInput>
    connect?: Enumerable<BoxArticleWhereUniqueInput>
    update?: Enumerable<BoxArticleUpdateWithWhereUniqueWithoutBoxInput>
    updateMany?: Enumerable<BoxArticleUpdateManyWithWhereWithoutBoxInput>
    deleteMany?: Enumerable<BoxArticleScalarWhereInput>
  }

  export type DailyRewardUncheckedUpdateManyWithoutBoxNestedInput = {
    create?: XOR<Enumerable<DailyRewardCreateWithoutBoxInput>, Enumerable<DailyRewardUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<DailyRewardCreateOrConnectWithoutBoxInput>
    upsert?: Enumerable<DailyRewardUpsertWithWhereUniqueWithoutBoxInput>
    createMany?: DailyRewardCreateManyBoxInputEnvelope
    set?: Enumerable<DailyRewardWhereUniqueInput>
    disconnect?: Enumerable<DailyRewardWhereUniqueInput>
    delete?: Enumerable<DailyRewardWhereUniqueInput>
    connect?: Enumerable<DailyRewardWhereUniqueInput>
    update?: Enumerable<DailyRewardUpdateWithWhereUniqueWithoutBoxInput>
    updateMany?: Enumerable<DailyRewardUpdateManyWithWhereWithoutBoxInput>
    deleteMany?: Enumerable<DailyRewardScalarWhereInput>
  }

  export type BoxRewardLevelUncheckedUpdateManyWithoutBoxNestedInput = {
    create?: XOR<Enumerable<BoxRewardLevelCreateWithoutBoxInput>, Enumerable<BoxRewardLevelUncheckedCreateWithoutBoxInput>>
    connectOrCreate?: Enumerable<BoxRewardLevelCreateOrConnectWithoutBoxInput>
    upsert?: Enumerable<BoxRewardLevelUpsertWithWhereUniqueWithoutBoxInput>
    createMany?: BoxRewardLevelCreateManyBoxInputEnvelope
    set?: Enumerable<BoxRewardLevelWhereUniqueInput>
    disconnect?: Enumerable<BoxRewardLevelWhereUniqueInput>
    delete?: Enumerable<BoxRewardLevelWhereUniqueInput>
    connect?: Enumerable<BoxRewardLevelWhereUniqueInput>
    update?: Enumerable<BoxRewardLevelUpdateWithWhereUniqueWithoutBoxInput>
    updateMany?: Enumerable<BoxRewardLevelUpdateManyWithWhereWithoutBoxInput>
    deleteMany?: Enumerable<BoxRewardLevelScalarWhereInput>
  }

  export type BoxCreateNestedOneWithoutDailyRewardInput = {
    create?: XOR<BoxCreateWithoutDailyRewardInput, BoxUncheckedCreateWithoutDailyRewardInput>
    connectOrCreate?: BoxCreateOrConnectWithoutDailyRewardInput
    connect?: BoxWhereUniqueInput
  }

  export type BoxUpdateOneRequiredWithoutDailyRewardNestedInput = {
    create?: XOR<BoxCreateWithoutDailyRewardInput, BoxUncheckedCreateWithoutDailyRewardInput>
    connectOrCreate?: BoxCreateOrConnectWithoutDailyRewardInput
    upsert?: BoxUpsertWithoutDailyRewardInput
    connect?: BoxWhereUniqueInput
    update?: XOR<BoxUpdateWithoutDailyRewardInput, BoxUncheckedUpdateWithoutDailyRewardInput>
  }

  export type BoxCreateNestedOneWithoutBoxRewardLevelInput = {
    create?: XOR<BoxCreateWithoutBoxRewardLevelInput, BoxUncheckedCreateWithoutBoxRewardLevelInput>
    connectOrCreate?: BoxCreateOrConnectWithoutBoxRewardLevelInput
    connect?: BoxWhereUniqueInput
  }

  export type RewardLevelCreateNestedOneWithoutBoxRewardLevelInput = {
    create?: XOR<RewardLevelCreateWithoutBoxRewardLevelInput, RewardLevelUncheckedCreateWithoutBoxRewardLevelInput>
    connectOrCreate?: RewardLevelCreateOrConnectWithoutBoxRewardLevelInput
    connect?: RewardLevelWhereUniqueInput
  }

  export type BoxUpdateOneRequiredWithoutBoxRewardLevelNestedInput = {
    create?: XOR<BoxCreateWithoutBoxRewardLevelInput, BoxUncheckedCreateWithoutBoxRewardLevelInput>
    connectOrCreate?: BoxCreateOrConnectWithoutBoxRewardLevelInput
    upsert?: BoxUpsertWithoutBoxRewardLevelInput
    connect?: BoxWhereUniqueInput
    update?: XOR<BoxUpdateWithoutBoxRewardLevelInput, BoxUncheckedUpdateWithoutBoxRewardLevelInput>
  }

  export type RewardLevelUpdateOneRequiredWithoutBoxRewardLevelNestedInput = {
    create?: XOR<RewardLevelCreateWithoutBoxRewardLevelInput, RewardLevelUncheckedCreateWithoutBoxRewardLevelInput>
    connectOrCreate?: RewardLevelCreateOrConnectWithoutBoxRewardLevelInput
    upsert?: RewardLevelUpsertWithoutBoxRewardLevelInput
    connect?: RewardLevelWhereUniqueInput
    update?: XOR<RewardLevelUpdateWithoutBoxRewardLevelInput, RewardLevelUncheckedUpdateWithoutBoxRewardLevelInput>
  }

  export type BoxRewardLevelCreateNestedManyWithoutRewardLevelInput = {
    create?: XOR<Enumerable<BoxRewardLevelCreateWithoutRewardLevelInput>, Enumerable<BoxRewardLevelUncheckedCreateWithoutRewardLevelInput>>
    connectOrCreate?: Enumerable<BoxRewardLevelCreateOrConnectWithoutRewardLevelInput>
    createMany?: BoxRewardLevelCreateManyRewardLevelInputEnvelope
    connect?: Enumerable<BoxRewardLevelWhereUniqueInput>
  }

  export type BoxRewardLevelUncheckedCreateNestedManyWithoutRewardLevelInput = {
    create?: XOR<Enumerable<BoxRewardLevelCreateWithoutRewardLevelInput>, Enumerable<BoxRewardLevelUncheckedCreateWithoutRewardLevelInput>>
    connectOrCreate?: Enumerable<BoxRewardLevelCreateOrConnectWithoutRewardLevelInput>
    createMany?: BoxRewardLevelCreateManyRewardLevelInputEnvelope
    connect?: Enumerable<BoxRewardLevelWhereUniqueInput>
  }

  export type BoxRewardLevelUpdateManyWithoutRewardLevelNestedInput = {
    create?: XOR<Enumerable<BoxRewardLevelCreateWithoutRewardLevelInput>, Enumerable<BoxRewardLevelUncheckedCreateWithoutRewardLevelInput>>
    connectOrCreate?: Enumerable<BoxRewardLevelCreateOrConnectWithoutRewardLevelInput>
    upsert?: Enumerable<BoxRewardLevelUpsertWithWhereUniqueWithoutRewardLevelInput>
    createMany?: BoxRewardLevelCreateManyRewardLevelInputEnvelope
    set?: Enumerable<BoxRewardLevelWhereUniqueInput>
    disconnect?: Enumerable<BoxRewardLevelWhereUniqueInput>
    delete?: Enumerable<BoxRewardLevelWhereUniqueInput>
    connect?: Enumerable<BoxRewardLevelWhereUniqueInput>
    update?: Enumerable<BoxRewardLevelUpdateWithWhereUniqueWithoutRewardLevelInput>
    updateMany?: Enumerable<BoxRewardLevelUpdateManyWithWhereWithoutRewardLevelInput>
    deleteMany?: Enumerable<BoxRewardLevelScalarWhereInput>
  }

  export type BoxRewardLevelUncheckedUpdateManyWithoutRewardLevelNestedInput = {
    create?: XOR<Enumerable<BoxRewardLevelCreateWithoutRewardLevelInput>, Enumerable<BoxRewardLevelUncheckedCreateWithoutRewardLevelInput>>
    connectOrCreate?: Enumerable<BoxRewardLevelCreateOrConnectWithoutRewardLevelInput>
    upsert?: Enumerable<BoxRewardLevelUpsertWithWhereUniqueWithoutRewardLevelInput>
    createMany?: BoxRewardLevelCreateManyRewardLevelInputEnvelope
    set?: Enumerable<BoxRewardLevelWhereUniqueInput>
    disconnect?: Enumerable<BoxRewardLevelWhereUniqueInput>
    delete?: Enumerable<BoxRewardLevelWhereUniqueInput>
    connect?: Enumerable<BoxRewardLevelWhereUniqueInput>
    update?: Enumerable<BoxRewardLevelUpdateWithWhereUniqueWithoutRewardLevelInput>
    updateMany?: Enumerable<BoxRewardLevelUpdateManyWithWhereWithoutRewardLevelInput>
    deleteMany?: Enumerable<BoxRewardLevelScalarWhereInput>
  }

  export type BoxCreateNestedOneWithoutBoxImageInput = {
    create?: XOR<BoxCreateWithoutBoxImageInput, BoxUncheckedCreateWithoutBoxImageInput>
    connectOrCreate?: BoxCreateOrConnectWithoutBoxImageInput
    connect?: BoxWhereUniqueInput
  }

  export type EnumEnumBoxImageStatusFieldUpdateOperationsInput = {
    set?: EnumBoxImageStatus
  }

  export type BoxUpdateOneRequiredWithoutBoxImageNestedInput = {
    create?: XOR<BoxCreateWithoutBoxImageInput, BoxUncheckedCreateWithoutBoxImageInput>
    connectOrCreate?: BoxCreateOrConnectWithoutBoxImageInput
    upsert?: BoxUpsertWithoutBoxImageInput
    connect?: BoxWhereUniqueInput
    update?: XOR<BoxUpdateWithoutBoxImageInput, BoxUncheckedUpdateWithoutBoxImageInput>
  }

  export type ArticleCreateNestedManyWithoutProviderInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutProviderInput>, Enumerable<ArticleUncheckedCreateWithoutProviderInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutProviderInput>
    createMany?: ArticleCreateManyProviderInputEnvelope
    connect?: Enumerable<ArticleWhereUniqueInput>
  }

  export type ArticleUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutProviderInput>, Enumerable<ArticleUncheckedCreateWithoutProviderInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutProviderInput>
    createMany?: ArticleCreateManyProviderInputEnvelope
    connect?: Enumerable<ArticleWhereUniqueInput>
  }

  export type ArticleUpdateManyWithoutProviderNestedInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutProviderInput>, Enumerable<ArticleUncheckedCreateWithoutProviderInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutProviderInput>
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutProviderInput>
    createMany?: ArticleCreateManyProviderInputEnvelope
    set?: Enumerable<ArticleWhereUniqueInput>
    disconnect?: Enumerable<ArticleWhereUniqueInput>
    delete?: Enumerable<ArticleWhereUniqueInput>
    connect?: Enumerable<ArticleWhereUniqueInput>
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutProviderInput>
    updateMany?: Enumerable<ArticleUpdateManyWithWhereWithoutProviderInput>
    deleteMany?: Enumerable<ArticleScalarWhereInput>
  }

  export type ArticleUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutProviderInput>, Enumerable<ArticleUncheckedCreateWithoutProviderInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutProviderInput>
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutProviderInput>
    createMany?: ArticleCreateManyProviderInputEnvelope
    set?: Enumerable<ArticleWhereUniqueInput>
    disconnect?: Enumerable<ArticleWhereUniqueInput>
    delete?: Enumerable<ArticleWhereUniqueInput>
    connect?: Enumerable<ArticleWhereUniqueInput>
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutProviderInput>
    updateMany?: Enumerable<ArticleUpdateManyWithWhereWithoutProviderInput>
    deleteMany?: Enumerable<ArticleScalarWhereInput>
  }

  export type SubCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<SubCategoryCreateWithoutCategoryInput>, Enumerable<SubCategoryUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<SubCategoryCreateOrConnectWithoutCategoryInput>
    createMany?: SubCategoryCreateManyCategoryInputEnvelope
    connect?: Enumerable<SubCategoryWhereUniqueInput>
  }

  export type SubCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<SubCategoryCreateWithoutCategoryInput>, Enumerable<SubCategoryUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<SubCategoryCreateOrConnectWithoutCategoryInput>
    createMany?: SubCategoryCreateManyCategoryInputEnvelope
    connect?: Enumerable<SubCategoryWhereUniqueInput>
  }

  export type SubCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<SubCategoryCreateWithoutCategoryInput>, Enumerable<SubCategoryUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<SubCategoryCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<SubCategoryUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: SubCategoryCreateManyCategoryInputEnvelope
    set?: Enumerable<SubCategoryWhereUniqueInput>
    disconnect?: Enumerable<SubCategoryWhereUniqueInput>
    delete?: Enumerable<SubCategoryWhereUniqueInput>
    connect?: Enumerable<SubCategoryWhereUniqueInput>
    update?: Enumerable<SubCategoryUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<SubCategoryUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<SubCategoryScalarWhereInput>
  }

  export type SubCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<SubCategoryCreateWithoutCategoryInput>, Enumerable<SubCategoryUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<SubCategoryCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<SubCategoryUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: SubCategoryCreateManyCategoryInputEnvelope
    set?: Enumerable<SubCategoryWhereUniqueInput>
    disconnect?: Enumerable<SubCategoryWhereUniqueInput>
    delete?: Enumerable<SubCategoryWhereUniqueInput>
    connect?: Enumerable<SubCategoryWhereUniqueInput>
    update?: Enumerable<SubCategoryUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<SubCategoryUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<SubCategoryScalarWhereInput>
  }

  export type CategoryCreateNestedOneWithoutSubCategoryInput = {
    create?: XOR<CategoryCreateWithoutSubCategoryInput, CategoryUncheckedCreateWithoutSubCategoryInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubCategoryInput
    connect?: CategoryWhereUniqueInput
  }

  export type ArticleCreateNestedManyWithoutSubCategoryInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutSubCategoryInput>, Enumerable<ArticleUncheckedCreateWithoutSubCategoryInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutSubCategoryInput>
    createMany?: ArticleCreateManySubCategoryInputEnvelope
    connect?: Enumerable<ArticleWhereUniqueInput>
  }

  export type ArticleUncheckedCreateNestedManyWithoutSubCategoryInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutSubCategoryInput>, Enumerable<ArticleUncheckedCreateWithoutSubCategoryInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutSubCategoryInput>
    createMany?: ArticleCreateManySubCategoryInputEnvelope
    connect?: Enumerable<ArticleWhereUniqueInput>
  }

  export type CategoryUpdateOneRequiredWithoutSubCategoryNestedInput = {
    create?: XOR<CategoryCreateWithoutSubCategoryInput, CategoryUncheckedCreateWithoutSubCategoryInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubCategoryInput
    upsert?: CategoryUpsertWithoutSubCategoryInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<CategoryUpdateWithoutSubCategoryInput, CategoryUncheckedUpdateWithoutSubCategoryInput>
  }

  export type ArticleUpdateManyWithoutSubCategoryNestedInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutSubCategoryInput>, Enumerable<ArticleUncheckedCreateWithoutSubCategoryInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutSubCategoryInput>
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutSubCategoryInput>
    createMany?: ArticleCreateManySubCategoryInputEnvelope
    set?: Enumerable<ArticleWhereUniqueInput>
    disconnect?: Enumerable<ArticleWhereUniqueInput>
    delete?: Enumerable<ArticleWhereUniqueInput>
    connect?: Enumerable<ArticleWhereUniqueInput>
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutSubCategoryInput>
    updateMany?: Enumerable<ArticleUpdateManyWithWhereWithoutSubCategoryInput>
    deleteMany?: Enumerable<ArticleScalarWhereInput>
  }

  export type ArticleUncheckedUpdateManyWithoutSubCategoryNestedInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutSubCategoryInput>, Enumerable<ArticleUncheckedCreateWithoutSubCategoryInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutSubCategoryInput>
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutSubCategoryInput>
    createMany?: ArticleCreateManySubCategoryInputEnvelope
    set?: Enumerable<ArticleWhereUniqueInput>
    disconnect?: Enumerable<ArticleWhereUniqueInput>
    delete?: Enumerable<ArticleWhereUniqueInput>
    connect?: Enumerable<ArticleWhereUniqueInput>
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutSubCategoryInput>
    updateMany?: Enumerable<ArticleUpdateManyWithWhereWithoutSubCategoryInput>
    deleteMany?: Enumerable<ArticleScalarWhereInput>
  }

  export type ArticleCreateNestedManyWithoutUnitySizeInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutUnitySizeInput>, Enumerable<ArticleUncheckedCreateWithoutUnitySizeInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutUnitySizeInput>
    createMany?: ArticleCreateManyUnitySizeInputEnvelope
    connect?: Enumerable<ArticleWhereUniqueInput>
  }

  export type ArticleUncheckedCreateNestedManyWithoutUnitySizeInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutUnitySizeInput>, Enumerable<ArticleUncheckedCreateWithoutUnitySizeInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutUnitySizeInput>
    createMany?: ArticleCreateManyUnitySizeInputEnvelope
    connect?: Enumerable<ArticleWhereUniqueInput>
  }

  export type ArticleUpdateManyWithoutUnitySizeNestedInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutUnitySizeInput>, Enumerable<ArticleUncheckedCreateWithoutUnitySizeInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutUnitySizeInput>
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutUnitySizeInput>
    createMany?: ArticleCreateManyUnitySizeInputEnvelope
    set?: Enumerable<ArticleWhereUniqueInput>
    disconnect?: Enumerable<ArticleWhereUniqueInput>
    delete?: Enumerable<ArticleWhereUniqueInput>
    connect?: Enumerable<ArticleWhereUniqueInput>
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutUnitySizeInput>
    updateMany?: Enumerable<ArticleUpdateManyWithWhereWithoutUnitySizeInput>
    deleteMany?: Enumerable<ArticleScalarWhereInput>
  }

  export type ArticleUncheckedUpdateManyWithoutUnitySizeNestedInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutUnitySizeInput>, Enumerable<ArticleUncheckedCreateWithoutUnitySizeInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutUnitySizeInput>
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutUnitySizeInput>
    createMany?: ArticleCreateManyUnitySizeInputEnvelope
    set?: Enumerable<ArticleWhereUniqueInput>
    disconnect?: Enumerable<ArticleWhereUniqueInput>
    delete?: Enumerable<ArticleWhereUniqueInput>
    connect?: Enumerable<ArticleWhereUniqueInput>
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutUnitySizeInput>
    updateMany?: Enumerable<ArticleUpdateManyWithWhereWithoutUnitySizeInput>
    deleteMany?: Enumerable<ArticleScalarWhereInput>
  }

  export type ProviderCreateNestedOneWithoutArticleInput = {
    create?: XOR<ProviderCreateWithoutArticleInput, ProviderUncheckedCreateWithoutArticleInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutArticleInput
    connect?: ProviderWhereUniqueInput
  }

  export type UnitySizeCreateNestedOneWithoutArticleInput = {
    create?: XOR<UnitySizeCreateWithoutArticleInput, UnitySizeUncheckedCreateWithoutArticleInput>
    connectOrCreate?: UnitySizeCreateOrConnectWithoutArticleInput
    connect?: UnitySizeWhereUniqueInput
  }

  export type SubCategoryCreateNestedOneWithoutArticleInput = {
    create?: XOR<SubCategoryCreateWithoutArticleInput, SubCategoryUncheckedCreateWithoutArticleInput>
    connectOrCreate?: SubCategoryCreateOrConnectWithoutArticleInput
    connect?: SubCategoryWhereUniqueInput
  }

  export type BoxCreateNestedOneWithoutArticleInput = {
    create?: XOR<BoxCreateWithoutArticleInput, BoxUncheckedCreateWithoutArticleInput>
    connectOrCreate?: BoxCreateOrConnectWithoutArticleInput
    connect?: BoxWhereUniqueInput
  }

  export type ArticlePhotoCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<ArticlePhotoCreateWithoutArticleInput>, Enumerable<ArticlePhotoUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<ArticlePhotoCreateOrConnectWithoutArticleInput>
    createMany?: ArticlePhotoCreateManyArticleInputEnvelope
    connect?: Enumerable<ArticlePhotoWhereUniqueInput>
  }

  export type PostCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<PostCreateWithoutArticleInput>, Enumerable<PostUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutArticleInput>
    createMany?: PostCreateManyArticleInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type PriceCreateNestedOneWithoutArticleInput = {
    create?: XOR<PriceCreateWithoutArticleInput, PriceUncheckedCreateWithoutArticleInput>
    connectOrCreate?: PriceCreateOrConnectWithoutArticleInput
    connect?: PriceWhereUniqueInput
  }

  export type BoxArticleCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<BoxArticleCreateWithoutArticleInput>, Enumerable<BoxArticleUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<BoxArticleCreateOrConnectWithoutArticleInput>
    createMany?: BoxArticleCreateManyArticleInputEnvelope
    connect?: Enumerable<BoxArticleWhereUniqueInput>
  }

  export type GameCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<GameCreateWithoutArticleInput>, Enumerable<GameUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutArticleInput>
    createMany?: GameCreateManyArticleInputEnvelope
    connect?: Enumerable<GameWhereUniqueInput>
  }

  export type ArticlePhotoUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<ArticlePhotoCreateWithoutArticleInput>, Enumerable<ArticlePhotoUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<ArticlePhotoCreateOrConnectWithoutArticleInput>
    createMany?: ArticlePhotoCreateManyArticleInputEnvelope
    connect?: Enumerable<ArticlePhotoWhereUniqueInput>
  }

  export type PostUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<PostCreateWithoutArticleInput>, Enumerable<PostUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutArticleInput>
    createMany?: PostCreateManyArticleInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type PriceUncheckedCreateNestedOneWithoutArticleInput = {
    create?: XOR<PriceCreateWithoutArticleInput, PriceUncheckedCreateWithoutArticleInput>
    connectOrCreate?: PriceCreateOrConnectWithoutArticleInput
    connect?: PriceWhereUniqueInput
  }

  export type BoxArticleUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<BoxArticleCreateWithoutArticleInput>, Enumerable<BoxArticleUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<BoxArticleCreateOrConnectWithoutArticleInput>
    createMany?: BoxArticleCreateManyArticleInputEnvelope
    connect?: Enumerable<BoxArticleWhereUniqueInput>
  }

  export type GameUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<GameCreateWithoutArticleInput>, Enumerable<GameUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutArticleInput>
    createMany?: GameCreateManyArticleInputEnvelope
    connect?: Enumerable<GameWhereUniqueInput>
  }

  export type NullableEnumEnumTypeModeFieldUpdateOperationsInput = {
    set?: EnumTypeMode | null
    unset?: boolean
  }

  export type ProviderUpdateOneWithoutArticleNestedInput = {
    create?: XOR<ProviderCreateWithoutArticleInput, ProviderUncheckedCreateWithoutArticleInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutArticleInput
    upsert?: ProviderUpsertWithoutArticleInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProviderWhereUniqueInput
    update?: XOR<ProviderUpdateWithoutArticleInput, ProviderUncheckedUpdateWithoutArticleInput>
  }

  export type UnitySizeUpdateOneWithoutArticleNestedInput = {
    create?: XOR<UnitySizeCreateWithoutArticleInput, UnitySizeUncheckedCreateWithoutArticleInput>
    connectOrCreate?: UnitySizeCreateOrConnectWithoutArticleInput
    upsert?: UnitySizeUpsertWithoutArticleInput
    disconnect?: boolean
    delete?: boolean
    connect?: UnitySizeWhereUniqueInput
    update?: XOR<UnitySizeUpdateWithoutArticleInput, UnitySizeUncheckedUpdateWithoutArticleInput>
  }

  export type SubCategoryUpdateOneWithoutArticleNestedInput = {
    create?: XOR<SubCategoryCreateWithoutArticleInput, SubCategoryUncheckedCreateWithoutArticleInput>
    connectOrCreate?: SubCategoryCreateOrConnectWithoutArticleInput
    upsert?: SubCategoryUpsertWithoutArticleInput
    disconnect?: boolean
    delete?: boolean
    connect?: SubCategoryWhereUniqueInput
    update?: XOR<SubCategoryUpdateWithoutArticleInput, SubCategoryUncheckedUpdateWithoutArticleInput>
  }

  export type BoxUpdateOneWithoutArticleNestedInput = {
    create?: XOR<BoxCreateWithoutArticleInput, BoxUncheckedCreateWithoutArticleInput>
    connectOrCreate?: BoxCreateOrConnectWithoutArticleInput
    upsert?: BoxUpsertWithoutArticleInput
    disconnect?: boolean
    delete?: boolean
    connect?: BoxWhereUniqueInput
    update?: XOR<BoxUpdateWithoutArticleInput, BoxUncheckedUpdateWithoutArticleInput>
  }

  export type ArticlePhotoUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<ArticlePhotoCreateWithoutArticleInput>, Enumerable<ArticlePhotoUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<ArticlePhotoCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<ArticlePhotoUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: ArticlePhotoCreateManyArticleInputEnvelope
    set?: Enumerable<ArticlePhotoWhereUniqueInput>
    disconnect?: Enumerable<ArticlePhotoWhereUniqueInput>
    delete?: Enumerable<ArticlePhotoWhereUniqueInput>
    connect?: Enumerable<ArticlePhotoWhereUniqueInput>
    update?: Enumerable<ArticlePhotoUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<ArticlePhotoUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<ArticlePhotoScalarWhereInput>
  }

  export type PostUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<PostCreateWithoutArticleInput>, Enumerable<PostUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: PostCreateManyArticleInputEnvelope
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    connect?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type PriceUpdateOneWithoutArticleNestedInput = {
    create?: XOR<PriceCreateWithoutArticleInput, PriceUncheckedCreateWithoutArticleInput>
    connectOrCreate?: PriceCreateOrConnectWithoutArticleInput
    upsert?: PriceUpsertWithoutArticleInput
    disconnect?: boolean
    delete?: boolean
    connect?: PriceWhereUniqueInput
    update?: XOR<PriceUpdateWithoutArticleInput, PriceUncheckedUpdateWithoutArticleInput>
  }

  export type BoxArticleUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<BoxArticleCreateWithoutArticleInput>, Enumerable<BoxArticleUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<BoxArticleCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<BoxArticleUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: BoxArticleCreateManyArticleInputEnvelope
    set?: Enumerable<BoxArticleWhereUniqueInput>
    disconnect?: Enumerable<BoxArticleWhereUniqueInput>
    delete?: Enumerable<BoxArticleWhereUniqueInput>
    connect?: Enumerable<BoxArticleWhereUniqueInput>
    update?: Enumerable<BoxArticleUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<BoxArticleUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<BoxArticleScalarWhereInput>
  }

  export type GameUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<GameCreateWithoutArticleInput>, Enumerable<GameUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<GameUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: GameCreateManyArticleInputEnvelope
    set?: Enumerable<GameWhereUniqueInput>
    disconnect?: Enumerable<GameWhereUniqueInput>
    delete?: Enumerable<GameWhereUniqueInput>
    connect?: Enumerable<GameWhereUniqueInput>
    update?: Enumerable<GameUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<GameUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<GameScalarWhereInput>
  }

  export type ArticlePhotoUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<ArticlePhotoCreateWithoutArticleInput>, Enumerable<ArticlePhotoUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<ArticlePhotoCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<ArticlePhotoUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: ArticlePhotoCreateManyArticleInputEnvelope
    set?: Enumerable<ArticlePhotoWhereUniqueInput>
    disconnect?: Enumerable<ArticlePhotoWhereUniqueInput>
    delete?: Enumerable<ArticlePhotoWhereUniqueInput>
    connect?: Enumerable<ArticlePhotoWhereUniqueInput>
    update?: Enumerable<ArticlePhotoUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<ArticlePhotoUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<ArticlePhotoScalarWhereInput>
  }

  export type PostUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<PostCreateWithoutArticleInput>, Enumerable<PostUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: PostCreateManyArticleInputEnvelope
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    connect?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type PriceUncheckedUpdateOneWithoutArticleNestedInput = {
    create?: XOR<PriceCreateWithoutArticleInput, PriceUncheckedCreateWithoutArticleInput>
    connectOrCreate?: PriceCreateOrConnectWithoutArticleInput
    upsert?: PriceUpsertWithoutArticleInput
    disconnect?: boolean
    delete?: boolean
    connect?: PriceWhereUniqueInput
    update?: XOR<PriceUpdateWithoutArticleInput, PriceUncheckedUpdateWithoutArticleInput>
  }

  export type BoxArticleUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<BoxArticleCreateWithoutArticleInput>, Enumerable<BoxArticleUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<BoxArticleCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<BoxArticleUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: BoxArticleCreateManyArticleInputEnvelope
    set?: Enumerable<BoxArticleWhereUniqueInput>
    disconnect?: Enumerable<BoxArticleWhereUniqueInput>
    delete?: Enumerable<BoxArticleWhereUniqueInput>
    connect?: Enumerable<BoxArticleWhereUniqueInput>
    update?: Enumerable<BoxArticleUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<BoxArticleUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<BoxArticleScalarWhereInput>
  }

  export type GameUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<GameCreateWithoutArticleInput>, Enumerable<GameUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<GameUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: GameCreateManyArticleInputEnvelope
    set?: Enumerable<GameWhereUniqueInput>
    disconnect?: Enumerable<GameWhereUniqueInput>
    delete?: Enumerable<GameWhereUniqueInput>
    connect?: Enumerable<GameWhereUniqueInput>
    update?: Enumerable<GameUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<GameUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<GameScalarWhereInput>
  }

  export type BoxCreateNestedOneWithoutBoxArticleInput = {
    create?: XOR<BoxCreateWithoutBoxArticleInput, BoxUncheckedCreateWithoutBoxArticleInput>
    connectOrCreate?: BoxCreateOrConnectWithoutBoxArticleInput
    connect?: BoxWhereUniqueInput
  }

  export type ArticleCreateNestedOneWithoutBoxArticleInput = {
    create?: XOR<ArticleCreateWithoutBoxArticleInput, ArticleUncheckedCreateWithoutBoxArticleInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutBoxArticleInput
    connect?: ArticleWhereUniqueInput
  }

  export type BoxUpdateOneRequiredWithoutBoxArticleNestedInput = {
    create?: XOR<BoxCreateWithoutBoxArticleInput, BoxUncheckedCreateWithoutBoxArticleInput>
    connectOrCreate?: BoxCreateOrConnectWithoutBoxArticleInput
    upsert?: BoxUpsertWithoutBoxArticleInput
    connect?: BoxWhereUniqueInput
    update?: XOR<BoxUpdateWithoutBoxArticleInput, BoxUncheckedUpdateWithoutBoxArticleInput>
  }

  export type ArticleUpdateOneRequiredWithoutBoxArticleNestedInput = {
    create?: XOR<ArticleCreateWithoutBoxArticleInput, ArticleUncheckedCreateWithoutBoxArticleInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutBoxArticleInput
    upsert?: ArticleUpsertWithoutBoxArticleInput
    connect?: ArticleWhereUniqueInput
    update?: XOR<ArticleUpdateWithoutBoxArticleInput, ArticleUncheckedUpdateWithoutBoxArticleInput>
  }

  export type ArticleCreateNestedOneWithoutArticlePhotoInput = {
    create?: XOR<ArticleCreateWithoutArticlePhotoInput, ArticleUncheckedCreateWithoutArticlePhotoInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutArticlePhotoInput
    connect?: ArticleWhereUniqueInput
  }

  export type NullableEnumArticlePhotoStatusFieldUpdateOperationsInput = {
    set?: ArticlePhotoStatus | null
    unset?: boolean
  }

  export type ArticleUpdateOneRequiredWithoutArticlePhotoNestedInput = {
    create?: XOR<ArticleCreateWithoutArticlePhotoInput, ArticleUncheckedCreateWithoutArticlePhotoInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutArticlePhotoInput
    upsert?: ArticleUpsertWithoutArticlePhotoInput
    connect?: ArticleWhereUniqueInput
    update?: XOR<ArticleUpdateWithoutArticlePhotoInput, ArticleUncheckedUpdateWithoutArticlePhotoInput>
  }

  export type ArticleCreateNestedOneWithoutPostInput = {
    create?: XOR<ArticleCreateWithoutPostInput, ArticleUncheckedCreateWithoutPostInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutPostInput
    connect?: ArticleWhereUniqueInput
  }

  export type ArticleUpdateOneRequiredWithoutPostNestedInput = {
    create?: XOR<ArticleCreateWithoutPostInput, ArticleUncheckedCreateWithoutPostInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutPostInput
    upsert?: ArticleUpsertWithoutPostInput
    connect?: ArticleWhereUniqueInput
    update?: XOR<ArticleUpdateWithoutPostInput, ArticleUncheckedUpdateWithoutPostInput>
  }

  export type ArticleCreateNestedOneWithoutPriceInput = {
    create?: XOR<ArticleCreateWithoutPriceInput, ArticleUncheckedCreateWithoutPriceInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutPriceInput
    connect?: ArticleWhereUniqueInput
  }

  export type ArticleUpdateOneRequiredWithoutPriceNestedInput = {
    create?: XOR<ArticleCreateWithoutPriceInput, ArticleUncheckedCreateWithoutPriceInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutPriceInput
    upsert?: ArticleUpsertWithoutPriceInput
    connect?: ArticleWhereUniqueInput
    update?: XOR<ArticleUpdateWithoutPriceInput, ArticleUncheckedUpdateWithoutPriceInput>
  }

  export type ShoppingCartCreateNestedOneWithoutOrderInput = {
    create?: XOR<ShoppingCartCreateWithoutOrderInput, ShoppingCartUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutOrderInput
    connect?: ShoppingCartWhereUniqueInput
  }

  export type EnumEnumOrderStatusFieldUpdateOperationsInput = {
    set?: EnumOrderStatus
  }

  export type ShoppingCartUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<ShoppingCartCreateWithoutOrderInput, ShoppingCartUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutOrderInput
    upsert?: ShoppingCartUpsertWithoutOrderInput
    connect?: ShoppingCartWhereUniqueInput
    update?: XOR<ShoppingCartUpdateWithoutOrderInput, ShoppingCartUncheckedUpdateWithoutOrderInput>
  }

  export type GameCreateNestedOneWithoutShoppingCartInput = {
    create?: XOR<GameCreateWithoutShoppingCartInput, GameUncheckedCreateWithoutShoppingCartInput>
    connectOrCreate?: GameCreateOrConnectWithoutShoppingCartInput
    connect?: GameWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutShoppingCartInput = {
    create?: XOR<UserCreateWithoutShoppingCartInput, UserUncheckedCreateWithoutShoppingCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutShoppingCartInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutShoppingCartInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutShoppingCartInput>, Enumerable<TransactionUncheckedCreateWithoutShoppingCartInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutShoppingCartInput>
    createMany?: TransactionCreateManyShoppingCartInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type OrderCreateNestedOneWithoutShoppingCartInput = {
    create?: XOR<OrderCreateWithoutShoppingCartInput, OrderUncheckedCreateWithoutShoppingCartInput>
    connectOrCreate?: OrderCreateOrConnectWithoutShoppingCartInput
    connect?: OrderWhereUniqueInput
  }

  export type TransactionUncheckedCreateNestedManyWithoutShoppingCartInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutShoppingCartInput>, Enumerable<TransactionUncheckedCreateWithoutShoppingCartInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutShoppingCartInput>
    createMany?: TransactionCreateManyShoppingCartInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type OrderUncheckedCreateNestedOneWithoutShoppingCartInput = {
    create?: XOR<OrderCreateWithoutShoppingCartInput, OrderUncheckedCreateWithoutShoppingCartInput>
    connectOrCreate?: OrderCreateOrConnectWithoutShoppingCartInput
    connect?: OrderWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type GameUpdateOneRequiredWithoutShoppingCartNestedInput = {
    create?: XOR<GameCreateWithoutShoppingCartInput, GameUncheckedCreateWithoutShoppingCartInput>
    connectOrCreate?: GameCreateOrConnectWithoutShoppingCartInput
    upsert?: GameUpsertWithoutShoppingCartInput
    connect?: GameWhereUniqueInput
    update?: XOR<GameUpdateWithoutShoppingCartInput, GameUncheckedUpdateWithoutShoppingCartInput>
  }

  export type UserUpdateOneRequiredWithoutShoppingCartNestedInput = {
    create?: XOR<UserCreateWithoutShoppingCartInput, UserUncheckedCreateWithoutShoppingCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutShoppingCartInput
    upsert?: UserUpsertWithoutShoppingCartInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutShoppingCartInput, UserUncheckedUpdateWithoutShoppingCartInput>
  }

  export type TransactionUpdateManyWithoutShoppingCartNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutShoppingCartInput>, Enumerable<TransactionUncheckedCreateWithoutShoppingCartInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutShoppingCartInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutShoppingCartInput>
    createMany?: TransactionCreateManyShoppingCartInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutShoppingCartInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutShoppingCartInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type OrderUpdateOneWithoutShoppingCartNestedInput = {
    create?: XOR<OrderCreateWithoutShoppingCartInput, OrderUncheckedCreateWithoutShoppingCartInput>
    connectOrCreate?: OrderCreateOrConnectWithoutShoppingCartInput
    upsert?: OrderUpsertWithoutShoppingCartInput
    disconnect?: boolean
    delete?: boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<OrderUpdateWithoutShoppingCartInput, OrderUncheckedUpdateWithoutShoppingCartInput>
  }

  export type TransactionUncheckedUpdateManyWithoutShoppingCartNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutShoppingCartInput>, Enumerable<TransactionUncheckedCreateWithoutShoppingCartInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutShoppingCartInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutShoppingCartInput>
    createMany?: TransactionCreateManyShoppingCartInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutShoppingCartInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutShoppingCartInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type OrderUncheckedUpdateOneWithoutShoppingCartNestedInput = {
    create?: XOR<OrderCreateWithoutShoppingCartInput, OrderUncheckedCreateWithoutShoppingCartInput>
    connectOrCreate?: OrderCreateOrConnectWithoutShoppingCartInput
    upsert?: OrderUpsertWithoutShoppingCartInput
    disconnect?: boolean
    delete?: boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<OrderUpdateWithoutShoppingCartInput, OrderUncheckedUpdateWithoutShoppingCartInput>
  }

  export type BoxCreateNestedOneWithoutTransactionInput = {
    create?: XOR<BoxCreateWithoutTransactionInput, BoxUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: BoxCreateOrConnectWithoutTransactionInput
    connect?: BoxWhereUniqueInput
  }

  export type WalletCreateNestedOneWithoutTransactionInput = {
    create?: XOR<WalletCreateWithoutTransactionInput, WalletUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTransactionInput
    connect?: WalletWhereUniqueInput
  }

  export type OfferCreateNestedOneWithoutTransactionInput = {
    create?: XOR<OfferCreateWithoutTransactionInput, OfferUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: OfferCreateOrConnectWithoutTransactionInput
    connect?: OfferWhereUniqueInput
  }

  export type ShoppingCartCreateNestedOneWithoutTransactionInput = {
    create?: XOR<ShoppingCartCreateWithoutTransactionInput, ShoppingCartUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutTransactionInput
    connect?: ShoppingCartWhereUniqueInput
  }

  export type BankCreateNestedOneWithoutTransactionInput = {
    create?: XOR<BankCreateWithoutTransactionInput, BankUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: BankCreateOrConnectWithoutTransactionInput
    connect?: BankWhereUniqueInput
  }

  export type GameCreateNestedOneWithoutTransactionInput = {
    create?: XOR<GameCreateWithoutTransactionInput, GameUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: GameCreateOrConnectWithoutTransactionInput
    connect?: GameWhereUniqueInput
  }

  export type EnumEnumTypeTransactionFieldUpdateOperationsInput = {
    set?: EnumTypeTransaction
  }

  export type EnumEnumStatusTransactionFieldUpdateOperationsInput = {
    set?: EnumStatusTransaction
  }

  export type BoxUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<BoxCreateWithoutTransactionInput, BoxUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: BoxCreateOrConnectWithoutTransactionInput
    upsert?: BoxUpsertWithoutTransactionInput
    disconnect?: boolean
    delete?: boolean
    connect?: BoxWhereUniqueInput
    update?: XOR<BoxUpdateWithoutTransactionInput, BoxUncheckedUpdateWithoutTransactionInput>
  }

  export type WalletUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<WalletCreateWithoutTransactionInput, WalletUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTransactionInput
    upsert?: WalletUpsertWithoutTransactionInput
    connect?: WalletWhereUniqueInput
    update?: XOR<WalletUpdateWithoutTransactionInput, WalletUncheckedUpdateWithoutTransactionInput>
  }

  export type OfferUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<OfferCreateWithoutTransactionInput, OfferUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: OfferCreateOrConnectWithoutTransactionInput
    upsert?: OfferUpsertWithoutTransactionInput
    disconnect?: boolean
    delete?: boolean
    connect?: OfferWhereUniqueInput
    update?: XOR<OfferUpdateWithoutTransactionInput, OfferUncheckedUpdateWithoutTransactionInput>
  }

  export type ShoppingCartUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<ShoppingCartCreateWithoutTransactionInput, ShoppingCartUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutTransactionInput
    upsert?: ShoppingCartUpsertWithoutTransactionInput
    disconnect?: boolean
    delete?: boolean
    connect?: ShoppingCartWhereUniqueInput
    update?: XOR<ShoppingCartUpdateWithoutTransactionInput, ShoppingCartUncheckedUpdateWithoutTransactionInput>
  }

  export type BankUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<BankCreateWithoutTransactionInput, BankUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: BankCreateOrConnectWithoutTransactionInput
    upsert?: BankUpsertWithoutTransactionInput
    disconnect?: boolean
    delete?: boolean
    connect?: BankWhereUniqueInput
    update?: XOR<BankUpdateWithoutTransactionInput, BankUncheckedUpdateWithoutTransactionInput>
  }

  export type GameUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<GameCreateWithoutTransactionInput, GameUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: GameCreateOrConnectWithoutTransactionInput
    upsert?: GameUpsertWithoutTransactionInput
    disconnect?: boolean
    delete?: boolean
    connect?: GameWhereUniqueInput
    update?: XOR<GameUpdateWithoutTransactionInput, GameUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionCreateNestedManyWithoutBankInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutBankInput>, Enumerable<TransactionUncheckedCreateWithoutBankInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutBankInput>
    createMany?: TransactionCreateManyBankInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type TransactionUncheckedCreateNestedManyWithoutBankInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutBankInput>, Enumerable<TransactionUncheckedCreateWithoutBankInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutBankInput>
    createMany?: TransactionCreateManyBankInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type TransactionUpdateManyWithoutBankNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutBankInput>, Enumerable<TransactionUncheckedCreateWithoutBankInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutBankInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutBankInput>
    createMany?: TransactionCreateManyBankInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutBankInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutBankInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type TransactionUncheckedUpdateManyWithoutBankNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutBankInput>, Enumerable<TransactionUncheckedCreateWithoutBankInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutBankInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutBankInput>
    createMany?: TransactionCreateManyBankInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutBankInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutBankInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutUserBoxInput = {
    create?: XOR<UserCreateWithoutUserBoxInput, UserUncheckedCreateWithoutUserBoxInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserBoxInput
    connect?: UserWhereUniqueInput
  }

  export type BoxCreateNestedOneWithoutUserBoxInput = {
    create?: XOR<BoxCreateWithoutUserBoxInput, BoxUncheckedCreateWithoutUserBoxInput>
    connectOrCreate?: BoxCreateOrConnectWithoutUserBoxInput
    connect?: BoxWhereUniqueInput
  }

  export type GameCreateNestedManyWithoutUserBoxInput = {
    create?: XOR<Enumerable<GameCreateWithoutUserBoxInput>, Enumerable<GameUncheckedCreateWithoutUserBoxInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutUserBoxInput>
    createMany?: GameCreateManyUserBoxInputEnvelope
    connect?: Enumerable<GameWhereUniqueInput>
  }

  export type GameUncheckedCreateNestedManyWithoutUserBoxInput = {
    create?: XOR<Enumerable<GameCreateWithoutUserBoxInput>, Enumerable<GameUncheckedCreateWithoutUserBoxInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutUserBoxInput>
    createMany?: GameCreateManyUserBoxInputEnvelope
    connect?: Enumerable<GameWhereUniqueInput>
  }

  export type EnumEnumUserBoxTypeFieldUpdateOperationsInput = {
    set?: EnumUserBoxType
  }

  export type UserUpdateOneRequiredWithoutUserBoxNestedInput = {
    create?: XOR<UserCreateWithoutUserBoxInput, UserUncheckedCreateWithoutUserBoxInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserBoxInput
    upsert?: UserUpsertWithoutUserBoxInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserBoxInput, UserUncheckedUpdateWithoutUserBoxInput>
  }

  export type BoxUpdateOneRequiredWithoutUserBoxNestedInput = {
    create?: XOR<BoxCreateWithoutUserBoxInput, BoxUncheckedCreateWithoutUserBoxInput>
    connectOrCreate?: BoxCreateOrConnectWithoutUserBoxInput
    upsert?: BoxUpsertWithoutUserBoxInput
    connect?: BoxWhereUniqueInput
    update?: XOR<BoxUpdateWithoutUserBoxInput, BoxUncheckedUpdateWithoutUserBoxInput>
  }

  export type GameUpdateManyWithoutUserBoxNestedInput = {
    create?: XOR<Enumerable<GameCreateWithoutUserBoxInput>, Enumerable<GameUncheckedCreateWithoutUserBoxInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutUserBoxInput>
    upsert?: Enumerable<GameUpsertWithWhereUniqueWithoutUserBoxInput>
    createMany?: GameCreateManyUserBoxInputEnvelope
    set?: Enumerable<GameWhereUniqueInput>
    disconnect?: Enumerable<GameWhereUniqueInput>
    delete?: Enumerable<GameWhereUniqueInput>
    connect?: Enumerable<GameWhereUniqueInput>
    update?: Enumerable<GameUpdateWithWhereUniqueWithoutUserBoxInput>
    updateMany?: Enumerable<GameUpdateManyWithWhereWithoutUserBoxInput>
    deleteMany?: Enumerable<GameScalarWhereInput>
  }

  export type GameUncheckedUpdateManyWithoutUserBoxNestedInput = {
    create?: XOR<Enumerable<GameCreateWithoutUserBoxInput>, Enumerable<GameUncheckedCreateWithoutUserBoxInput>>
    connectOrCreate?: Enumerable<GameCreateOrConnectWithoutUserBoxInput>
    upsert?: Enumerable<GameUpsertWithWhereUniqueWithoutUserBoxInput>
    createMany?: GameCreateManyUserBoxInputEnvelope
    set?: Enumerable<GameWhereUniqueInput>
    disconnect?: Enumerable<GameWhereUniqueInput>
    delete?: Enumerable<GameWhereUniqueInput>
    connect?: Enumerable<GameWhereUniqueInput>
    update?: Enumerable<GameUpdateWithWhereUniqueWithoutUserBoxInput>
    updateMany?: Enumerable<GameUpdateManyWithWhereWithoutUserBoxInput>
    deleteMany?: Enumerable<GameScalarWhereInput>
  }

  export type BoxCreateNestedOneWithoutBannerImageInput = {
    create?: XOR<BoxCreateWithoutBannerImageInput, BoxUncheckedCreateWithoutBannerImageInput>
    connectOrCreate?: BoxCreateOrConnectWithoutBannerImageInput
    connect?: BoxWhereUniqueInput
  }

  export type OfferCreateNestedOneWithoutBannerImageInput = {
    create?: XOR<OfferCreateWithoutBannerImageInput, OfferUncheckedCreateWithoutBannerImageInput>
    connectOrCreate?: OfferCreateOrConnectWithoutBannerImageInput
    connect?: OfferWhereUniqueInput
  }

  export type NullableEnumBannerImageTypeFieldUpdateOperationsInput = {
    set?: BannerImageType | null
    unset?: boolean
  }

  export type BoxUpdateOneWithoutBannerImageNestedInput = {
    create?: XOR<BoxCreateWithoutBannerImageInput, BoxUncheckedCreateWithoutBannerImageInput>
    connectOrCreate?: BoxCreateOrConnectWithoutBannerImageInput
    upsert?: BoxUpsertWithoutBannerImageInput
    disconnect?: boolean
    delete?: boolean
    connect?: BoxWhereUniqueInput
    update?: XOR<BoxUpdateWithoutBannerImageInput, BoxUncheckedUpdateWithoutBannerImageInput>
  }

  export type OfferUpdateOneWithoutBannerImageNestedInput = {
    create?: XOR<OfferCreateWithoutBannerImageInput, OfferUncheckedCreateWithoutBannerImageInput>
    connectOrCreate?: OfferCreateOrConnectWithoutBannerImageInput
    upsert?: OfferUpsertWithoutBannerImageInput
    disconnect?: boolean
    delete?: boolean
    connect?: OfferWhereUniqueInput
    update?: XOR<OfferUpdateWithoutBannerImageInput, OfferUncheckedUpdateWithoutBannerImageInput>
  }

  export type BoxCreateNestedOneWithoutBoxParamsInput = {
    create?: XOR<BoxCreateWithoutBoxParamsInput, BoxUncheckedCreateWithoutBoxParamsInput>
    connectOrCreate?: BoxCreateOrConnectWithoutBoxParamsInput
    connect?: BoxWhereUniqueInput
  }

  export type BoxUpdateOneWithoutBoxParamsNestedInput = {
    create?: XOR<BoxCreateWithoutBoxParamsInput, BoxUncheckedCreateWithoutBoxParamsInput>
    connectOrCreate?: BoxCreateOrConnectWithoutBoxParamsInput
    upsert?: BoxUpsertWithoutBoxParamsInput
    disconnect?: boolean
    delete?: boolean
    connect?: BoxWhereUniqueInput
    update?: XOR<BoxUpdateWithoutBoxParamsInput, BoxUncheckedUpdateWithoutBoxParamsInput>
  }

  export type UserCreateNestedOneWithoutHistoricalInput = {
    create?: XOR<UserCreateWithoutHistoricalInput, UserUncheckedCreateWithoutHistoricalInput>
    connectOrCreate?: UserCreateOrConnectWithoutHistoricalInput
    connect?: UserWhereUniqueInput
  }

  export type EnumEnumHistoricalActionFieldUpdateOperationsInput = {
    set?: EnumHistoricalAction
  }

  export type UserUpdateOneRequiredWithoutHistoricalNestedInput = {
    create?: XOR<UserCreateWithoutHistoricalInput, UserUncheckedCreateWithoutHistoricalInput>
    connectOrCreate?: UserCreateOrConnectWithoutHistoricalInput
    upsert?: UserUpsertWithoutHistoricalInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutHistoricalInput, UserUncheckedUpdateWithoutHistoricalInput>
  }

  export type UserCreateNestedOneWithoutMessageInput = {
    create?: XOR<UserCreateWithoutMessageInput, UserUncheckedCreateWithoutMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageInput
    connect?: UserWhereUniqueInput
  }

  export type ReceiverCreateNestedManyWithoutMessageInput = {
    create?: XOR<Enumerable<ReceiverCreateWithoutMessageInput>, Enumerable<ReceiverUncheckedCreateWithoutMessageInput>>
    connectOrCreate?: Enumerable<ReceiverCreateOrConnectWithoutMessageInput>
    createMany?: ReceiverCreateManyMessageInputEnvelope
    connect?: Enumerable<ReceiverWhereUniqueInput>
  }

  export type ReceiverUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<Enumerable<ReceiverCreateWithoutMessageInput>, Enumerable<ReceiverUncheckedCreateWithoutMessageInput>>
    connectOrCreate?: Enumerable<ReceiverCreateOrConnectWithoutMessageInput>
    createMany?: ReceiverCreateManyMessageInputEnvelope
    connect?: Enumerable<ReceiverWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutMessageNestedInput = {
    create?: XOR<UserCreateWithoutMessageInput, UserUncheckedCreateWithoutMessageInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageInput
    upsert?: UserUpsertWithoutMessageInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutMessageInput, UserUncheckedUpdateWithoutMessageInput>
  }

  export type ReceiverUpdateManyWithoutMessageNestedInput = {
    create?: XOR<Enumerable<ReceiverCreateWithoutMessageInput>, Enumerable<ReceiverUncheckedCreateWithoutMessageInput>>
    connectOrCreate?: Enumerable<ReceiverCreateOrConnectWithoutMessageInput>
    upsert?: Enumerable<ReceiverUpsertWithWhereUniqueWithoutMessageInput>
    createMany?: ReceiverCreateManyMessageInputEnvelope
    set?: Enumerable<ReceiverWhereUniqueInput>
    disconnect?: Enumerable<ReceiverWhereUniqueInput>
    delete?: Enumerable<ReceiverWhereUniqueInput>
    connect?: Enumerable<ReceiverWhereUniqueInput>
    update?: Enumerable<ReceiverUpdateWithWhereUniqueWithoutMessageInput>
    updateMany?: Enumerable<ReceiverUpdateManyWithWhereWithoutMessageInput>
    deleteMany?: Enumerable<ReceiverScalarWhereInput>
  }

  export type ReceiverUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<Enumerable<ReceiverCreateWithoutMessageInput>, Enumerable<ReceiverUncheckedCreateWithoutMessageInput>>
    connectOrCreate?: Enumerable<ReceiverCreateOrConnectWithoutMessageInput>
    upsert?: Enumerable<ReceiverUpsertWithWhereUniqueWithoutMessageInput>
    createMany?: ReceiverCreateManyMessageInputEnvelope
    set?: Enumerable<ReceiverWhereUniqueInput>
    disconnect?: Enumerable<ReceiverWhereUniqueInput>
    delete?: Enumerable<ReceiverWhereUniqueInput>
    connect?: Enumerable<ReceiverWhereUniqueInput>
    update?: Enumerable<ReceiverUpdateWithWhereUniqueWithoutMessageInput>
    updateMany?: Enumerable<ReceiverUpdateManyWithWhereWithoutMessageInput>
    deleteMany?: Enumerable<ReceiverScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutReceiverInput = {
    create?: XOR<UserCreateWithoutReceiverInput, UserUncheckedCreateWithoutReceiverInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceiverInput
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedOneWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput
    connect?: MessageWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReceiverNestedInput = {
    create?: XOR<UserCreateWithoutReceiverInput, UserUncheckedCreateWithoutReceiverInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceiverInput
    upsert?: UserUpsertWithoutReceiverInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutReceiverInput, UserUncheckedUpdateWithoutReceiverInput>
  }

  export type MessageUpdateOneRequiredWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput
    upsert?: MessageUpsertWithoutReceiverInput
    connect?: MessageWhereUniqueInput
    update?: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
  }

  export type UserCreateNestedOneWithoutTemoignageInput = {
    create?: XOR<UserCreateWithoutTemoignageInput, UserUncheckedCreateWithoutTemoignageInput>
    connectOrCreate?: UserCreateOrConnectWithoutTemoignageInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTemoignageNestedInput = {
    create?: XOR<UserCreateWithoutTemoignageInput, UserUncheckedCreateWithoutTemoignageInput>
    connectOrCreate?: UserCreateOrConnectWithoutTemoignageInput
    upsert?: UserUpsertWithoutTemoignageInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTemoignageInput, UserUncheckedUpdateWithoutTemoignageInput>
  }

  export type SubscriptionCreateNestedManyWithoutOfferInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutOfferInput>, Enumerable<SubscriptionUncheckedCreateWithoutOfferInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutOfferInput>
    createMany?: SubscriptionCreateManyOfferInputEnvelope
    connect?: Enumerable<SubscriptionWhereUniqueInput>
  }

  export type BannerImageCreateNestedManyWithoutOfferInput = {
    create?: XOR<Enumerable<BannerImageCreateWithoutOfferInput>, Enumerable<BannerImageUncheckedCreateWithoutOfferInput>>
    connectOrCreate?: Enumerable<BannerImageCreateOrConnectWithoutOfferInput>
    createMany?: BannerImageCreateManyOfferInputEnvelope
    connect?: Enumerable<BannerImageWhereUniqueInput>
  }

  export type TransactionCreateNestedManyWithoutOfferInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutOfferInput>, Enumerable<TransactionUncheckedCreateWithoutOfferInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutOfferInput>
    createMany?: TransactionCreateManyOfferInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutOfferInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutOfferInput>, Enumerable<SubscriptionUncheckedCreateWithoutOfferInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutOfferInput>
    createMany?: SubscriptionCreateManyOfferInputEnvelope
    connect?: Enumerable<SubscriptionWhereUniqueInput>
  }

  export type BannerImageUncheckedCreateNestedManyWithoutOfferInput = {
    create?: XOR<Enumerable<BannerImageCreateWithoutOfferInput>, Enumerable<BannerImageUncheckedCreateWithoutOfferInput>>
    connectOrCreate?: Enumerable<BannerImageCreateOrConnectWithoutOfferInput>
    createMany?: BannerImageCreateManyOfferInputEnvelope
    connect?: Enumerable<BannerImageWhereUniqueInput>
  }

  export type TransactionUncheckedCreateNestedManyWithoutOfferInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutOfferInput>, Enumerable<TransactionUncheckedCreateWithoutOfferInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutOfferInput>
    createMany?: TransactionCreateManyOfferInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type SubscriptionUpdateManyWithoutOfferNestedInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutOfferInput>, Enumerable<SubscriptionUncheckedCreateWithoutOfferInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutOfferInput>
    upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutOfferInput>
    createMany?: SubscriptionCreateManyOfferInputEnvelope
    set?: Enumerable<SubscriptionWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionWhereUniqueInput>
    delete?: Enumerable<SubscriptionWhereUniqueInput>
    connect?: Enumerable<SubscriptionWhereUniqueInput>
    update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutOfferInput>
    updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutOfferInput>
    deleteMany?: Enumerable<SubscriptionScalarWhereInput>
  }

  export type BannerImageUpdateManyWithoutOfferNestedInput = {
    create?: XOR<Enumerable<BannerImageCreateWithoutOfferInput>, Enumerable<BannerImageUncheckedCreateWithoutOfferInput>>
    connectOrCreate?: Enumerable<BannerImageCreateOrConnectWithoutOfferInput>
    upsert?: Enumerable<BannerImageUpsertWithWhereUniqueWithoutOfferInput>
    createMany?: BannerImageCreateManyOfferInputEnvelope
    set?: Enumerable<BannerImageWhereUniqueInput>
    disconnect?: Enumerable<BannerImageWhereUniqueInput>
    delete?: Enumerable<BannerImageWhereUniqueInput>
    connect?: Enumerable<BannerImageWhereUniqueInput>
    update?: Enumerable<BannerImageUpdateWithWhereUniqueWithoutOfferInput>
    updateMany?: Enumerable<BannerImageUpdateManyWithWhereWithoutOfferInput>
    deleteMany?: Enumerable<BannerImageScalarWhereInput>
  }

  export type TransactionUpdateManyWithoutOfferNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutOfferInput>, Enumerable<TransactionUncheckedCreateWithoutOfferInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutOfferInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutOfferInput>
    createMany?: TransactionCreateManyOfferInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutOfferInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutOfferInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type SubscriptionUncheckedUpdateManyWithoutOfferNestedInput = {
    create?: XOR<Enumerable<SubscriptionCreateWithoutOfferInput>, Enumerable<SubscriptionUncheckedCreateWithoutOfferInput>>
    connectOrCreate?: Enumerable<SubscriptionCreateOrConnectWithoutOfferInput>
    upsert?: Enumerable<SubscriptionUpsertWithWhereUniqueWithoutOfferInput>
    createMany?: SubscriptionCreateManyOfferInputEnvelope
    set?: Enumerable<SubscriptionWhereUniqueInput>
    disconnect?: Enumerable<SubscriptionWhereUniqueInput>
    delete?: Enumerable<SubscriptionWhereUniqueInput>
    connect?: Enumerable<SubscriptionWhereUniqueInput>
    update?: Enumerable<SubscriptionUpdateWithWhereUniqueWithoutOfferInput>
    updateMany?: Enumerable<SubscriptionUpdateManyWithWhereWithoutOfferInput>
    deleteMany?: Enumerable<SubscriptionScalarWhereInput>
  }

  export type BannerImageUncheckedUpdateManyWithoutOfferNestedInput = {
    create?: XOR<Enumerable<BannerImageCreateWithoutOfferInput>, Enumerable<BannerImageUncheckedCreateWithoutOfferInput>>
    connectOrCreate?: Enumerable<BannerImageCreateOrConnectWithoutOfferInput>
    upsert?: Enumerable<BannerImageUpsertWithWhereUniqueWithoutOfferInput>
    createMany?: BannerImageCreateManyOfferInputEnvelope
    set?: Enumerable<BannerImageWhereUniqueInput>
    disconnect?: Enumerable<BannerImageWhereUniqueInput>
    delete?: Enumerable<BannerImageWhereUniqueInput>
    connect?: Enumerable<BannerImageWhereUniqueInput>
    update?: Enumerable<BannerImageUpdateWithWhereUniqueWithoutOfferInput>
    updateMany?: Enumerable<BannerImageUpdateManyWithWhereWithoutOfferInput>
    deleteMany?: Enumerable<BannerImageScalarWhereInput>
  }

  export type TransactionUncheckedUpdateManyWithoutOfferNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutOfferInput>, Enumerable<TransactionUncheckedCreateWithoutOfferInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutOfferInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutOfferInput>
    createMany?: TransactionCreateManyOfferInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutOfferInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutOfferInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
  }

  export type OfferCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<OfferCreateWithoutSubscriptionInput, OfferUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: OfferCreateOrConnectWithoutSubscriptionInput
    connect?: OfferWhereUniqueInput
  }

  export type NullableEnumEnumPriceSubscriptionFieldUpdateOperationsInput = {
    set?: EnumPriceSubscription | null
    unset?: boolean
  }

  export type NullableEnumEnumStatusSubscriptionFieldUpdateOperationsInput = {
    set?: EnumStatusSubscription | null
    unset?: boolean
  }

  export type UserUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionInput
    upsert?: UserUpsertWithoutSubscriptionInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
  }

  export type OfferUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<OfferCreateWithoutSubscriptionInput, OfferUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: OfferCreateOrConnectWithoutSubscriptionInput
    upsert?: OfferUpsertWithoutSubscriptionInput
    connect?: OfferWhereUniqueInput
    update?: XOR<OfferUpdateWithoutSubscriptionInput, OfferUncheckedUpdateWithoutSubscriptionInput>
  }

  export type UserBoxCreateNestedOneWithoutGameInput = {
    create?: XOR<UserBoxCreateWithoutGameInput, UserBoxUncheckedCreateWithoutGameInput>
    connectOrCreate?: UserBoxCreateOrConnectWithoutGameInput
    connect?: UserBoxWhereUniqueInput
  }

  export type PatronageCreateNestedOneWithoutGameInput = {
    create?: XOR<PatronageCreateWithoutGameInput, PatronageUncheckedCreateWithoutGameInput>
    connectOrCreate?: PatronageCreateOrConnectWithoutGameInput
    connect?: PatronageWhereUniqueInput
  }

  export type ArticleCreateNestedOneWithoutGameInput = {
    create?: XOR<ArticleCreateWithoutGameInput, ArticleUncheckedCreateWithoutGameInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutGameInput
    connect?: ArticleWhereUniqueInput
  }

  export type ShoppingCartCreateNestedOneWithoutGameInput = {
    create?: XOR<ShoppingCartCreateWithoutGameInput, ShoppingCartUncheckedCreateWithoutGameInput>
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutGameInput
    connect?: ShoppingCartWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutGameInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutGameInput>, Enumerable<TransactionUncheckedCreateWithoutGameInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutGameInput>
    createMany?: TransactionCreateManyGameInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type ShoppingCartUncheckedCreateNestedOneWithoutGameInput = {
    create?: XOR<ShoppingCartCreateWithoutGameInput, ShoppingCartUncheckedCreateWithoutGameInput>
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutGameInput
    connect?: ShoppingCartWhereUniqueInput
  }

  export type TransactionUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutGameInput>, Enumerable<TransactionUncheckedCreateWithoutGameInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutGameInput>
    createMany?: TransactionCreateManyGameInputEnvelope
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type EnumEnumStatusGameFieldUpdateOperationsInput = {
    set?: EnumStatusGame
  }

  export type NullableEnumEnumVersionGameFieldUpdateOperationsInput = {
    set?: EnumVersionGame | null
    unset?: boolean
  }

  export type NullableEnumEnumTypeGameFieldUpdateOperationsInput = {
    set?: EnumTypeGame | null
    unset?: boolean
  }

  export type UserBoxUpdateOneWithoutGameNestedInput = {
    create?: XOR<UserBoxCreateWithoutGameInput, UserBoxUncheckedCreateWithoutGameInput>
    connectOrCreate?: UserBoxCreateOrConnectWithoutGameInput
    upsert?: UserBoxUpsertWithoutGameInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserBoxWhereUniqueInput
    update?: XOR<UserBoxUpdateWithoutGameInput, UserBoxUncheckedUpdateWithoutGameInput>
  }

  export type PatronageUpdateOneWithoutGameNestedInput = {
    create?: XOR<PatronageCreateWithoutGameInput, PatronageUncheckedCreateWithoutGameInput>
    connectOrCreate?: PatronageCreateOrConnectWithoutGameInput
    upsert?: PatronageUpsertWithoutGameInput
    disconnect?: boolean
    delete?: boolean
    connect?: PatronageWhereUniqueInput
    update?: XOR<PatronageUpdateWithoutGameInput, PatronageUncheckedUpdateWithoutGameInput>
  }

  export type ArticleUpdateOneWithoutGameNestedInput = {
    create?: XOR<ArticleCreateWithoutGameInput, ArticleUncheckedCreateWithoutGameInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutGameInput
    upsert?: ArticleUpsertWithoutGameInput
    disconnect?: boolean
    delete?: boolean
    connect?: ArticleWhereUniqueInput
    update?: XOR<ArticleUpdateWithoutGameInput, ArticleUncheckedUpdateWithoutGameInput>
  }

  export type ShoppingCartUpdateOneWithoutGameNestedInput = {
    create?: XOR<ShoppingCartCreateWithoutGameInput, ShoppingCartUncheckedCreateWithoutGameInput>
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutGameInput
    upsert?: ShoppingCartUpsertWithoutGameInput
    disconnect?: boolean
    delete?: boolean
    connect?: ShoppingCartWhereUniqueInput
    update?: XOR<ShoppingCartUpdateWithoutGameInput, ShoppingCartUncheckedUpdateWithoutGameInput>
  }

  export type TransactionUpdateManyWithoutGameNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutGameInput>, Enumerable<TransactionUncheckedCreateWithoutGameInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutGameInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutGameInput>
    createMany?: TransactionCreateManyGameInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutGameInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutGameInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type ShoppingCartUncheckedUpdateOneWithoutGameNestedInput = {
    create?: XOR<ShoppingCartCreateWithoutGameInput, ShoppingCartUncheckedCreateWithoutGameInput>
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutGameInput
    upsert?: ShoppingCartUpsertWithoutGameInput
    disconnect?: boolean
    delete?: boolean
    connect?: ShoppingCartWhereUniqueInput
    update?: XOR<ShoppingCartUpdateWithoutGameInput, ShoppingCartUncheckedUpdateWithoutGameInput>
  }

  export type TransactionUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutGameInput>, Enumerable<TransactionUncheckedCreateWithoutGameInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutGameInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutGameInput>
    createMany?: TransactionCreateManyGameInputEnvelope
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutGameInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutGameInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
    isSet?: boolean
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedEnumEnumGenderNullableFilter = {
    equals?: EnumGender | null
    in?: Enumerable<EnumGender> | null
    notIn?: Enumerable<EnumGender> | null
    not?: NestedEnumEnumGenderNullableFilter | EnumGender | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
    isSet?: boolean
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
    isSet?: boolean
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
    isSet?: boolean
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    isSet?: boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedEnumEnumGenderNullableWithAggregatesFilter = {
    equals?: EnumGender | null
    in?: Enumerable<EnumGender> | null
    notIn?: Enumerable<EnumGender> | null
    not?: NestedEnumEnumGenderNullableWithAggregatesFilter | EnumGender | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumEnumGenderNullableFilter
    _max?: NestedEnumEnumGenderNullableFilter
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    isSet?: boolean
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
    isSet?: boolean
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    isSet?: boolean
  }

  export type NestedEnumEnumStatusPatronageNullableFilter = {
    equals?: EnumStatusPatronage | null
    in?: Enumerable<EnumStatusPatronage> | null
    notIn?: Enumerable<EnumStatusPatronage> | null
    not?: NestedEnumEnumStatusPatronageNullableFilter | EnumStatusPatronage | null
    isSet?: boolean
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
    isSet?: boolean
  }

  export type NestedEnumEnumStatusPatronageNullableWithAggregatesFilter = {
    equals?: EnumStatusPatronage | null
    in?: Enumerable<EnumStatusPatronage> | null
    notIn?: Enumerable<EnumStatusPatronage> | null
    not?: NestedEnumEnumStatusPatronageNullableWithAggregatesFilter | EnumStatusPatronage | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumEnumStatusPatronageNullableFilter
    _max?: NestedEnumEnumStatusPatronageNullableFilter
    isSet?: boolean
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
    isSet?: boolean
  }

  export type NestedEnumEnumPermissionFilter = {
    equals?: EnumPermission
    in?: Enumerable<EnumPermission>
    notIn?: Enumerable<EnumPermission>
    not?: NestedEnumEnumPermissionFilter | EnumPermission
  }

  export type NestedEnumEnumPermissionWithAggregatesFilter = {
    equals?: EnumPermission
    in?: Enumerable<EnumPermission>
    notIn?: Enumerable<EnumPermission>
    not?: NestedEnumEnumPermissionWithAggregatesFilter | EnumPermission
    _count?: NestedIntFilter
    _min?: NestedEnumEnumPermissionFilter
    _max?: NestedEnumEnumPermissionFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedEnumEnumBadgeBoxNullableFilter = {
    equals?: EnumBadgeBox | null
    in?: Enumerable<EnumBadgeBox> | null
    notIn?: Enumerable<EnumBadgeBox> | null
    not?: NestedEnumEnumBadgeBoxNullableFilter | EnumBadgeBox | null
    isSet?: boolean
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedEnumEnumBadgeBoxNullableWithAggregatesFilter = {
    equals?: EnumBadgeBox | null
    in?: Enumerable<EnumBadgeBox> | null
    notIn?: Enumerable<EnumBadgeBox> | null
    not?: NestedEnumEnumBadgeBoxNullableWithAggregatesFilter | EnumBadgeBox | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumEnumBadgeBoxNullableFilter
    _max?: NestedEnumEnumBadgeBoxNullableFilter
    isSet?: boolean
  }

  export type NestedEnumEnumBoxImageStatusFilter = {
    equals?: EnumBoxImageStatus
    in?: Enumerable<EnumBoxImageStatus>
    notIn?: Enumerable<EnumBoxImageStatus>
    not?: NestedEnumEnumBoxImageStatusFilter | EnumBoxImageStatus
  }

  export type NestedEnumEnumBoxImageStatusWithAggregatesFilter = {
    equals?: EnumBoxImageStatus
    in?: Enumerable<EnumBoxImageStatus>
    notIn?: Enumerable<EnumBoxImageStatus>
    not?: NestedEnumEnumBoxImageStatusWithAggregatesFilter | EnumBoxImageStatus
    _count?: NestedIntFilter
    _min?: NestedEnumEnumBoxImageStatusFilter
    _max?: NestedEnumEnumBoxImageStatusFilter
  }

  export type NestedEnumEnumTypeModeNullableFilter = {
    equals?: EnumTypeMode | null
    in?: Enumerable<EnumTypeMode> | null
    notIn?: Enumerable<EnumTypeMode> | null
    not?: NestedEnumEnumTypeModeNullableFilter | EnumTypeMode | null
    isSet?: boolean
  }

  export type NestedEnumEnumTypeModeNullableWithAggregatesFilter = {
    equals?: EnumTypeMode | null
    in?: Enumerable<EnumTypeMode> | null
    notIn?: Enumerable<EnumTypeMode> | null
    not?: NestedEnumEnumTypeModeNullableWithAggregatesFilter | EnumTypeMode | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumEnumTypeModeNullableFilter
    _max?: NestedEnumEnumTypeModeNullableFilter
    isSet?: boolean
  }

  export type NestedEnumArticlePhotoStatusNullableFilter = {
    equals?: ArticlePhotoStatus | null
    in?: Enumerable<ArticlePhotoStatus> | null
    notIn?: Enumerable<ArticlePhotoStatus> | null
    not?: NestedEnumArticlePhotoStatusNullableFilter | ArticlePhotoStatus | null
    isSet?: boolean
  }

  export type NestedEnumArticlePhotoStatusNullableWithAggregatesFilter = {
    equals?: ArticlePhotoStatus | null
    in?: Enumerable<ArticlePhotoStatus> | null
    notIn?: Enumerable<ArticlePhotoStatus> | null
    not?: NestedEnumArticlePhotoStatusNullableWithAggregatesFilter | ArticlePhotoStatus | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumArticlePhotoStatusNullableFilter
    _max?: NestedEnumArticlePhotoStatusNullableFilter
    isSet?: boolean
  }

  export type NestedEnumEnumOrderStatusFilter = {
    equals?: EnumOrderStatus
    in?: Enumerable<EnumOrderStatus>
    notIn?: Enumerable<EnumOrderStatus>
    not?: NestedEnumEnumOrderStatusFilter | EnumOrderStatus
  }

  export type NestedEnumEnumOrderStatusWithAggregatesFilter = {
    equals?: EnumOrderStatus
    in?: Enumerable<EnumOrderStatus>
    notIn?: Enumerable<EnumOrderStatus>
    not?: NestedEnumEnumOrderStatusWithAggregatesFilter | EnumOrderStatus
    _count?: NestedIntFilter
    _min?: NestedEnumEnumOrderStatusFilter
    _max?: NestedEnumEnumOrderStatusFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedEnumEnumTypeTransactionFilter = {
    equals?: EnumTypeTransaction
    in?: Enumerable<EnumTypeTransaction>
    notIn?: Enumerable<EnumTypeTransaction>
    not?: NestedEnumEnumTypeTransactionFilter | EnumTypeTransaction
  }

  export type NestedEnumEnumStatusTransactionFilter = {
    equals?: EnumStatusTransaction
    in?: Enumerable<EnumStatusTransaction>
    notIn?: Enumerable<EnumStatusTransaction>
    not?: NestedEnumEnumStatusTransactionFilter | EnumStatusTransaction
  }

  export type NestedEnumEnumTypeTransactionWithAggregatesFilter = {
    equals?: EnumTypeTransaction
    in?: Enumerable<EnumTypeTransaction>
    notIn?: Enumerable<EnumTypeTransaction>
    not?: NestedEnumEnumTypeTransactionWithAggregatesFilter | EnumTypeTransaction
    _count?: NestedIntFilter
    _min?: NestedEnumEnumTypeTransactionFilter
    _max?: NestedEnumEnumTypeTransactionFilter
  }

  export type NestedEnumEnumStatusTransactionWithAggregatesFilter = {
    equals?: EnumStatusTransaction
    in?: Enumerable<EnumStatusTransaction>
    notIn?: Enumerable<EnumStatusTransaction>
    not?: NestedEnumEnumStatusTransactionWithAggregatesFilter | EnumStatusTransaction
    _count?: NestedIntFilter
    _min?: NestedEnumEnumStatusTransactionFilter
    _max?: NestedEnumEnumStatusTransactionFilter
  }

  export type NestedEnumEnumUserBoxTypeFilter = {
    equals?: EnumUserBoxType
    in?: Enumerable<EnumUserBoxType>
    notIn?: Enumerable<EnumUserBoxType>
    not?: NestedEnumEnumUserBoxTypeFilter | EnumUserBoxType
  }

  export type NestedEnumEnumUserBoxTypeWithAggregatesFilter = {
    equals?: EnumUserBoxType
    in?: Enumerable<EnumUserBoxType>
    notIn?: Enumerable<EnumUserBoxType>
    not?: NestedEnumEnumUserBoxTypeWithAggregatesFilter | EnumUserBoxType
    _count?: NestedIntFilter
    _min?: NestedEnumEnumUserBoxTypeFilter
    _max?: NestedEnumEnumUserBoxTypeFilter
  }

  export type NestedEnumBannerImageTypeNullableFilter = {
    equals?: BannerImageType | null
    in?: Enumerable<BannerImageType> | null
    notIn?: Enumerable<BannerImageType> | null
    not?: NestedEnumBannerImageTypeNullableFilter | BannerImageType | null
    isSet?: boolean
  }

  export type NestedEnumBannerImageTypeNullableWithAggregatesFilter = {
    equals?: BannerImageType | null
    in?: Enumerable<BannerImageType> | null
    notIn?: Enumerable<BannerImageType> | null
    not?: NestedEnumBannerImageTypeNullableWithAggregatesFilter | BannerImageType | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumBannerImageTypeNullableFilter
    _max?: NestedEnumBannerImageTypeNullableFilter
    isSet?: boolean
  }

  export type NestedEnumEnumHistoricalActionFilter = {
    equals?: EnumHistoricalAction
    in?: Enumerable<EnumHistoricalAction>
    notIn?: Enumerable<EnumHistoricalAction>
    not?: NestedEnumEnumHistoricalActionFilter | EnumHistoricalAction
  }

  export type NestedEnumEnumHistoricalActionWithAggregatesFilter = {
    equals?: EnumHistoricalAction
    in?: Enumerable<EnumHistoricalAction>
    notIn?: Enumerable<EnumHistoricalAction>
    not?: NestedEnumEnumHistoricalActionWithAggregatesFilter | EnumHistoricalAction
    _count?: NestedIntFilter
    _min?: NestedEnumEnumHistoricalActionFilter
    _max?: NestedEnumEnumHistoricalActionFilter
  }

  export type NestedEnumEnumPriceSubscriptionNullableFilter = {
    equals?: EnumPriceSubscription | null
    in?: Enumerable<EnumPriceSubscription> | null
    notIn?: Enumerable<EnumPriceSubscription> | null
    not?: NestedEnumEnumPriceSubscriptionNullableFilter | EnumPriceSubscription | null
    isSet?: boolean
  }

  export type NestedEnumEnumStatusSubscriptionNullableFilter = {
    equals?: EnumStatusSubscription | null
    in?: Enumerable<EnumStatusSubscription> | null
    notIn?: Enumerable<EnumStatusSubscription> | null
    not?: NestedEnumEnumStatusSubscriptionNullableFilter | EnumStatusSubscription | null
    isSet?: boolean
  }

  export type NestedEnumEnumPriceSubscriptionNullableWithAggregatesFilter = {
    equals?: EnumPriceSubscription | null
    in?: Enumerable<EnumPriceSubscription> | null
    notIn?: Enumerable<EnumPriceSubscription> | null
    not?: NestedEnumEnumPriceSubscriptionNullableWithAggregatesFilter | EnumPriceSubscription | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumEnumPriceSubscriptionNullableFilter
    _max?: NestedEnumEnumPriceSubscriptionNullableFilter
    isSet?: boolean
  }

  export type NestedEnumEnumStatusSubscriptionNullableWithAggregatesFilter = {
    equals?: EnumStatusSubscription | null
    in?: Enumerable<EnumStatusSubscription> | null
    notIn?: Enumerable<EnumStatusSubscription> | null
    not?: NestedEnumEnumStatusSubscriptionNullableWithAggregatesFilter | EnumStatusSubscription | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumEnumStatusSubscriptionNullableFilter
    _max?: NestedEnumEnumStatusSubscriptionNullableFilter
    isSet?: boolean
  }

  export type NestedEnumEnumStatusGameFilter = {
    equals?: EnumStatusGame
    in?: Enumerable<EnumStatusGame>
    notIn?: Enumerable<EnumStatusGame>
    not?: NestedEnumEnumStatusGameFilter | EnumStatusGame
  }

  export type NestedEnumEnumVersionGameNullableFilter = {
    equals?: EnumVersionGame | null
    in?: Enumerable<EnumVersionGame> | null
    notIn?: Enumerable<EnumVersionGame> | null
    not?: NestedEnumEnumVersionGameNullableFilter | EnumVersionGame | null
    isSet?: boolean
  }

  export type NestedEnumEnumTypeGameNullableFilter = {
    equals?: EnumTypeGame | null
    in?: Enumerable<EnumTypeGame> | null
    notIn?: Enumerable<EnumTypeGame> | null
    not?: NestedEnumEnumTypeGameNullableFilter | EnumTypeGame | null
    isSet?: boolean
  }

  export type NestedEnumEnumStatusGameWithAggregatesFilter = {
    equals?: EnumStatusGame
    in?: Enumerable<EnumStatusGame>
    notIn?: Enumerable<EnumStatusGame>
    not?: NestedEnumEnumStatusGameWithAggregatesFilter | EnumStatusGame
    _count?: NestedIntFilter
    _min?: NestedEnumEnumStatusGameFilter
    _max?: NestedEnumEnumStatusGameFilter
  }

  export type NestedEnumEnumVersionGameNullableWithAggregatesFilter = {
    equals?: EnumVersionGame | null
    in?: Enumerable<EnumVersionGame> | null
    notIn?: Enumerable<EnumVersionGame> | null
    not?: NestedEnumEnumVersionGameNullableWithAggregatesFilter | EnumVersionGame | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumEnumVersionGameNullableFilter
    _max?: NestedEnumEnumVersionGameNullableFilter
    isSet?: boolean
  }

  export type NestedEnumEnumTypeGameNullableWithAggregatesFilter = {
    equals?: EnumTypeGame | null
    in?: Enumerable<EnumTypeGame> | null
    notIn?: Enumerable<EnumTypeGame> | null
    not?: NestedEnumEnumTypeGameNullableWithAggregatesFilter | EnumTypeGame | null
    _count?: NestedIntNullableFilter
    _min?: NestedEnumEnumTypeGameNullableFilter
    _max?: NestedEnumEnumTypeGameNullableFilter
    isSet?: boolean
  }

  export type RuleCreateWithoutUserInput = {
    id?: string
    name: string
    keyword: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    permissions?: PermissionCreateNestedManyWithoutRulesInput
  }

  export type RuleUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    keyword: string
    permissionIDs?: RuleCreatepermissionIDsInput | Enumerable<string>
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    permissions?: PermissionUncheckedCreateNestedManyWithoutRulesInput
  }

  export type RuleCreateOrConnectWithoutUserInput = {
    where: RuleWhereUniqueInput
    create: XOR<RuleCreateWithoutUserInput, RuleUncheckedCreateWithoutUserInput>
  }

  export type AddressCreateWithoutUserInput = {
    id?: string
    firstAdress: string
    secondAdress?: string | null
    zipCode: string
    city: string
    region: string
    country: string
    additionnalInformation?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AddressUncheckedCreateWithoutUserInput = {
    id?: string
    firstAdress: string
    secondAdress?: string | null
    zipCode: string
    city: string
    region: string
    country: string
    additionnalInformation?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AddressCreateOrConnectWithoutUserInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
  }

  export type CodeConfirmLoginCreateWithoutUserInput = {
    id?: string
    uuid: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CodeConfirmLoginUncheckedCreateWithoutUserInput = {
    id?: string
    uuid: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CodeConfirmLoginCreateOrConnectWithoutUserInput = {
    where: CodeConfirmLoginWhereUniqueInput
    create: XOR<CodeConfirmLoginCreateWithoutUserInput, CodeConfirmLoginUncheckedCreateWithoutUserInput>
  }

  export type CodeConfirmLoginCreateManyUserInputEnvelope = {
    data: Enumerable<CodeConfirmLoginCreateManyUserInput>
  }

  export type CodeConfirmMailCreateWithoutUserInput = {
    id?: string
    uuid: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CodeConfirmMailUncheckedCreateWithoutUserInput = {
    id?: string
    uuid: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CodeConfirmMailCreateOrConnectWithoutUserInput = {
    where: CodeConfirmMailWhereUniqueInput
    create: XOR<CodeConfirmMailCreateWithoutUserInput, CodeConfirmMailUncheckedCreateWithoutUserInput>
  }

  export type CodeConfirmMailCreateManyUserInputEnvelope = {
    data: Enumerable<CodeConfirmMailCreateManyUserInput>
  }

  export type WalletCreateWithoutUserInput = {
    id?: string
    balance: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    transaction?: TransactionCreateNestedManyWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutUserInput = {
    id?: string
    balance: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    transaction?: TransactionUncheckedCreateNestedManyWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutUserInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
  }

  export type ShoppingCartCreateWithoutUserInput = {
    id?: string
    winningDate: Date | string
    isClaimed?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    game: GameCreateNestedOneWithoutShoppingCartInput
    transaction?: TransactionCreateNestedManyWithoutShoppingCartInput
    order?: OrderCreateNestedOneWithoutShoppingCartInput
  }

  export type ShoppingCartUncheckedCreateWithoutUserInput = {
    id?: string
    winningDate: Date | string
    isClaimed?: boolean | null
    gameId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    transaction?: TransactionUncheckedCreateNestedManyWithoutShoppingCartInput
    order?: OrderUncheckedCreateNestedOneWithoutShoppingCartInput
  }

  export type ShoppingCartCreateOrConnectWithoutUserInput = {
    where: ShoppingCartWhereUniqueInput
    create: XOR<ShoppingCartCreateWithoutUserInput, ShoppingCartUncheckedCreateWithoutUserInput>
  }

  export type ShoppingCartCreateManyUserInputEnvelope = {
    data: Enumerable<ShoppingCartCreateManyUserInput>
  }

  export type UserBoxCreateWithoutUserInput = {
    id?: string
    type: EnumUserBoxType
    duration?: Date | string | null
    dayNumber?: number | null
    isPlayed?: boolean | null
    isLocked?: boolean | null
    playedDate?: Date | string | null
    activationDate?: Date | string | null
    deactivationDate?: Date | string | null
    orderNumber?: number | null
    name?: string | null
    unlockThreshold?: number | null
    description?: string | null
    lot?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    box: BoxCreateNestedOneWithoutUserBoxInput
    game?: GameCreateNestedManyWithoutUserBoxInput
  }

  export type UserBoxUncheckedCreateWithoutUserInput = {
    id?: string
    type: EnumUserBoxType
    duration?: Date | string | null
    dayNumber?: number | null
    isPlayed?: boolean | null
    isLocked?: boolean | null
    playedDate?: Date | string | null
    activationDate?: Date | string | null
    deactivationDate?: Date | string | null
    orderNumber?: number | null
    name?: string | null
    unlockThreshold?: number | null
    description?: string | null
    boxId: string
    lot?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    game?: GameUncheckedCreateNestedManyWithoutUserBoxInput
  }

  export type UserBoxCreateOrConnectWithoutUserInput = {
    where: UserBoxWhereUniqueInput
    create: XOR<UserBoxCreateWithoutUserInput, UserBoxUncheckedCreateWithoutUserInput>
  }

  export type UserBoxCreateManyUserInputEnvelope = {
    data: Enumerable<UserBoxCreateManyUserInput>
  }

  export type HistoricalCreateWithoutUserInput = {
    id?: string
    date: Date | string
    description: string
    action: EnumHistoricalAction
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type HistoricalUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    description: string
    action: EnumHistoricalAction
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type HistoricalCreateOrConnectWithoutUserInput = {
    where: HistoricalWhereUniqueInput
    create: XOR<HistoricalCreateWithoutUserInput, HistoricalUncheckedCreateWithoutUserInput>
  }

  export type HistoricalCreateManyUserInputEnvelope = {
    data: Enumerable<HistoricalCreateManyUserInput>
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    message: string
    sendingDate: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    receiver?: ReceiverCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    message: string
    sendingDate: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    receiver?: ReceiverUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: Enumerable<MessageCreateManySenderInput>
  }

  export type ReceiverCreateWithoutReceiverInput = {
    id?: string
    readingDate: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    message: MessageCreateNestedOneWithoutReceiverInput
  }

  export type ReceiverUncheckedCreateWithoutReceiverInput = {
    id?: string
    readingDate: Date | string
    messageId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ReceiverCreateOrConnectWithoutReceiverInput = {
    where: ReceiverWhereUniqueInput
    create: XOR<ReceiverCreateWithoutReceiverInput, ReceiverUncheckedCreateWithoutReceiverInput>
  }

  export type ReceiverCreateManyReceiverInputEnvelope = {
    data: Enumerable<ReceiverCreateManyReceiverInput>
  }

  export type TemoignageCreateWithoutUserInput = {
    id?: string
    comment: string
    rating: number
    commentDate: Date | string
    isToShow?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TemoignageUncheckedCreateWithoutUserInput = {
    id?: string
    comment: string
    rating: number
    commentDate: Date | string
    isToShow?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TemoignageCreateOrConnectWithoutUserInput = {
    where: TemoignageWhereUniqueInput
    create: XOR<TemoignageCreateWithoutUserInput, TemoignageUncheckedCreateWithoutUserInput>
  }

  export type TemoignageCreateManyUserInputEnvelope = {
    data: Enumerable<TemoignageCreateManyUserInput>
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    durationType?: EnumPriceSubscription | null
    status?: EnumStatusSubscription | null
    autoRenewal?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    offer: OfferCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    durationType?: EnumPriceSubscription | null
    status?: EnumStatusSubscription | null
    autoRenewal?: boolean
    offerId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionCreateManyUserInputEnvelope = {
    data: Enumerable<SubscriptionCreateManyUserInput>
  }

  export type PatronageCreateWithoutUserParentInput = {
    id?: string
    gainPercentage?: number | null
    discountPercentage?: number | null
    status?: EnumStatusPatronage | null
    bonusEndDate?: Date | string | null
    bonusCollect?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    userChild: UserCreateNestedOneWithoutUserChildInput
    game?: GameCreateNestedManyWithoutPatronageInput
  }

  export type PatronageUncheckedCreateWithoutUserParentInput = {
    id?: string
    gainPercentage?: number | null
    discountPercentage?: number | null
    status?: EnumStatusPatronage | null
    bonusEndDate?: Date | string | null
    userChildId: string
    bonusCollect?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    game?: GameUncheckedCreateNestedManyWithoutPatronageInput
  }

  export type PatronageCreateOrConnectWithoutUserParentInput = {
    where: PatronageWhereUniqueInput
    create: XOR<PatronageCreateWithoutUserParentInput, PatronageUncheckedCreateWithoutUserParentInput>
  }

  export type PatronageCreateManyUserParentInputEnvelope = {
    data: Enumerable<PatronageCreateManyUserParentInput>
  }

  export type PatronageCreateWithoutUserChildInput = {
    id?: string
    gainPercentage?: number | null
    discountPercentage?: number | null
    status?: EnumStatusPatronage | null
    bonusEndDate?: Date | string | null
    bonusCollect?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    userParent: UserCreateNestedOneWithoutPatronageInput
    game?: GameCreateNestedManyWithoutPatronageInput
  }

  export type PatronageUncheckedCreateWithoutUserChildInput = {
    id?: string
    gainPercentage?: number | null
    discountPercentage?: number | null
    status?: EnumStatusPatronage | null
    bonusEndDate?: Date | string | null
    userParentId: string
    bonusCollect?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    game?: GameUncheckedCreateNestedManyWithoutPatronageInput
  }

  export type PatronageCreateOrConnectWithoutUserChildInput = {
    where: PatronageWhereUniqueInput
    create: XOR<PatronageCreateWithoutUserChildInput, PatronageUncheckedCreateWithoutUserChildInput>
  }

  export type RuleUpsertWithoutUserInput = {
    update: XOR<RuleUpdateWithoutUserInput, RuleUncheckedUpdateWithoutUserInput>
    create: XOR<RuleCreateWithoutUserInput, RuleUncheckedCreateWithoutUserInput>
  }

  export type RuleUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: PermissionUpdateManyWithoutRulesNestedInput
  }

  export type RuleUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    permissionIDs?: RuleUpdatepermissionIDsInput | Enumerable<string>
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: PermissionUncheckedUpdateManyWithoutRulesNestedInput
  }

  export type AddressUpsertWithoutUserInput = {
    update: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
  }

  export type AddressUpdateWithoutUserInput = {
    firstAdress?: StringFieldUpdateOperationsInput | string
    secondAdress?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    additionnalInformation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AddressUncheckedUpdateWithoutUserInput = {
    firstAdress?: StringFieldUpdateOperationsInput | string
    secondAdress?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    additionnalInformation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CodeConfirmLoginUpsertWithWhereUniqueWithoutUserInput = {
    where: CodeConfirmLoginWhereUniqueInput
    update: XOR<CodeConfirmLoginUpdateWithoutUserInput, CodeConfirmLoginUncheckedUpdateWithoutUserInput>
    create: XOR<CodeConfirmLoginCreateWithoutUserInput, CodeConfirmLoginUncheckedCreateWithoutUserInput>
  }

  export type CodeConfirmLoginUpdateWithWhereUniqueWithoutUserInput = {
    where: CodeConfirmLoginWhereUniqueInput
    data: XOR<CodeConfirmLoginUpdateWithoutUserInput, CodeConfirmLoginUncheckedUpdateWithoutUserInput>
  }

  export type CodeConfirmLoginUpdateManyWithWhereWithoutUserInput = {
    where: CodeConfirmLoginScalarWhereInput
    data: XOR<CodeConfirmLoginUpdateManyMutationInput, CodeConfirmLoginUncheckedUpdateManyWithoutCodeConfirmLoginInput>
  }

  export type CodeConfirmLoginScalarWhereInput = {
    AND?: Enumerable<CodeConfirmLoginScalarWhereInput>
    OR?: Enumerable<CodeConfirmLoginScalarWhereInput>
    NOT?: Enumerable<CodeConfirmLoginScalarWhereInput>
    id?: StringFilter | string
    uuid?: StringFilter | string
    useId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type CodeConfirmMailUpsertWithWhereUniqueWithoutUserInput = {
    where: CodeConfirmMailWhereUniqueInput
    update: XOR<CodeConfirmMailUpdateWithoutUserInput, CodeConfirmMailUncheckedUpdateWithoutUserInput>
    create: XOR<CodeConfirmMailCreateWithoutUserInput, CodeConfirmMailUncheckedCreateWithoutUserInput>
  }

  export type CodeConfirmMailUpdateWithWhereUniqueWithoutUserInput = {
    where: CodeConfirmMailWhereUniqueInput
    data: XOR<CodeConfirmMailUpdateWithoutUserInput, CodeConfirmMailUncheckedUpdateWithoutUserInput>
  }

  export type CodeConfirmMailUpdateManyWithWhereWithoutUserInput = {
    where: CodeConfirmMailScalarWhereInput
    data: XOR<CodeConfirmMailUpdateManyMutationInput, CodeConfirmMailUncheckedUpdateManyWithoutCodeConfirmMailInput>
  }

  export type CodeConfirmMailScalarWhereInput = {
    AND?: Enumerable<CodeConfirmMailScalarWhereInput>
    OR?: Enumerable<CodeConfirmMailScalarWhereInput>
    NOT?: Enumerable<CodeConfirmMailScalarWhereInput>
    id?: StringFilter | string
    uuid?: StringFilter | string
    useId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type WalletUpsertWithoutUserInput = {
    update: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
  }

  export type WalletUpdateWithoutUserInput = {
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction?: TransactionUpdateManyWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateWithoutUserInput = {
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction?: TransactionUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type ShoppingCartUpsertWithWhereUniqueWithoutUserInput = {
    where: ShoppingCartWhereUniqueInput
    update: XOR<ShoppingCartUpdateWithoutUserInput, ShoppingCartUncheckedUpdateWithoutUserInput>
    create: XOR<ShoppingCartCreateWithoutUserInput, ShoppingCartUncheckedCreateWithoutUserInput>
  }

  export type ShoppingCartUpdateWithWhereUniqueWithoutUserInput = {
    where: ShoppingCartWhereUniqueInput
    data: XOR<ShoppingCartUpdateWithoutUserInput, ShoppingCartUncheckedUpdateWithoutUserInput>
  }

  export type ShoppingCartUpdateManyWithWhereWithoutUserInput = {
    where: ShoppingCartScalarWhereInput
    data: XOR<ShoppingCartUpdateManyMutationInput, ShoppingCartUncheckedUpdateManyWithoutShoppingCartInput>
  }

  export type ShoppingCartScalarWhereInput = {
    AND?: Enumerable<ShoppingCartScalarWhereInput>
    OR?: Enumerable<ShoppingCartScalarWhereInput>
    NOT?: Enumerable<ShoppingCartScalarWhereInput>
    id?: StringFilter | string
    winningDate?: DateTimeFilter | Date | string
    isClaimed?: BoolNullableFilter | boolean | null
    gameId?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type UserBoxUpsertWithWhereUniqueWithoutUserInput = {
    where: UserBoxWhereUniqueInput
    update: XOR<UserBoxUpdateWithoutUserInput, UserBoxUncheckedUpdateWithoutUserInput>
    create: XOR<UserBoxCreateWithoutUserInput, UserBoxUncheckedCreateWithoutUserInput>
  }

  export type UserBoxUpdateWithWhereUniqueWithoutUserInput = {
    where: UserBoxWhereUniqueInput
    data: XOR<UserBoxUpdateWithoutUserInput, UserBoxUncheckedUpdateWithoutUserInput>
  }

  export type UserBoxUpdateManyWithWhereWithoutUserInput = {
    where: UserBoxScalarWhereInput
    data: XOR<UserBoxUpdateManyMutationInput, UserBoxUncheckedUpdateManyWithoutUserBoxInput>
  }

  export type UserBoxScalarWhereInput = {
    AND?: Enumerable<UserBoxScalarWhereInput>
    OR?: Enumerable<UserBoxScalarWhereInput>
    NOT?: Enumerable<UserBoxScalarWhereInput>
    id?: StringFilter | string
    type?: EnumEnumUserBoxTypeFilter | EnumUserBoxType
    duration?: DateTimeNullableFilter | Date | string | null
    dayNumber?: IntNullableFilter | number | null
    isPlayed?: BoolNullableFilter | boolean | null
    isLocked?: BoolNullableFilter | boolean | null
    playedDate?: DateTimeNullableFilter | Date | string | null
    activationDate?: DateTimeNullableFilter | Date | string | null
    deactivationDate?: DateTimeNullableFilter | Date | string | null
    orderNumber?: IntNullableFilter | number | null
    name?: StringNullableFilter | string | null
    unlockThreshold?: FloatNullableFilter | number | null
    description?: StringNullableFilter | string | null
    userId?: StringFilter | string
    boxId?: StringFilter | string
    lot?: IntNullableFilter | number | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type HistoricalUpsertWithWhereUniqueWithoutUserInput = {
    where: HistoricalWhereUniqueInput
    update: XOR<HistoricalUpdateWithoutUserInput, HistoricalUncheckedUpdateWithoutUserInput>
    create: XOR<HistoricalCreateWithoutUserInput, HistoricalUncheckedCreateWithoutUserInput>
  }

  export type HistoricalUpdateWithWhereUniqueWithoutUserInput = {
    where: HistoricalWhereUniqueInput
    data: XOR<HistoricalUpdateWithoutUserInput, HistoricalUncheckedUpdateWithoutUserInput>
  }

  export type HistoricalUpdateManyWithWhereWithoutUserInput = {
    where: HistoricalScalarWhereInput
    data: XOR<HistoricalUpdateManyMutationInput, HistoricalUncheckedUpdateManyWithoutHistoricalInput>
  }

  export type HistoricalScalarWhereInput = {
    AND?: Enumerable<HistoricalScalarWhereInput>
    OR?: Enumerable<HistoricalScalarWhereInput>
    NOT?: Enumerable<HistoricalScalarWhereInput>
    id?: StringFilter | string
    date?: DateTimeFilter | Date | string
    description?: StringFilter | string
    userId?: StringFilter | string
    action?: EnumEnumHistoricalActionFilter | EnumHistoricalAction
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageScalarWhereInput = {
    AND?: Enumerable<MessageScalarWhereInput>
    OR?: Enumerable<MessageScalarWhereInput>
    NOT?: Enumerable<MessageScalarWhereInput>
    id?: StringFilter | string
    message?: StringFilter | string
    sendingDate?: DateTimeFilter | Date | string
    senderId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ReceiverUpsertWithWhereUniqueWithoutReceiverInput = {
    where: ReceiverWhereUniqueInput
    update: XOR<ReceiverUpdateWithoutReceiverInput, ReceiverUncheckedUpdateWithoutReceiverInput>
    create: XOR<ReceiverCreateWithoutReceiverInput, ReceiverUncheckedCreateWithoutReceiverInput>
  }

  export type ReceiverUpdateWithWhereUniqueWithoutReceiverInput = {
    where: ReceiverWhereUniqueInput
    data: XOR<ReceiverUpdateWithoutReceiverInput, ReceiverUncheckedUpdateWithoutReceiverInput>
  }

  export type ReceiverUpdateManyWithWhereWithoutReceiverInput = {
    where: ReceiverScalarWhereInput
    data: XOR<ReceiverUpdateManyMutationInput, ReceiverUncheckedUpdateManyWithoutReceiverInput>
  }

  export type ReceiverScalarWhereInput = {
    AND?: Enumerable<ReceiverScalarWhereInput>
    OR?: Enumerable<ReceiverScalarWhereInput>
    NOT?: Enumerable<ReceiverScalarWhereInput>
    id?: StringFilter | string
    readingDate?: DateTimeFilter | Date | string
    receiverId?: StringFilter | string
    messageId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type TemoignageUpsertWithWhereUniqueWithoutUserInput = {
    where: TemoignageWhereUniqueInput
    update: XOR<TemoignageUpdateWithoutUserInput, TemoignageUncheckedUpdateWithoutUserInput>
    create: XOR<TemoignageCreateWithoutUserInput, TemoignageUncheckedCreateWithoutUserInput>
  }

  export type TemoignageUpdateWithWhereUniqueWithoutUserInput = {
    where: TemoignageWhereUniqueInput
    data: XOR<TemoignageUpdateWithoutUserInput, TemoignageUncheckedUpdateWithoutUserInput>
  }

  export type TemoignageUpdateManyWithWhereWithoutUserInput = {
    where: TemoignageScalarWhereInput
    data: XOR<TemoignageUpdateManyMutationInput, TemoignageUncheckedUpdateManyWithoutTemoignageInput>
  }

  export type TemoignageScalarWhereInput = {
    AND?: Enumerable<TemoignageScalarWhereInput>
    OR?: Enumerable<TemoignageScalarWhereInput>
    NOT?: Enumerable<TemoignageScalarWhereInput>
    id?: StringFilter | string
    comment?: StringFilter | string
    rating?: IntFilter | number
    commentDate?: DateTimeFilter | Date | string
    isToShow?: BoolFilter | boolean
    userId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: Enumerable<SubscriptionScalarWhereInput>
    OR?: Enumerable<SubscriptionScalarWhereInput>
    NOT?: Enumerable<SubscriptionScalarWhereInput>
    id?: StringFilter | string
    startDate?: DateTimeFilter | Date | string
    endDate?: DateTimeFilter | Date | string
    durationType?: EnumEnumPriceSubscriptionNullableFilter | EnumPriceSubscription | null
    status?: EnumEnumStatusSubscriptionNullableFilter | EnumStatusSubscription | null
    autoRenewal?: BoolFilter | boolean
    userId?: StringFilter | string
    offerId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type PatronageUpsertWithWhereUniqueWithoutUserParentInput = {
    where: PatronageWhereUniqueInput
    update: XOR<PatronageUpdateWithoutUserParentInput, PatronageUncheckedUpdateWithoutUserParentInput>
    create: XOR<PatronageCreateWithoutUserParentInput, PatronageUncheckedCreateWithoutUserParentInput>
  }

  export type PatronageUpdateWithWhereUniqueWithoutUserParentInput = {
    where: PatronageWhereUniqueInput
    data: XOR<PatronageUpdateWithoutUserParentInput, PatronageUncheckedUpdateWithoutUserParentInput>
  }

  export type PatronageUpdateManyWithWhereWithoutUserParentInput = {
    where: PatronageScalarWhereInput
    data: XOR<PatronageUpdateManyMutationInput, PatronageUncheckedUpdateManyWithoutPatronageInput>
  }

  export type PatronageScalarWhereInput = {
    AND?: Enumerable<PatronageScalarWhereInput>
    OR?: Enumerable<PatronageScalarWhereInput>
    NOT?: Enumerable<PatronageScalarWhereInput>
    id?: StringFilter | string
    gainPercentage?: FloatNullableFilter | number | null
    discountPercentage?: FloatNullableFilter | number | null
    status?: EnumEnumStatusPatronageNullableFilter | EnumStatusPatronage | null
    bonusEndDate?: DateTimeNullableFilter | Date | string | null
    userParentId?: StringFilter | string
    userChildId?: StringFilter | string
    bonusCollect?: BoolNullableFilter | boolean | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type PatronageUpsertWithoutUserChildInput = {
    update: XOR<PatronageUpdateWithoutUserChildInput, PatronageUncheckedUpdateWithoutUserChildInput>
    create: XOR<PatronageCreateWithoutUserChildInput, PatronageUncheckedCreateWithoutUserChildInput>
  }

  export type PatronageUpdateWithoutUserChildInput = {
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumEnumStatusPatronageFieldUpdateOperationsInput | EnumStatusPatronage | null
    bonusEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bonusCollect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userParent?: UserUpdateOneRequiredWithoutPatronageNestedInput
    game?: GameUpdateManyWithoutPatronageNestedInput
  }

  export type PatronageUncheckedUpdateWithoutUserChildInput = {
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumEnumStatusPatronageFieldUpdateOperationsInput | EnumStatusPatronage | null
    bonusEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userParentId?: StringFieldUpdateOperationsInput | string
    bonusCollect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    game?: GameUncheckedUpdateManyWithoutPatronageNestedInput
  }

  export type UserCreateWithoutPatronageInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeCustomerId?: string | null
    rule?: RuleCreateNestedOneWithoutUserInput
    address?: AddressCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartCreateNestedManyWithoutUserInput
    userBox?: UserBoxCreateNestedManyWithoutUserInput
    historical?: HistoricalCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    receiver?: ReceiverCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedManyWithoutUserInput
    userChild?: PatronageCreateNestedOneWithoutUserChildInput
  }

  export type UserUncheckedCreateWithoutPatronageInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ruleId?: string | null
    stripeCustomerId?: string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUserInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutUserInput
    historical?: HistoricalUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receiver?: ReceiverUncheckedCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    userChild?: PatronageUncheckedCreateNestedOneWithoutUserChildInput
  }

  export type UserCreateOrConnectWithoutPatronageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPatronageInput, UserUncheckedCreateWithoutPatronageInput>
  }

  export type UserCreateWithoutUserChildInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeCustomerId?: string | null
    rule?: RuleCreateNestedOneWithoutUserInput
    address?: AddressCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartCreateNestedManyWithoutUserInput
    userBox?: UserBoxCreateNestedManyWithoutUserInput
    historical?: HistoricalCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    receiver?: ReceiverCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedManyWithoutUserInput
    patronage?: PatronageCreateNestedManyWithoutUserParentInput
  }

  export type UserUncheckedCreateWithoutUserChildInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ruleId?: string | null
    stripeCustomerId?: string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUserInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutUserInput
    historical?: HistoricalUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receiver?: ReceiverUncheckedCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    patronage?: PatronageUncheckedCreateNestedManyWithoutUserParentInput
  }

  export type UserCreateOrConnectWithoutUserChildInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserChildInput, UserUncheckedCreateWithoutUserChildInput>
  }

  export type GameCreateWithoutPatronageInput = {
    id?: string
    reference: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: EnumStatusGame
    version?: EnumVersionGame | null
    type?: EnumTypeGame | null
    gainPercentage?: number | null
    gainDraw?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    userBox?: UserBoxCreateNestedOneWithoutGameInput
    article?: ArticleCreateNestedOneWithoutGameInput
    shoppingCart?: ShoppingCartCreateNestedOneWithoutGameInput
    transaction?: TransactionCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutPatronageInput = {
    id?: string
    reference: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: EnumStatusGame
    version?: EnumVersionGame | null
    type?: EnumTypeGame | null
    userBoxId?: string | null
    gainPercentage?: number | null
    gainDraw?: number | null
    articleId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    shoppingCart?: ShoppingCartUncheckedCreateNestedOneWithoutGameInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutPatronageInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutPatronageInput, GameUncheckedCreateWithoutPatronageInput>
  }

  export type GameCreateManyPatronageInputEnvelope = {
    data: Enumerable<GameCreateManyPatronageInput>
  }

  export type UserUpsertWithoutPatronageInput = {
    update: XOR<UserUpdateWithoutPatronageInput, UserUncheckedUpdateWithoutPatronageInput>
    create: XOR<UserCreateWithoutPatronageInput, UserUncheckedCreateWithoutPatronageInput>
  }

  export type UserUpdateWithoutPatronageInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    rule?: RuleUpdateOneWithoutUserNestedInput
    address?: AddressUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUpdateManyWithoutUserNestedInput
    historical?: HistoricalUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    userChild?: PatronageUpdateOneWithoutUserChildNestedInput
  }

  export type UserUncheckedUpdateWithoutPatronageInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ruleId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutUserNestedInput
    historical?: HistoricalUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUncheckedUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    userChild?: PatronageUncheckedUpdateOneWithoutUserChildNestedInput
  }

  export type UserUpsertWithoutUserChildInput = {
    update: XOR<UserUpdateWithoutUserChildInput, UserUncheckedUpdateWithoutUserChildInput>
    create: XOR<UserCreateWithoutUserChildInput, UserUncheckedCreateWithoutUserChildInput>
  }

  export type UserUpdateWithoutUserChildInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    rule?: RuleUpdateOneWithoutUserNestedInput
    address?: AddressUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUpdateManyWithoutUserNestedInput
    historical?: HistoricalUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    patronage?: PatronageUpdateManyWithoutUserParentNestedInput
  }

  export type UserUncheckedUpdateWithoutUserChildInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ruleId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutUserNestedInput
    historical?: HistoricalUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUncheckedUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    patronage?: PatronageUncheckedUpdateManyWithoutUserParentNestedInput
  }

  export type GameUpsertWithWhereUniqueWithoutPatronageInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutPatronageInput, GameUncheckedUpdateWithoutPatronageInput>
    create: XOR<GameCreateWithoutPatronageInput, GameUncheckedCreateWithoutPatronageInput>
  }

  export type GameUpdateWithWhereUniqueWithoutPatronageInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutPatronageInput, GameUncheckedUpdateWithoutPatronageInput>
  }

  export type GameUpdateManyWithWhereWithoutPatronageInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutGameInput>
  }

  export type GameScalarWhereInput = {
    AND?: Enumerable<GameScalarWhereInput>
    OR?: Enumerable<GameScalarWhereInput>
    NOT?: Enumerable<GameScalarWhereInput>
    id?: StringFilter | string
    reference?: StringFilter | string
    startDate?: DateTimeFilter | Date | string
    endDate?: DateTimeNullableFilter | Date | string | null
    status?: EnumEnumStatusGameFilter | EnumStatusGame
    version?: EnumEnumVersionGameNullableFilter | EnumVersionGame | null
    type?: EnumEnumTypeGameNullableFilter | EnumTypeGame | null
    userBoxId?: StringNullableFilter | string | null
    patronageId?: StringNullableFilter | string | null
    gainPercentage?: FloatNullableFilter | number | null
    gainDraw?: FloatNullableFilter | number | null
    articleId?: StringNullableFilter | string | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type UserCreateWithoutCodeConfirmLoginInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeCustomerId?: string | null
    rule?: RuleCreateNestedOneWithoutUserInput
    address?: AddressCreateNestedOneWithoutUserInput
    codeConfirmMail?: CodeConfirmMailCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartCreateNestedManyWithoutUserInput
    userBox?: UserBoxCreateNestedManyWithoutUserInput
    historical?: HistoricalCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    receiver?: ReceiverCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedManyWithoutUserInput
    patronage?: PatronageCreateNestedManyWithoutUserParentInput
    userChild?: PatronageCreateNestedOneWithoutUserChildInput
  }

  export type UserUncheckedCreateWithoutCodeConfirmLoginInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ruleId?: string | null
    stripeCustomerId?: string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    codeConfirmMail?: CodeConfirmMailUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUserInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutUserInput
    historical?: HistoricalUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receiver?: ReceiverUncheckedCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    patronage?: PatronageUncheckedCreateNestedManyWithoutUserParentInput
    userChild?: PatronageUncheckedCreateNestedOneWithoutUserChildInput
  }

  export type UserCreateOrConnectWithoutCodeConfirmLoginInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCodeConfirmLoginInput, UserUncheckedCreateWithoutCodeConfirmLoginInput>
  }

  export type UserUpsertWithoutCodeConfirmLoginInput = {
    update: XOR<UserUpdateWithoutCodeConfirmLoginInput, UserUncheckedUpdateWithoutCodeConfirmLoginInput>
    create: XOR<UserCreateWithoutCodeConfirmLoginInput, UserUncheckedCreateWithoutCodeConfirmLoginInput>
  }

  export type UserUpdateWithoutCodeConfirmLoginInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    rule?: RuleUpdateOneWithoutUserNestedInput
    address?: AddressUpdateOneWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUpdateManyWithoutUserNestedInput
    historical?: HistoricalUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    patronage?: PatronageUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUpdateOneWithoutUserChildNestedInput
  }

  export type UserUncheckedUpdateWithoutCodeConfirmLoginInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ruleId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutUserNestedInput
    historical?: HistoricalUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUncheckedUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    patronage?: PatronageUncheckedUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUncheckedUpdateOneWithoutUserChildNestedInput
  }

  export type UserCreateWithoutCodeConfirmMailInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeCustomerId?: string | null
    rule?: RuleCreateNestedOneWithoutUserInput
    address?: AddressCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartCreateNestedManyWithoutUserInput
    userBox?: UserBoxCreateNestedManyWithoutUserInput
    historical?: HistoricalCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    receiver?: ReceiverCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedManyWithoutUserInput
    patronage?: PatronageCreateNestedManyWithoutUserParentInput
    userChild?: PatronageCreateNestedOneWithoutUserChildInput
  }

  export type UserUncheckedCreateWithoutCodeConfirmMailInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ruleId?: string | null
    stripeCustomerId?: string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUserInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutUserInput
    historical?: HistoricalUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receiver?: ReceiverUncheckedCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    patronage?: PatronageUncheckedCreateNestedManyWithoutUserParentInput
    userChild?: PatronageUncheckedCreateNestedOneWithoutUserChildInput
  }

  export type UserCreateOrConnectWithoutCodeConfirmMailInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCodeConfirmMailInput, UserUncheckedCreateWithoutCodeConfirmMailInput>
  }

  export type UserUpsertWithoutCodeConfirmMailInput = {
    update: XOR<UserUpdateWithoutCodeConfirmMailInput, UserUncheckedUpdateWithoutCodeConfirmMailInput>
    create: XOR<UserCreateWithoutCodeConfirmMailInput, UserUncheckedCreateWithoutCodeConfirmMailInput>
  }

  export type UserUpdateWithoutCodeConfirmMailInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    rule?: RuleUpdateOneWithoutUserNestedInput
    address?: AddressUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUpdateManyWithoutUserNestedInput
    historical?: HistoricalUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    patronage?: PatronageUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUpdateOneWithoutUserChildNestedInput
  }

  export type UserUncheckedUpdateWithoutCodeConfirmMailInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ruleId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutUserNestedInput
    historical?: HistoricalUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUncheckedUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    patronage?: PatronageUncheckedUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUncheckedUpdateOneWithoutUserChildNestedInput
  }

  export type UserCreateWithoutRuleInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeCustomerId?: string | null
    address?: AddressCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartCreateNestedManyWithoutUserInput
    userBox?: UserBoxCreateNestedManyWithoutUserInput
    historical?: HistoricalCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    receiver?: ReceiverCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedManyWithoutUserInput
    patronage?: PatronageCreateNestedManyWithoutUserParentInput
    userChild?: PatronageCreateNestedOneWithoutUserChildInput
  }

  export type UserUncheckedCreateWithoutRuleInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeCustomerId?: string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUserInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutUserInput
    historical?: HistoricalUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receiver?: ReceiverUncheckedCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    patronage?: PatronageUncheckedCreateNestedManyWithoutUserParentInput
    userChild?: PatronageUncheckedCreateNestedOneWithoutUserChildInput
  }

  export type UserCreateOrConnectWithoutRuleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRuleInput, UserUncheckedCreateWithoutRuleInput>
  }

  export type UserCreateManyRuleInputEnvelope = {
    data: Enumerable<UserCreateManyRuleInput>
  }

  export type PermissionCreateWithoutRulesInput = {
    id?: string
    name: EnumPermission
    keyword: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    models?: ModelCreateNestedManyWithoutPermissionsInput
  }

  export type PermissionUncheckedCreateWithoutRulesInput = {
    id?: string
    name: EnumPermission
    keyword: string
    rulesIDs?: PermissionCreaterulesIDsInput | Enumerable<string>
    modelsIDs?: PermissionCreatemodelsIDsInput | Enumerable<string>
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    models?: ModelUncheckedCreateNestedManyWithoutPermissionsInput
  }

  export type PermissionCreateOrConnectWithoutRulesInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRulesInput, PermissionUncheckedCreateWithoutRulesInput>
  }

  export type UserUpsertWithWhereUniqueWithoutRuleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRuleInput, UserUncheckedUpdateWithoutRuleInput>
    create: XOR<UserCreateWithoutRuleInput, UserUncheckedCreateWithoutRuleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRuleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRuleInput, UserUncheckedUpdateWithoutRuleInput>
  }

  export type UserUpdateManyWithWhereWithoutRuleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUserInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringNullableFilter | string | null
    username?: StringFilter | string
    photoUrl?: StringNullableFilter | string | null
    email?: StringFilter | string
    isActif?: BoolFilter | boolean
    isMember?: BoolFilter | boolean
    isAdmin?: BoolFilter | boolean
    emailIsVerified?: BoolFilter | boolean
    twoAuthIsActive?: BoolFilter | boolean
    phone?: StringNullableFilter | string | null
    gender?: EnumEnumGenderNullableFilter | EnumGender | null
    birthDate?: DateTimeNullableFilter | Date | string | null
    password?: StringFilter | string
    socketId?: StringNullableFilter | string | null
    refreshToken?: StringNullableFilter | string | null
    supportingDocumentUrl?: StringNullableFilter | string | null
    isValideSupportingDocument?: BoolFilter | boolean
    registrationBonus?: FloatNullableFilter | number | null
    latestConnectedDate?: DateTimeNullableFilter | Date | string | null
    signInCount?: IntNullableFilter | number | null
    lotCount?: IntNullableFilter | number | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    ruleId?: StringNullableFilter | string | null
    stripeCustomerId?: StringNullableFilter | string | null
  }

  export type PermissionUpsertWithWhereUniqueWithoutRulesInput = {
    where: PermissionWhereUniqueInput
    update: XOR<PermissionUpdateWithoutRulesInput, PermissionUncheckedUpdateWithoutRulesInput>
    create: XOR<PermissionCreateWithoutRulesInput, PermissionUncheckedCreateWithoutRulesInput>
  }

  export type PermissionUpdateWithWhereUniqueWithoutRulesInput = {
    where: PermissionWhereUniqueInput
    data: XOR<PermissionUpdateWithoutRulesInput, PermissionUncheckedUpdateWithoutRulesInput>
  }

  export type PermissionUpdateManyWithWhereWithoutRulesInput = {
    where: PermissionScalarWhereInput
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyWithoutPermissionsInput>
  }

  export type PermissionScalarWhereInput = {
    AND?: Enumerable<PermissionScalarWhereInput>
    OR?: Enumerable<PermissionScalarWhereInput>
    NOT?: Enumerable<PermissionScalarWhereInput>
    id?: StringFilter | string
    name?: EnumEnumPermissionFilter | EnumPermission
    keyword?: StringFilter | string
    rulesIDs?: StringNullableListFilter
    modelsIDs?: StringNullableListFilter
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type RuleCreateWithoutPermissionsInput = {
    id?: string
    name: string
    keyword: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user?: UserCreateNestedManyWithoutRuleInput
  }

  export type RuleUncheckedCreateWithoutPermissionsInput = {
    id?: string
    name: string
    keyword: string
    permissionIDs?: RuleCreatepermissionIDsInput | Enumerable<string>
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user?: UserUncheckedCreateNestedManyWithoutRuleInput
  }

  export type RuleCreateOrConnectWithoutPermissionsInput = {
    where: RuleWhereUniqueInput
    create: XOR<RuleCreateWithoutPermissionsInput, RuleUncheckedCreateWithoutPermissionsInput>
  }

  export type ModelCreateWithoutPermissionsInput = {
    id?: string
    name: string
    keyword: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelUncheckedCreateWithoutPermissionsInput = {
    id?: string
    name: string
    keyword: string
    permissionIDs?: ModelCreatepermissionIDsInput | Enumerable<string>
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ModelCreateOrConnectWithoutPermissionsInput = {
    where: ModelWhereUniqueInput
    create: XOR<ModelCreateWithoutPermissionsInput, ModelUncheckedCreateWithoutPermissionsInput>
  }

  export type RuleUpsertWithWhereUniqueWithoutPermissionsInput = {
    where: RuleWhereUniqueInput
    update: XOR<RuleUpdateWithoutPermissionsInput, RuleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RuleCreateWithoutPermissionsInput, RuleUncheckedCreateWithoutPermissionsInput>
  }

  export type RuleUpdateWithWhereUniqueWithoutPermissionsInput = {
    where: RuleWhereUniqueInput
    data: XOR<RuleUpdateWithoutPermissionsInput, RuleUncheckedUpdateWithoutPermissionsInput>
  }

  export type RuleUpdateManyWithWhereWithoutPermissionsInput = {
    where: RuleScalarWhereInput
    data: XOR<RuleUpdateManyMutationInput, RuleUncheckedUpdateManyWithoutRulesInput>
  }

  export type RuleScalarWhereInput = {
    AND?: Enumerable<RuleScalarWhereInput>
    OR?: Enumerable<RuleScalarWhereInput>
    NOT?: Enumerable<RuleScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    keyword?: StringFilter | string
    permissionIDs?: StringNullableListFilter
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ModelUpsertWithWhereUniqueWithoutPermissionsInput = {
    where: ModelWhereUniqueInput
    update: XOR<ModelUpdateWithoutPermissionsInput, ModelUncheckedUpdateWithoutPermissionsInput>
    create: XOR<ModelCreateWithoutPermissionsInput, ModelUncheckedCreateWithoutPermissionsInput>
  }

  export type ModelUpdateWithWhereUniqueWithoutPermissionsInput = {
    where: ModelWhereUniqueInput
    data: XOR<ModelUpdateWithoutPermissionsInput, ModelUncheckedUpdateWithoutPermissionsInput>
  }

  export type ModelUpdateManyWithWhereWithoutPermissionsInput = {
    where: ModelScalarWhereInput
    data: XOR<ModelUpdateManyMutationInput, ModelUncheckedUpdateManyWithoutModelsInput>
  }

  export type ModelScalarWhereInput = {
    AND?: Enumerable<ModelScalarWhereInput>
    OR?: Enumerable<ModelScalarWhereInput>
    NOT?: Enumerable<ModelScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    keyword?: StringFilter | string
    permissionIDs?: StringNullableListFilter
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type PermissionCreateWithoutModelsInput = {
    id?: string
    name: EnumPermission
    keyword: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    rules?: RuleCreateNestedManyWithoutPermissionsInput
  }

  export type PermissionUncheckedCreateWithoutModelsInput = {
    id?: string
    name: EnumPermission
    keyword: string
    rulesIDs?: PermissionCreaterulesIDsInput | Enumerable<string>
    modelsIDs?: PermissionCreatemodelsIDsInput | Enumerable<string>
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    rules?: RuleUncheckedCreateNestedManyWithoutPermissionsInput
  }

  export type PermissionCreateOrConnectWithoutModelsInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutModelsInput, PermissionUncheckedCreateWithoutModelsInput>
  }

  export type PermissionUpsertWithWhereUniqueWithoutModelsInput = {
    where: PermissionWhereUniqueInput
    update: XOR<PermissionUpdateWithoutModelsInput, PermissionUncheckedUpdateWithoutModelsInput>
    create: XOR<PermissionCreateWithoutModelsInput, PermissionUncheckedCreateWithoutModelsInput>
  }

  export type PermissionUpdateWithWhereUniqueWithoutModelsInput = {
    where: PermissionWhereUniqueInput
    data: XOR<PermissionUpdateWithoutModelsInput, PermissionUncheckedUpdateWithoutModelsInput>
  }

  export type PermissionUpdateManyWithWhereWithoutModelsInput = {
    where: PermissionScalarWhereInput
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyWithoutPermissionsInput>
  }

  export type UserCreateWithoutAddressInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeCustomerId?: string | null
    rule?: RuleCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartCreateNestedManyWithoutUserInput
    userBox?: UserBoxCreateNestedManyWithoutUserInput
    historical?: HistoricalCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    receiver?: ReceiverCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedManyWithoutUserInput
    patronage?: PatronageCreateNestedManyWithoutUserParentInput
    userChild?: PatronageCreateNestedOneWithoutUserChildInput
  }

  export type UserUncheckedCreateWithoutAddressInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ruleId?: string | null
    stripeCustomerId?: string | null
    codeConfirmLogin?: CodeConfirmLoginUncheckedCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUserInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutUserInput
    historical?: HistoricalUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receiver?: ReceiverUncheckedCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    patronage?: PatronageUncheckedCreateNestedManyWithoutUserParentInput
    userChild?: PatronageUncheckedCreateNestedOneWithoutUserChildInput
  }

  export type UserCreateOrConnectWithoutAddressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
  }

  export type UserUpsertWithoutAddressInput = {
    update: XOR<UserUpdateWithoutAddressInput, UserUncheckedUpdateWithoutAddressInput>
    create: XOR<UserCreateWithoutAddressInput, UserUncheckedCreateWithoutAddressInput>
  }

  export type UserUpdateWithoutAddressInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    rule?: RuleUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUpdateManyWithoutUserNestedInput
    historical?: HistoricalUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    patronage?: PatronageUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUpdateOneWithoutUserChildNestedInput
  }

  export type UserUncheckedUpdateWithoutAddressInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ruleId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    codeConfirmLogin?: CodeConfirmLoginUncheckedUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutUserNestedInput
    historical?: HistoricalUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUncheckedUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    patronage?: PatronageUncheckedUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUncheckedUpdateOneWithoutUserChildNestedInput
  }

  export type UserCreateWithoutWalletInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeCustomerId?: string | null
    rule?: RuleCreateNestedOneWithoutUserInput
    address?: AddressCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailCreateNestedManyWithoutUserInput
    shoppingCart?: ShoppingCartCreateNestedManyWithoutUserInput
    userBox?: UserBoxCreateNestedManyWithoutUserInput
    historical?: HistoricalCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    receiver?: ReceiverCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedManyWithoutUserInput
    patronage?: PatronageCreateNestedManyWithoutUserParentInput
    userChild?: PatronageCreateNestedOneWithoutUserChildInput
  }

  export type UserUncheckedCreateWithoutWalletInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ruleId?: string | null
    stripeCustomerId?: string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailUncheckedCreateNestedManyWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUserInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutUserInput
    historical?: HistoricalUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receiver?: ReceiverUncheckedCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    patronage?: PatronageUncheckedCreateNestedManyWithoutUserParentInput
    userChild?: PatronageUncheckedCreateNestedOneWithoutUserChildInput
  }

  export type UserCreateOrConnectWithoutWalletInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
  }

  export type TransactionCreateWithoutWalletInput = {
    id?: string
    type: EnumTypeTransaction
    date: Date | string
    amount: number
    status: EnumStatusTransaction
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    box?: BoxCreateNestedOneWithoutTransactionInput
    offer?: OfferCreateNestedOneWithoutTransactionInput
    shoppingCart?: ShoppingCartCreateNestedOneWithoutTransactionInput
    bank?: BankCreateNestedOneWithoutTransactionInput
    game?: GameCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutWalletInput = {
    id?: string
    type: EnumTypeTransaction
    date: Date | string
    amount: number
    status: EnumStatusTransaction
    boxId?: string | null
    offerId?: string | null
    shoppingCartId?: string | null
    bankId?: string | null
    gameId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TransactionCreateOrConnectWithoutWalletInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutWalletInput, TransactionUncheckedCreateWithoutWalletInput>
  }

  export type TransactionCreateManyWalletInputEnvelope = {
    data: Enumerable<TransactionCreateManyWalletInput>
  }

  export type UserUpsertWithoutWalletInput = {
    update: XOR<UserUpdateWithoutWalletInput, UserUncheckedUpdateWithoutWalletInput>
    create: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
  }

  export type UserUpdateWithoutWalletInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    rule?: RuleUpdateOneWithoutUserNestedInput
    address?: AddressUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUpdateManyWithoutUserNestedInput
    shoppingCart?: ShoppingCartUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUpdateManyWithoutUserNestedInput
    historical?: HistoricalUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    patronage?: PatronageUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUpdateOneWithoutUserChildNestedInput
  }

  export type UserUncheckedUpdateWithoutWalletInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ruleId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUncheckedUpdateManyWithoutUserNestedInput
    shoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutUserNestedInput
    historical?: HistoricalUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUncheckedUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    patronage?: PatronageUncheckedUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUncheckedUpdateOneWithoutUserChildNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutWalletInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutWalletInput, TransactionUncheckedUpdateWithoutWalletInput>
    create: XOR<TransactionCreateWithoutWalletInput, TransactionUncheckedCreateWithoutWalletInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutWalletInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutWalletInput, TransactionUncheckedUpdateWithoutWalletInput>
  }

  export type TransactionUpdateManyWithWhereWithoutWalletInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTransactionInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: Enumerable<TransactionScalarWhereInput>
    OR?: Enumerable<TransactionScalarWhereInput>
    NOT?: Enumerable<TransactionScalarWhereInput>
    id?: StringFilter | string
    type?: EnumEnumTypeTransactionFilter | EnumTypeTransaction
    date?: DateTimeFilter | Date | string
    amount?: FloatFilter | number
    status?: EnumEnumStatusTransactionFilter | EnumStatusTransaction
    boxId?: StringNullableFilter | string | null
    walletId?: StringFilter | string
    offerId?: StringNullableFilter | string | null
    shoppingCartId?: StringNullableFilter | string | null
    bankId?: StringNullableFilter | string | null
    gameId?: StringNullableFilter | string | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type BoxCreateWithoutBoxTypeInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    boxImage?: BoxImageCreateNestedManyWithoutBoxInput
    article?: ArticleCreateNestedManyWithoutBoxInput
    transaction?: TransactionCreateNestedManyWithoutBoxInput
    userBox?: UserBoxCreateNestedManyWithoutBoxInput
    bannerImage?: BannerImageCreateNestedManyWithoutBoxInput
    boxParams?: BoxParamsCreateNestedOneWithoutBoxInput
    boxArticle?: BoxArticleCreateNestedManyWithoutBoxInput
    dailyReward?: DailyRewardCreateNestedManyWithoutBoxInput
    boxRewardLevel?: BoxRewardLevelCreateNestedManyWithoutBoxInput
  }

  export type BoxUncheckedCreateWithoutBoxTypeInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    boxImage?: BoxImageUncheckedCreateNestedManyWithoutBoxInput
    article?: ArticleUncheckedCreateNestedManyWithoutBoxInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutBoxInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutBoxInput
    bannerImage?: BannerImageUncheckedCreateNestedManyWithoutBoxInput
    boxParams?: BoxParamsUncheckedCreateNestedOneWithoutBoxInput
    boxArticle?: BoxArticleUncheckedCreateNestedManyWithoutBoxInput
    dailyReward?: DailyRewardUncheckedCreateNestedManyWithoutBoxInput
    boxRewardLevel?: BoxRewardLevelUncheckedCreateNestedManyWithoutBoxInput
  }

  export type BoxCreateOrConnectWithoutBoxTypeInput = {
    where: BoxWhereUniqueInput
    create: XOR<BoxCreateWithoutBoxTypeInput, BoxUncheckedCreateWithoutBoxTypeInput>
  }

  export type BoxCreateManyBoxTypeInputEnvelope = {
    data: Enumerable<BoxCreateManyBoxTypeInput>
  }

  export type BoxUpsertWithWhereUniqueWithoutBoxTypeInput = {
    where: BoxWhereUniqueInput
    update: XOR<BoxUpdateWithoutBoxTypeInput, BoxUncheckedUpdateWithoutBoxTypeInput>
    create: XOR<BoxCreateWithoutBoxTypeInput, BoxUncheckedCreateWithoutBoxTypeInput>
  }

  export type BoxUpdateWithWhereUniqueWithoutBoxTypeInput = {
    where: BoxWhereUniqueInput
    data: XOR<BoxUpdateWithoutBoxTypeInput, BoxUncheckedUpdateWithoutBoxTypeInput>
  }

  export type BoxUpdateManyWithWhereWithoutBoxTypeInput = {
    where: BoxScalarWhereInput
    data: XOR<BoxUpdateManyMutationInput, BoxUncheckedUpdateManyWithoutBoxInput>
  }

  export type BoxScalarWhereInput = {
    AND?: Enumerable<BoxScalarWhereInput>
    OR?: Enumerable<BoxScalarWhereInput>
    NOT?: Enumerable<BoxScalarWhereInput>
    id?: StringFilter | string
    reference?: StringFilter | string
    name?: StringFilter | string
    price?: FloatFilter | number
    number?: IntFilter | number
    description?: StringFilter | string
    badge?: EnumEnumBadgeBoxNullableFilter | EnumBadgeBox | null
    boxTypeId?: StringNullableFilter | string | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type BoxImageCreateWithoutBoxInput = {
    id?: string
    photoUrl: string
    status: EnumBoxImageStatus
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BoxImageUncheckedCreateWithoutBoxInput = {
    id?: string
    photoUrl: string
    status: EnumBoxImageStatus
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BoxImageCreateOrConnectWithoutBoxInput = {
    where: BoxImageWhereUniqueInput
    create: XOR<BoxImageCreateWithoutBoxInput, BoxImageUncheckedCreateWithoutBoxInput>
  }

  export type BoxImageCreateManyBoxInputEnvelope = {
    data: Enumerable<BoxImageCreateManyBoxInput>
  }

  export type ArticleCreateWithoutBoxInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    provider?: ProviderCreateNestedOneWithoutArticleInput
    unitySize?: UnitySizeCreateNestedOneWithoutArticleInput
    subCategory?: SubCategoryCreateNestedOneWithoutArticleInput
    articlePhoto?: ArticlePhotoCreateNestedManyWithoutArticleInput
    post?: PostCreateNestedManyWithoutArticleInput
    price?: PriceCreateNestedOneWithoutArticleInput
    boxArticle?: BoxArticleCreateNestedManyWithoutArticleInput
    game?: GameCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutBoxInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    providerId?: string | null
    unitySizeId?: string | null
    subCategoryId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    articlePhoto?: ArticlePhotoUncheckedCreateNestedManyWithoutArticleInput
    post?: PostUncheckedCreateNestedManyWithoutArticleInput
    price?: PriceUncheckedCreateNestedOneWithoutArticleInput
    boxArticle?: BoxArticleUncheckedCreateNestedManyWithoutArticleInput
    game?: GameUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutBoxInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutBoxInput, ArticleUncheckedCreateWithoutBoxInput>
  }

  export type ArticleCreateManyBoxInputEnvelope = {
    data: Enumerable<ArticleCreateManyBoxInput>
  }

  export type TransactionCreateWithoutBoxInput = {
    id?: string
    type: EnumTypeTransaction
    date: Date | string
    amount: number
    status: EnumStatusTransaction
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    wallet: WalletCreateNestedOneWithoutTransactionInput
    offer?: OfferCreateNestedOneWithoutTransactionInput
    shoppingCart?: ShoppingCartCreateNestedOneWithoutTransactionInput
    bank?: BankCreateNestedOneWithoutTransactionInput
    game?: GameCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutBoxInput = {
    id?: string
    type: EnumTypeTransaction
    date: Date | string
    amount: number
    status: EnumStatusTransaction
    walletId: string
    offerId?: string | null
    shoppingCartId?: string | null
    bankId?: string | null
    gameId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TransactionCreateOrConnectWithoutBoxInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutBoxInput, TransactionUncheckedCreateWithoutBoxInput>
  }

  export type TransactionCreateManyBoxInputEnvelope = {
    data: Enumerable<TransactionCreateManyBoxInput>
  }

  export type UserBoxCreateWithoutBoxInput = {
    id?: string
    type: EnumUserBoxType
    duration?: Date | string | null
    dayNumber?: number | null
    isPlayed?: boolean | null
    isLocked?: boolean | null
    playedDate?: Date | string | null
    activationDate?: Date | string | null
    deactivationDate?: Date | string | null
    orderNumber?: number | null
    name?: string | null
    unlockThreshold?: number | null
    description?: string | null
    lot?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutUserBoxInput
    game?: GameCreateNestedManyWithoutUserBoxInput
  }

  export type UserBoxUncheckedCreateWithoutBoxInput = {
    id?: string
    type: EnumUserBoxType
    duration?: Date | string | null
    dayNumber?: number | null
    isPlayed?: boolean | null
    isLocked?: boolean | null
    playedDate?: Date | string | null
    activationDate?: Date | string | null
    deactivationDate?: Date | string | null
    orderNumber?: number | null
    name?: string | null
    unlockThreshold?: number | null
    description?: string | null
    userId: string
    lot?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    game?: GameUncheckedCreateNestedManyWithoutUserBoxInput
  }

  export type UserBoxCreateOrConnectWithoutBoxInput = {
    where: UserBoxWhereUniqueInput
    create: XOR<UserBoxCreateWithoutBoxInput, UserBoxUncheckedCreateWithoutBoxInput>
  }

  export type UserBoxCreateManyBoxInputEnvelope = {
    data: Enumerable<UserBoxCreateManyBoxInput>
  }

  export type BannerImageCreateWithoutBoxInput = {
    id?: string
    bannerImgUrl: string
    bannerLink?: string | null
    type?: BannerImageType | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    offer?: OfferCreateNestedOneWithoutBannerImageInput
  }

  export type BannerImageUncheckedCreateWithoutBoxInput = {
    id?: string
    bannerImgUrl: string
    bannerLink?: string | null
    type?: BannerImageType | null
    offerId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BannerImageCreateOrConnectWithoutBoxInput = {
    where: BannerImageWhereUniqueInput
    create: XOR<BannerImageCreateWithoutBoxInput, BannerImageUncheckedCreateWithoutBoxInput>
  }

  export type BannerImageCreateManyBoxInputEnvelope = {
    data: Enumerable<BannerImageCreateManyBoxInput>
  }

  export type BoxParamsCreateWithoutBoxInput = {
    id?: string
    isBestSelling?: boolean
    isRecommended?: boolean
    isNew?: boolean
    isBigPrice?: boolean
    isSubsciptionBonus?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BoxParamsUncheckedCreateWithoutBoxInput = {
    id?: string
    isBestSelling?: boolean
    isRecommended?: boolean
    isNew?: boolean
    isBigPrice?: boolean
    isSubsciptionBonus?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BoxParamsCreateOrConnectWithoutBoxInput = {
    where: BoxParamsWhereUniqueInput
    create: XOR<BoxParamsCreateWithoutBoxInput, BoxParamsUncheckedCreateWithoutBoxInput>
  }

  export type BoxTypeCreateWithoutBoxInput = {
    id?: string
    reference: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BoxTypeUncheckedCreateWithoutBoxInput = {
    id?: string
    reference: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BoxTypeCreateOrConnectWithoutBoxInput = {
    where: BoxTypeWhereUniqueInput
    create: XOR<BoxTypeCreateWithoutBoxInput, BoxTypeUncheckedCreateWithoutBoxInput>
  }

  export type BoxArticleCreateWithoutBoxInput = {
    id?: string
    winningChance: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    article: ArticleCreateNestedOneWithoutBoxArticleInput
  }

  export type BoxArticleUncheckedCreateWithoutBoxInput = {
    id?: string
    winningChance: number
    articleId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BoxArticleCreateOrConnectWithoutBoxInput = {
    where: BoxArticleWhereUniqueInput
    create: XOR<BoxArticleCreateWithoutBoxInput, BoxArticleUncheckedCreateWithoutBoxInput>
  }

  export type BoxArticleCreateManyBoxInputEnvelope = {
    data: Enumerable<BoxArticleCreateManyBoxInput>
  }

  export type DailyRewardCreateWithoutBoxInput = {
    id?: string
    number: number
  }

  export type DailyRewardUncheckedCreateWithoutBoxInput = {
    id?: string
    number: number
  }

  export type DailyRewardCreateOrConnectWithoutBoxInput = {
    where: DailyRewardWhereUniqueInput
    create: XOR<DailyRewardCreateWithoutBoxInput, DailyRewardUncheckedCreateWithoutBoxInput>
  }

  export type DailyRewardCreateManyBoxInputEnvelope = {
    data: Enumerable<DailyRewardCreateManyBoxInput>
  }

  export type BoxRewardLevelCreateWithoutBoxInput = {
    id?: string
    rewardLevel: RewardLevelCreateNestedOneWithoutBoxRewardLevelInput
  }

  export type BoxRewardLevelUncheckedCreateWithoutBoxInput = {
    id?: string
    rewardLevelId: string
  }

  export type BoxRewardLevelCreateOrConnectWithoutBoxInput = {
    where: BoxRewardLevelWhereUniqueInput
    create: XOR<BoxRewardLevelCreateWithoutBoxInput, BoxRewardLevelUncheckedCreateWithoutBoxInput>
  }

  export type BoxRewardLevelCreateManyBoxInputEnvelope = {
    data: Enumerable<BoxRewardLevelCreateManyBoxInput>
  }

  export type BoxImageUpsertWithWhereUniqueWithoutBoxInput = {
    where: BoxImageWhereUniqueInput
    update: XOR<BoxImageUpdateWithoutBoxInput, BoxImageUncheckedUpdateWithoutBoxInput>
    create: XOR<BoxImageCreateWithoutBoxInput, BoxImageUncheckedCreateWithoutBoxInput>
  }

  export type BoxImageUpdateWithWhereUniqueWithoutBoxInput = {
    where: BoxImageWhereUniqueInput
    data: XOR<BoxImageUpdateWithoutBoxInput, BoxImageUncheckedUpdateWithoutBoxInput>
  }

  export type BoxImageUpdateManyWithWhereWithoutBoxInput = {
    where: BoxImageScalarWhereInput
    data: XOR<BoxImageUpdateManyMutationInput, BoxImageUncheckedUpdateManyWithoutBoxImageInput>
  }

  export type BoxImageScalarWhereInput = {
    AND?: Enumerable<BoxImageScalarWhereInput>
    OR?: Enumerable<BoxImageScalarWhereInput>
    NOT?: Enumerable<BoxImageScalarWhereInput>
    id?: StringFilter | string
    photoUrl?: StringFilter | string
    status?: EnumEnumBoxImageStatusFilter | EnumBoxImageStatus
    boxId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type ArticleUpsertWithWhereUniqueWithoutBoxInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutBoxInput, ArticleUncheckedUpdateWithoutBoxInput>
    create: XOR<ArticleCreateWithoutBoxInput, ArticleUncheckedCreateWithoutBoxInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutBoxInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutBoxInput, ArticleUncheckedUpdateWithoutBoxInput>
  }

  export type ArticleUpdateManyWithWhereWithoutBoxInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutArticleInput>
  }

  export type ArticleScalarWhereInput = {
    AND?: Enumerable<ArticleScalarWhereInput>
    OR?: Enumerable<ArticleScalarWhereInput>
    NOT?: Enumerable<ArticleScalarWhereInput>
    id?: StringFilter | string
    reference?: StringFilter | string
    designation?: StringFilter | string
    type?: EnumEnumTypeModeNullableFilter | EnumTypeMode | null
    size?: StringNullableFilter | string | null
    color?: StringNullableFilter | string | null
    productUrl?: StringNullableFilter | string | null
    observation?: StringNullableFilter | string | null
    winningChance?: FloatNullableFilter | number | null
    providerId?: StringNullableFilter | string | null
    unitySizeId?: StringNullableFilter | string | null
    subCategoryId?: StringFilter | string
    boxId?: StringNullableFilter | string | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type TransactionUpsertWithWhereUniqueWithoutBoxInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutBoxInput, TransactionUncheckedUpdateWithoutBoxInput>
    create: XOR<TransactionCreateWithoutBoxInput, TransactionUncheckedCreateWithoutBoxInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutBoxInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutBoxInput, TransactionUncheckedUpdateWithoutBoxInput>
  }

  export type TransactionUpdateManyWithWhereWithoutBoxInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTransactionInput>
  }

  export type UserBoxUpsertWithWhereUniqueWithoutBoxInput = {
    where: UserBoxWhereUniqueInput
    update: XOR<UserBoxUpdateWithoutBoxInput, UserBoxUncheckedUpdateWithoutBoxInput>
    create: XOR<UserBoxCreateWithoutBoxInput, UserBoxUncheckedCreateWithoutBoxInput>
  }

  export type UserBoxUpdateWithWhereUniqueWithoutBoxInput = {
    where: UserBoxWhereUniqueInput
    data: XOR<UserBoxUpdateWithoutBoxInput, UserBoxUncheckedUpdateWithoutBoxInput>
  }

  export type UserBoxUpdateManyWithWhereWithoutBoxInput = {
    where: UserBoxScalarWhereInput
    data: XOR<UserBoxUpdateManyMutationInput, UserBoxUncheckedUpdateManyWithoutUserBoxInput>
  }

  export type BannerImageUpsertWithWhereUniqueWithoutBoxInput = {
    where: BannerImageWhereUniqueInput
    update: XOR<BannerImageUpdateWithoutBoxInput, BannerImageUncheckedUpdateWithoutBoxInput>
    create: XOR<BannerImageCreateWithoutBoxInput, BannerImageUncheckedCreateWithoutBoxInput>
  }

  export type BannerImageUpdateWithWhereUniqueWithoutBoxInput = {
    where: BannerImageWhereUniqueInput
    data: XOR<BannerImageUpdateWithoutBoxInput, BannerImageUncheckedUpdateWithoutBoxInput>
  }

  export type BannerImageUpdateManyWithWhereWithoutBoxInput = {
    where: BannerImageScalarWhereInput
    data: XOR<BannerImageUpdateManyMutationInput, BannerImageUncheckedUpdateManyWithoutBannerImageInput>
  }

  export type BannerImageScalarWhereInput = {
    AND?: Enumerable<BannerImageScalarWhereInput>
    OR?: Enumerable<BannerImageScalarWhereInput>
    NOT?: Enumerable<BannerImageScalarWhereInput>
    id?: StringFilter | string
    bannerImgUrl?: StringFilter | string
    bannerLink?: StringNullableFilter | string | null
    type?: EnumBannerImageTypeNullableFilter | BannerImageType | null
    boxId?: StringNullableFilter | string | null
    offerId?: StringNullableFilter | string | null
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type BoxParamsUpsertWithoutBoxInput = {
    update: XOR<BoxParamsUpdateWithoutBoxInput, BoxParamsUncheckedUpdateWithoutBoxInput>
    create: XOR<BoxParamsCreateWithoutBoxInput, BoxParamsUncheckedCreateWithoutBoxInput>
  }

  export type BoxParamsUpdateWithoutBoxInput = {
    isBestSelling?: BoolFieldUpdateOperationsInput | boolean
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isBigPrice?: BoolFieldUpdateOperationsInput | boolean
    isSubsciptionBonus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxParamsUncheckedUpdateWithoutBoxInput = {
    isBestSelling?: BoolFieldUpdateOperationsInput | boolean
    isRecommended?: BoolFieldUpdateOperationsInput | boolean
    isNew?: BoolFieldUpdateOperationsInput | boolean
    isBigPrice?: BoolFieldUpdateOperationsInput | boolean
    isSubsciptionBonus?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxTypeUpsertWithoutBoxInput = {
    update: XOR<BoxTypeUpdateWithoutBoxInput, BoxTypeUncheckedUpdateWithoutBoxInput>
    create: XOR<BoxTypeCreateWithoutBoxInput, BoxTypeUncheckedCreateWithoutBoxInput>
  }

  export type BoxTypeUpdateWithoutBoxInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxTypeUncheckedUpdateWithoutBoxInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxArticleUpsertWithWhereUniqueWithoutBoxInput = {
    where: BoxArticleWhereUniqueInput
    update: XOR<BoxArticleUpdateWithoutBoxInput, BoxArticleUncheckedUpdateWithoutBoxInput>
    create: XOR<BoxArticleCreateWithoutBoxInput, BoxArticleUncheckedCreateWithoutBoxInput>
  }

  export type BoxArticleUpdateWithWhereUniqueWithoutBoxInput = {
    where: BoxArticleWhereUniqueInput
    data: XOR<BoxArticleUpdateWithoutBoxInput, BoxArticleUncheckedUpdateWithoutBoxInput>
  }

  export type BoxArticleUpdateManyWithWhereWithoutBoxInput = {
    where: BoxArticleScalarWhereInput
    data: XOR<BoxArticleUpdateManyMutationInput, BoxArticleUncheckedUpdateManyWithoutBoxArticleInput>
  }

  export type BoxArticleScalarWhereInput = {
    AND?: Enumerable<BoxArticleScalarWhereInput>
    OR?: Enumerable<BoxArticleScalarWhereInput>
    NOT?: Enumerable<BoxArticleScalarWhereInput>
    id?: StringFilter | string
    winningChance?: FloatFilter | number
    boxId?: StringFilter | string
    articleId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type DailyRewardUpsertWithWhereUniqueWithoutBoxInput = {
    where: DailyRewardWhereUniqueInput
    update: XOR<DailyRewardUpdateWithoutBoxInput, DailyRewardUncheckedUpdateWithoutBoxInput>
    create: XOR<DailyRewardCreateWithoutBoxInput, DailyRewardUncheckedCreateWithoutBoxInput>
  }

  export type DailyRewardUpdateWithWhereUniqueWithoutBoxInput = {
    where: DailyRewardWhereUniqueInput
    data: XOR<DailyRewardUpdateWithoutBoxInput, DailyRewardUncheckedUpdateWithoutBoxInput>
  }

  export type DailyRewardUpdateManyWithWhereWithoutBoxInput = {
    where: DailyRewardScalarWhereInput
    data: XOR<DailyRewardUpdateManyMutationInput, DailyRewardUncheckedUpdateManyWithoutDailyRewardInput>
  }

  export type DailyRewardScalarWhereInput = {
    AND?: Enumerable<DailyRewardScalarWhereInput>
    OR?: Enumerable<DailyRewardScalarWhereInput>
    NOT?: Enumerable<DailyRewardScalarWhereInput>
    id?: StringFilter | string
    number?: IntFilter | number
    boxId?: StringFilter | string
  }

  export type BoxRewardLevelUpsertWithWhereUniqueWithoutBoxInput = {
    where: BoxRewardLevelWhereUniqueInput
    update: XOR<BoxRewardLevelUpdateWithoutBoxInput, BoxRewardLevelUncheckedUpdateWithoutBoxInput>
    create: XOR<BoxRewardLevelCreateWithoutBoxInput, BoxRewardLevelUncheckedCreateWithoutBoxInput>
  }

  export type BoxRewardLevelUpdateWithWhereUniqueWithoutBoxInput = {
    where: BoxRewardLevelWhereUniqueInput
    data: XOR<BoxRewardLevelUpdateWithoutBoxInput, BoxRewardLevelUncheckedUpdateWithoutBoxInput>
  }

  export type BoxRewardLevelUpdateManyWithWhereWithoutBoxInput = {
    where: BoxRewardLevelScalarWhereInput
    data: XOR<BoxRewardLevelUpdateManyMutationInput, BoxRewardLevelUncheckedUpdateManyWithoutBoxRewardLevelInput>
  }

  export type BoxRewardLevelScalarWhereInput = {
    AND?: Enumerable<BoxRewardLevelScalarWhereInput>
    OR?: Enumerable<BoxRewardLevelScalarWhereInput>
    NOT?: Enumerable<BoxRewardLevelScalarWhereInput>
    id?: StringFilter | string
    boxId?: StringFilter | string
    rewardLevelId?: StringFilter | string
  }

  export type BoxCreateWithoutDailyRewardInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    boxImage?: BoxImageCreateNestedManyWithoutBoxInput
    article?: ArticleCreateNestedManyWithoutBoxInput
    transaction?: TransactionCreateNestedManyWithoutBoxInput
    userBox?: UserBoxCreateNestedManyWithoutBoxInput
    bannerImage?: BannerImageCreateNestedManyWithoutBoxInput
    boxParams?: BoxParamsCreateNestedOneWithoutBoxInput
    boxType?: BoxTypeCreateNestedOneWithoutBoxInput
    boxArticle?: BoxArticleCreateNestedManyWithoutBoxInput
    boxRewardLevel?: BoxRewardLevelCreateNestedManyWithoutBoxInput
  }

  export type BoxUncheckedCreateWithoutDailyRewardInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    boxTypeId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    boxImage?: BoxImageUncheckedCreateNestedManyWithoutBoxInput
    article?: ArticleUncheckedCreateNestedManyWithoutBoxInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutBoxInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutBoxInput
    bannerImage?: BannerImageUncheckedCreateNestedManyWithoutBoxInput
    boxParams?: BoxParamsUncheckedCreateNestedOneWithoutBoxInput
    boxArticle?: BoxArticleUncheckedCreateNestedManyWithoutBoxInput
    boxRewardLevel?: BoxRewardLevelUncheckedCreateNestedManyWithoutBoxInput
  }

  export type BoxCreateOrConnectWithoutDailyRewardInput = {
    where: BoxWhereUniqueInput
    create: XOR<BoxCreateWithoutDailyRewardInput, BoxUncheckedCreateWithoutDailyRewardInput>
  }

  export type BoxUpsertWithoutDailyRewardInput = {
    update: XOR<BoxUpdateWithoutDailyRewardInput, BoxUncheckedUpdateWithoutDailyRewardInput>
    create: XOR<BoxCreateWithoutDailyRewardInput, BoxUncheckedCreateWithoutDailyRewardInput>
  }

  export type BoxUpdateWithoutDailyRewardInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    boxImage?: BoxImageUpdateManyWithoutBoxNestedInput
    article?: ArticleUpdateManyWithoutBoxNestedInput
    transaction?: TransactionUpdateManyWithoutBoxNestedInput
    userBox?: UserBoxUpdateManyWithoutBoxNestedInput
    bannerImage?: BannerImageUpdateManyWithoutBoxNestedInput
    boxParams?: BoxParamsUpdateOneWithoutBoxNestedInput
    boxType?: BoxTypeUpdateOneWithoutBoxNestedInput
    boxArticle?: BoxArticleUpdateManyWithoutBoxNestedInput
    boxRewardLevel?: BoxRewardLevelUpdateManyWithoutBoxNestedInput
  }

  export type BoxUncheckedUpdateWithoutDailyRewardInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    boxTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    boxImage?: BoxImageUncheckedUpdateManyWithoutBoxNestedInput
    article?: ArticleUncheckedUpdateManyWithoutBoxNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutBoxNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutBoxNestedInput
    bannerImage?: BannerImageUncheckedUpdateManyWithoutBoxNestedInput
    boxParams?: BoxParamsUncheckedUpdateOneWithoutBoxNestedInput
    boxArticle?: BoxArticleUncheckedUpdateManyWithoutBoxNestedInput
    boxRewardLevel?: BoxRewardLevelUncheckedUpdateManyWithoutBoxNestedInput
  }

  export type BoxCreateWithoutBoxRewardLevelInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    boxImage?: BoxImageCreateNestedManyWithoutBoxInput
    article?: ArticleCreateNestedManyWithoutBoxInput
    transaction?: TransactionCreateNestedManyWithoutBoxInput
    userBox?: UserBoxCreateNestedManyWithoutBoxInput
    bannerImage?: BannerImageCreateNestedManyWithoutBoxInput
    boxParams?: BoxParamsCreateNestedOneWithoutBoxInput
    boxType?: BoxTypeCreateNestedOneWithoutBoxInput
    boxArticle?: BoxArticleCreateNestedManyWithoutBoxInput
    dailyReward?: DailyRewardCreateNestedManyWithoutBoxInput
  }

  export type BoxUncheckedCreateWithoutBoxRewardLevelInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    boxTypeId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    boxImage?: BoxImageUncheckedCreateNestedManyWithoutBoxInput
    article?: ArticleUncheckedCreateNestedManyWithoutBoxInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutBoxInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutBoxInput
    bannerImage?: BannerImageUncheckedCreateNestedManyWithoutBoxInput
    boxParams?: BoxParamsUncheckedCreateNestedOneWithoutBoxInput
    boxArticle?: BoxArticleUncheckedCreateNestedManyWithoutBoxInput
    dailyReward?: DailyRewardUncheckedCreateNestedManyWithoutBoxInput
  }

  export type BoxCreateOrConnectWithoutBoxRewardLevelInput = {
    where: BoxWhereUniqueInput
    create: XOR<BoxCreateWithoutBoxRewardLevelInput, BoxUncheckedCreateWithoutBoxRewardLevelInput>
  }

  export type RewardLevelCreateWithoutBoxRewardLevelInput = {
    id?: string
    orderNumber: number
    name: string
    unlockThreshold: number
    description?: string | null
  }

  export type RewardLevelUncheckedCreateWithoutBoxRewardLevelInput = {
    id?: string
    orderNumber: number
    name: string
    unlockThreshold: number
    description?: string | null
  }

  export type RewardLevelCreateOrConnectWithoutBoxRewardLevelInput = {
    where: RewardLevelWhereUniqueInput
    create: XOR<RewardLevelCreateWithoutBoxRewardLevelInput, RewardLevelUncheckedCreateWithoutBoxRewardLevelInput>
  }

  export type BoxUpsertWithoutBoxRewardLevelInput = {
    update: XOR<BoxUpdateWithoutBoxRewardLevelInput, BoxUncheckedUpdateWithoutBoxRewardLevelInput>
    create: XOR<BoxCreateWithoutBoxRewardLevelInput, BoxUncheckedCreateWithoutBoxRewardLevelInput>
  }

  export type BoxUpdateWithoutBoxRewardLevelInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    boxImage?: BoxImageUpdateManyWithoutBoxNestedInput
    article?: ArticleUpdateManyWithoutBoxNestedInput
    transaction?: TransactionUpdateManyWithoutBoxNestedInput
    userBox?: UserBoxUpdateManyWithoutBoxNestedInput
    bannerImage?: BannerImageUpdateManyWithoutBoxNestedInput
    boxParams?: BoxParamsUpdateOneWithoutBoxNestedInput
    boxType?: BoxTypeUpdateOneWithoutBoxNestedInput
    boxArticle?: BoxArticleUpdateManyWithoutBoxNestedInput
    dailyReward?: DailyRewardUpdateManyWithoutBoxNestedInput
  }

  export type BoxUncheckedUpdateWithoutBoxRewardLevelInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    boxTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    boxImage?: BoxImageUncheckedUpdateManyWithoutBoxNestedInput
    article?: ArticleUncheckedUpdateManyWithoutBoxNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutBoxNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutBoxNestedInput
    bannerImage?: BannerImageUncheckedUpdateManyWithoutBoxNestedInput
    boxParams?: BoxParamsUncheckedUpdateOneWithoutBoxNestedInput
    boxArticle?: BoxArticleUncheckedUpdateManyWithoutBoxNestedInput
    dailyReward?: DailyRewardUncheckedUpdateManyWithoutBoxNestedInput
  }

  export type RewardLevelUpsertWithoutBoxRewardLevelInput = {
    update: XOR<RewardLevelUpdateWithoutBoxRewardLevelInput, RewardLevelUncheckedUpdateWithoutBoxRewardLevelInput>
    create: XOR<RewardLevelCreateWithoutBoxRewardLevelInput, RewardLevelUncheckedCreateWithoutBoxRewardLevelInput>
  }

  export type RewardLevelUpdateWithoutBoxRewardLevelInput = {
    orderNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unlockThreshold?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RewardLevelUncheckedUpdateWithoutBoxRewardLevelInput = {
    orderNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    unlockThreshold?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BoxRewardLevelCreateWithoutRewardLevelInput = {
    id?: string
    box: BoxCreateNestedOneWithoutBoxRewardLevelInput
  }

  export type BoxRewardLevelUncheckedCreateWithoutRewardLevelInput = {
    id?: string
    boxId: string
  }

  export type BoxRewardLevelCreateOrConnectWithoutRewardLevelInput = {
    where: BoxRewardLevelWhereUniqueInput
    create: XOR<BoxRewardLevelCreateWithoutRewardLevelInput, BoxRewardLevelUncheckedCreateWithoutRewardLevelInput>
  }

  export type BoxRewardLevelCreateManyRewardLevelInputEnvelope = {
    data: Enumerable<BoxRewardLevelCreateManyRewardLevelInput>
  }

  export type BoxRewardLevelUpsertWithWhereUniqueWithoutRewardLevelInput = {
    where: BoxRewardLevelWhereUniqueInput
    update: XOR<BoxRewardLevelUpdateWithoutRewardLevelInput, BoxRewardLevelUncheckedUpdateWithoutRewardLevelInput>
    create: XOR<BoxRewardLevelCreateWithoutRewardLevelInput, BoxRewardLevelUncheckedCreateWithoutRewardLevelInput>
  }

  export type BoxRewardLevelUpdateWithWhereUniqueWithoutRewardLevelInput = {
    where: BoxRewardLevelWhereUniqueInput
    data: XOR<BoxRewardLevelUpdateWithoutRewardLevelInput, BoxRewardLevelUncheckedUpdateWithoutRewardLevelInput>
  }

  export type BoxRewardLevelUpdateManyWithWhereWithoutRewardLevelInput = {
    where: BoxRewardLevelScalarWhereInput
    data: XOR<BoxRewardLevelUpdateManyMutationInput, BoxRewardLevelUncheckedUpdateManyWithoutBoxRewardLevelInput>
  }

  export type BoxCreateWithoutBoxImageInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    article?: ArticleCreateNestedManyWithoutBoxInput
    transaction?: TransactionCreateNestedManyWithoutBoxInput
    userBox?: UserBoxCreateNestedManyWithoutBoxInput
    bannerImage?: BannerImageCreateNestedManyWithoutBoxInput
    boxParams?: BoxParamsCreateNestedOneWithoutBoxInput
    boxType?: BoxTypeCreateNestedOneWithoutBoxInput
    boxArticle?: BoxArticleCreateNestedManyWithoutBoxInput
    dailyReward?: DailyRewardCreateNestedManyWithoutBoxInput
    boxRewardLevel?: BoxRewardLevelCreateNestedManyWithoutBoxInput
  }

  export type BoxUncheckedCreateWithoutBoxImageInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    boxTypeId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    article?: ArticleUncheckedCreateNestedManyWithoutBoxInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutBoxInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutBoxInput
    bannerImage?: BannerImageUncheckedCreateNestedManyWithoutBoxInput
    boxParams?: BoxParamsUncheckedCreateNestedOneWithoutBoxInput
    boxArticle?: BoxArticleUncheckedCreateNestedManyWithoutBoxInput
    dailyReward?: DailyRewardUncheckedCreateNestedManyWithoutBoxInput
    boxRewardLevel?: BoxRewardLevelUncheckedCreateNestedManyWithoutBoxInput
  }

  export type BoxCreateOrConnectWithoutBoxImageInput = {
    where: BoxWhereUniqueInput
    create: XOR<BoxCreateWithoutBoxImageInput, BoxUncheckedCreateWithoutBoxImageInput>
  }

  export type BoxUpsertWithoutBoxImageInput = {
    update: XOR<BoxUpdateWithoutBoxImageInput, BoxUncheckedUpdateWithoutBoxImageInput>
    create: XOR<BoxCreateWithoutBoxImageInput, BoxUncheckedCreateWithoutBoxImageInput>
  }

  export type BoxUpdateWithoutBoxImageInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    article?: ArticleUpdateManyWithoutBoxNestedInput
    transaction?: TransactionUpdateManyWithoutBoxNestedInput
    userBox?: UserBoxUpdateManyWithoutBoxNestedInput
    bannerImage?: BannerImageUpdateManyWithoutBoxNestedInput
    boxParams?: BoxParamsUpdateOneWithoutBoxNestedInput
    boxType?: BoxTypeUpdateOneWithoutBoxNestedInput
    boxArticle?: BoxArticleUpdateManyWithoutBoxNestedInput
    dailyReward?: DailyRewardUpdateManyWithoutBoxNestedInput
    boxRewardLevel?: BoxRewardLevelUpdateManyWithoutBoxNestedInput
  }

  export type BoxUncheckedUpdateWithoutBoxImageInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    boxTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    article?: ArticleUncheckedUpdateManyWithoutBoxNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutBoxNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutBoxNestedInput
    bannerImage?: BannerImageUncheckedUpdateManyWithoutBoxNestedInput
    boxParams?: BoxParamsUncheckedUpdateOneWithoutBoxNestedInput
    boxArticle?: BoxArticleUncheckedUpdateManyWithoutBoxNestedInput
    dailyReward?: DailyRewardUncheckedUpdateManyWithoutBoxNestedInput
    boxRewardLevel?: BoxRewardLevelUncheckedUpdateManyWithoutBoxNestedInput
  }

  export type ArticleCreateWithoutProviderInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    unitySize?: UnitySizeCreateNestedOneWithoutArticleInput
    subCategory?: SubCategoryCreateNestedOneWithoutArticleInput
    box?: BoxCreateNestedOneWithoutArticleInput
    articlePhoto?: ArticlePhotoCreateNestedManyWithoutArticleInput
    post?: PostCreateNestedManyWithoutArticleInput
    price?: PriceCreateNestedOneWithoutArticleInput
    boxArticle?: BoxArticleCreateNestedManyWithoutArticleInput
    game?: GameCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutProviderInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    unitySizeId?: string | null
    subCategoryId: string
    boxId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    articlePhoto?: ArticlePhotoUncheckedCreateNestedManyWithoutArticleInput
    post?: PostUncheckedCreateNestedManyWithoutArticleInput
    price?: PriceUncheckedCreateNestedOneWithoutArticleInput
    boxArticle?: BoxArticleUncheckedCreateNestedManyWithoutArticleInput
    game?: GameUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutProviderInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutProviderInput, ArticleUncheckedCreateWithoutProviderInput>
  }

  export type ArticleCreateManyProviderInputEnvelope = {
    data: Enumerable<ArticleCreateManyProviderInput>
  }

  export type ArticleUpsertWithWhereUniqueWithoutProviderInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutProviderInput, ArticleUncheckedUpdateWithoutProviderInput>
    create: XOR<ArticleCreateWithoutProviderInput, ArticleUncheckedCreateWithoutProviderInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutProviderInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutProviderInput, ArticleUncheckedUpdateWithoutProviderInput>
  }

  export type ArticleUpdateManyWithWhereWithoutProviderInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutArticleInput>
  }

  export type SubCategoryCreateWithoutCategoryInput = {
    id?: string
    reference: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    article?: ArticleCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    reference: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    article?: ArticleUncheckedCreateNestedManyWithoutSubCategoryInput
  }

  export type SubCategoryCreateOrConnectWithoutCategoryInput = {
    where: SubCategoryWhereUniqueInput
    create: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type SubCategoryCreateManyCategoryInputEnvelope = {
    data: Enumerable<SubCategoryCreateManyCategoryInput>
  }

  export type SubCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: SubCategoryWhereUniqueInput
    update: XOR<SubCategoryUpdateWithoutCategoryInput, SubCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<SubCategoryCreateWithoutCategoryInput, SubCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type SubCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: SubCategoryWhereUniqueInput
    data: XOR<SubCategoryUpdateWithoutCategoryInput, SubCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type SubCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: SubCategoryScalarWhereInput
    data: XOR<SubCategoryUpdateManyMutationInput, SubCategoryUncheckedUpdateManyWithoutSubCategoryInput>
  }

  export type SubCategoryScalarWhereInput = {
    AND?: Enumerable<SubCategoryScalarWhereInput>
    OR?: Enumerable<SubCategoryScalarWhereInput>
    NOT?: Enumerable<SubCategoryScalarWhereInput>
    id?: StringFilter | string
    reference?: StringFilter | string
    name?: StringFilter | string
    categoryId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type CategoryCreateWithoutSubCategoryInput = {
    id?: string
    reference: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CategoryUncheckedCreateWithoutSubCategoryInput = {
    id?: string
    reference: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CategoryCreateOrConnectWithoutSubCategoryInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutSubCategoryInput, CategoryUncheckedCreateWithoutSubCategoryInput>
  }

  export type ArticleCreateWithoutSubCategoryInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    provider?: ProviderCreateNestedOneWithoutArticleInput
    unitySize?: UnitySizeCreateNestedOneWithoutArticleInput
    box?: BoxCreateNestedOneWithoutArticleInput
    articlePhoto?: ArticlePhotoCreateNestedManyWithoutArticleInput
    post?: PostCreateNestedManyWithoutArticleInput
    price?: PriceCreateNestedOneWithoutArticleInput
    boxArticle?: BoxArticleCreateNestedManyWithoutArticleInput
    game?: GameCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutSubCategoryInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    providerId?: string | null
    unitySizeId?: string | null
    boxId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    articlePhoto?: ArticlePhotoUncheckedCreateNestedManyWithoutArticleInput
    post?: PostUncheckedCreateNestedManyWithoutArticleInput
    price?: PriceUncheckedCreateNestedOneWithoutArticleInput
    boxArticle?: BoxArticleUncheckedCreateNestedManyWithoutArticleInput
    game?: GameUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutSubCategoryInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutSubCategoryInput, ArticleUncheckedCreateWithoutSubCategoryInput>
  }

  export type ArticleCreateManySubCategoryInputEnvelope = {
    data: Enumerable<ArticleCreateManySubCategoryInput>
  }

  export type CategoryUpsertWithoutSubCategoryInput = {
    update: XOR<CategoryUpdateWithoutSubCategoryInput, CategoryUncheckedUpdateWithoutSubCategoryInput>
    create: XOR<CategoryCreateWithoutSubCategoryInput, CategoryUncheckedCreateWithoutSubCategoryInput>
  }

  export type CategoryUpdateWithoutSubCategoryInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryUncheckedUpdateWithoutSubCategoryInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArticleUpsertWithWhereUniqueWithoutSubCategoryInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutSubCategoryInput, ArticleUncheckedUpdateWithoutSubCategoryInput>
    create: XOR<ArticleCreateWithoutSubCategoryInput, ArticleUncheckedCreateWithoutSubCategoryInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutSubCategoryInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutSubCategoryInput, ArticleUncheckedUpdateWithoutSubCategoryInput>
  }

  export type ArticleUpdateManyWithWhereWithoutSubCategoryInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutArticleInput>
  }

  export type ArticleCreateWithoutUnitySizeInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    provider?: ProviderCreateNestedOneWithoutArticleInput
    subCategory?: SubCategoryCreateNestedOneWithoutArticleInput
    box?: BoxCreateNestedOneWithoutArticleInput
    articlePhoto?: ArticlePhotoCreateNestedManyWithoutArticleInput
    post?: PostCreateNestedManyWithoutArticleInput
    price?: PriceCreateNestedOneWithoutArticleInput
    boxArticle?: BoxArticleCreateNestedManyWithoutArticleInput
    game?: GameCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutUnitySizeInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    providerId?: string | null
    subCategoryId: string
    boxId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    articlePhoto?: ArticlePhotoUncheckedCreateNestedManyWithoutArticleInput
    post?: PostUncheckedCreateNestedManyWithoutArticleInput
    price?: PriceUncheckedCreateNestedOneWithoutArticleInput
    boxArticle?: BoxArticleUncheckedCreateNestedManyWithoutArticleInput
    game?: GameUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutUnitySizeInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutUnitySizeInput, ArticleUncheckedCreateWithoutUnitySizeInput>
  }

  export type ArticleCreateManyUnitySizeInputEnvelope = {
    data: Enumerable<ArticleCreateManyUnitySizeInput>
  }

  export type ArticleUpsertWithWhereUniqueWithoutUnitySizeInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutUnitySizeInput, ArticleUncheckedUpdateWithoutUnitySizeInput>
    create: XOR<ArticleCreateWithoutUnitySizeInput, ArticleUncheckedCreateWithoutUnitySizeInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutUnitySizeInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutUnitySizeInput, ArticleUncheckedUpdateWithoutUnitySizeInput>
  }

  export type ArticleUpdateManyWithWhereWithoutUnitySizeInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutArticleInput>
  }

  export type ProviderCreateWithoutArticleInput = {
    id?: string
    reference: string
    companyName: string
    address?: string | null
    phone?: string | null
    webSite?: string | null
    logo?: string | null
    isPinned?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ProviderUncheckedCreateWithoutArticleInput = {
    id?: string
    reference: string
    companyName: string
    address?: string | null
    phone?: string | null
    webSite?: string | null
    logo?: string | null
    isPinned?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ProviderCreateOrConnectWithoutArticleInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutArticleInput, ProviderUncheckedCreateWithoutArticleInput>
  }

  export type UnitySizeCreateWithoutArticleInput = {
    id?: string
    name: string
    abbreviation: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UnitySizeUncheckedCreateWithoutArticleInput = {
    id?: string
    name: string
    abbreviation: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UnitySizeCreateOrConnectWithoutArticleInput = {
    where: UnitySizeWhereUniqueInput
    create: XOR<UnitySizeCreateWithoutArticleInput, UnitySizeUncheckedCreateWithoutArticleInput>
  }

  export type SubCategoryCreateWithoutArticleInput = {
    id?: string
    reference: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    category: CategoryCreateNestedOneWithoutSubCategoryInput
  }

  export type SubCategoryUncheckedCreateWithoutArticleInput = {
    id?: string
    reference: string
    name: string
    categoryId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubCategoryCreateOrConnectWithoutArticleInput = {
    where: SubCategoryWhereUniqueInput
    create: XOR<SubCategoryCreateWithoutArticleInput, SubCategoryUncheckedCreateWithoutArticleInput>
  }

  export type BoxCreateWithoutArticleInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    boxImage?: BoxImageCreateNestedManyWithoutBoxInput
    transaction?: TransactionCreateNestedManyWithoutBoxInput
    userBox?: UserBoxCreateNestedManyWithoutBoxInput
    bannerImage?: BannerImageCreateNestedManyWithoutBoxInput
    boxParams?: BoxParamsCreateNestedOneWithoutBoxInput
    boxType?: BoxTypeCreateNestedOneWithoutBoxInput
    boxArticle?: BoxArticleCreateNestedManyWithoutBoxInput
    dailyReward?: DailyRewardCreateNestedManyWithoutBoxInput
    boxRewardLevel?: BoxRewardLevelCreateNestedManyWithoutBoxInput
  }

  export type BoxUncheckedCreateWithoutArticleInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    boxTypeId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    boxImage?: BoxImageUncheckedCreateNestedManyWithoutBoxInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutBoxInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutBoxInput
    bannerImage?: BannerImageUncheckedCreateNestedManyWithoutBoxInput
    boxParams?: BoxParamsUncheckedCreateNestedOneWithoutBoxInput
    boxArticle?: BoxArticleUncheckedCreateNestedManyWithoutBoxInput
    dailyReward?: DailyRewardUncheckedCreateNestedManyWithoutBoxInput
    boxRewardLevel?: BoxRewardLevelUncheckedCreateNestedManyWithoutBoxInput
  }

  export type BoxCreateOrConnectWithoutArticleInput = {
    where: BoxWhereUniqueInput
    create: XOR<BoxCreateWithoutArticleInput, BoxUncheckedCreateWithoutArticleInput>
  }

  export type ArticlePhotoCreateWithoutArticleInput = {
    id?: string
    photoUrl: string
    status?: ArticlePhotoStatus | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ArticlePhotoUncheckedCreateWithoutArticleInput = {
    id?: string
    photoUrl: string
    status?: ArticlePhotoStatus | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ArticlePhotoCreateOrConnectWithoutArticleInput = {
    where: ArticlePhotoWhereUniqueInput
    create: XOR<ArticlePhotoCreateWithoutArticleInput, ArticlePhotoUncheckedCreateWithoutArticleInput>
  }

  export type ArticlePhotoCreateManyArticleInputEnvelope = {
    data: Enumerable<ArticlePhotoCreateManyArticleInput>
  }

  export type PostCreateWithoutArticleInput = {
    id?: string
    title: string
    content: string
    postUrl: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PostUncheckedCreateWithoutArticleInput = {
    id?: string
    title: string
    content: string
    postUrl: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PostCreateOrConnectWithoutArticleInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutArticleInput, PostUncheckedCreateWithoutArticleInput>
  }

  export type PostCreateManyArticleInputEnvelope = {
    data: Enumerable<PostCreateManyArticleInput>
  }

  export type PriceCreateWithoutArticleInput = {
    id?: string
    reference?: string | null
    currentPrice: number
    oldPrice?: number | null
    rate?: number | null
    reduction?: number | null
    sellingPrice?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PriceUncheckedCreateWithoutArticleInput = {
    id?: string
    reference?: string | null
    currentPrice: number
    oldPrice?: number | null
    rate?: number | null
    reduction?: number | null
    sellingPrice?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PriceCreateOrConnectWithoutArticleInput = {
    where: PriceWhereUniqueInput
    create: XOR<PriceCreateWithoutArticleInput, PriceUncheckedCreateWithoutArticleInput>
  }

  export type BoxArticleCreateWithoutArticleInput = {
    id?: string
    winningChance: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    box: BoxCreateNestedOneWithoutBoxArticleInput
  }

  export type BoxArticleUncheckedCreateWithoutArticleInput = {
    id?: string
    winningChance: number
    boxId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BoxArticleCreateOrConnectWithoutArticleInput = {
    where: BoxArticleWhereUniqueInput
    create: XOR<BoxArticleCreateWithoutArticleInput, BoxArticleUncheckedCreateWithoutArticleInput>
  }

  export type BoxArticleCreateManyArticleInputEnvelope = {
    data: Enumerable<BoxArticleCreateManyArticleInput>
  }

  export type GameCreateWithoutArticleInput = {
    id?: string
    reference: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: EnumStatusGame
    version?: EnumVersionGame | null
    type?: EnumTypeGame | null
    gainPercentage?: number | null
    gainDraw?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    userBox?: UserBoxCreateNestedOneWithoutGameInput
    patronage?: PatronageCreateNestedOneWithoutGameInput
    shoppingCart?: ShoppingCartCreateNestedOneWithoutGameInput
    transaction?: TransactionCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutArticleInput = {
    id?: string
    reference: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: EnumStatusGame
    version?: EnumVersionGame | null
    type?: EnumTypeGame | null
    userBoxId?: string | null
    patronageId?: string | null
    gainPercentage?: number | null
    gainDraw?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    shoppingCart?: ShoppingCartUncheckedCreateNestedOneWithoutGameInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutArticleInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutArticleInput, GameUncheckedCreateWithoutArticleInput>
  }

  export type GameCreateManyArticleInputEnvelope = {
    data: Enumerable<GameCreateManyArticleInput>
  }

  export type ProviderUpsertWithoutArticleInput = {
    update: XOR<ProviderUpdateWithoutArticleInput, ProviderUncheckedUpdateWithoutArticleInput>
    create: XOR<ProviderCreateWithoutArticleInput, ProviderUncheckedCreateWithoutArticleInput>
  }

  export type ProviderUpdateWithoutArticleInput = {
    reference?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    webSite?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderUncheckedUpdateWithoutArticleInput = {
    reference?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    webSite?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitySizeUpsertWithoutArticleInput = {
    update: XOR<UnitySizeUpdateWithoutArticleInput, UnitySizeUncheckedUpdateWithoutArticleInput>
    create: XOR<UnitySizeCreateWithoutArticleInput, UnitySizeUncheckedCreateWithoutArticleInput>
  }

  export type UnitySizeUpdateWithoutArticleInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UnitySizeUncheckedUpdateWithoutArticleInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubCategoryUpsertWithoutArticleInput = {
    update: XOR<SubCategoryUpdateWithoutArticleInput, SubCategoryUncheckedUpdateWithoutArticleInput>
    create: XOR<SubCategoryCreateWithoutArticleInput, SubCategoryUncheckedCreateWithoutArticleInput>
  }

  export type SubCategoryUpdateWithoutArticleInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: CategoryUpdateOneRequiredWithoutSubCategoryNestedInput
  }

  export type SubCategoryUncheckedUpdateWithoutArticleInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxUpsertWithoutArticleInput = {
    update: XOR<BoxUpdateWithoutArticleInput, BoxUncheckedUpdateWithoutArticleInput>
    create: XOR<BoxCreateWithoutArticleInput, BoxUncheckedCreateWithoutArticleInput>
  }

  export type BoxUpdateWithoutArticleInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    boxImage?: BoxImageUpdateManyWithoutBoxNestedInput
    transaction?: TransactionUpdateManyWithoutBoxNestedInput
    userBox?: UserBoxUpdateManyWithoutBoxNestedInput
    bannerImage?: BannerImageUpdateManyWithoutBoxNestedInput
    boxParams?: BoxParamsUpdateOneWithoutBoxNestedInput
    boxType?: BoxTypeUpdateOneWithoutBoxNestedInput
    boxArticle?: BoxArticleUpdateManyWithoutBoxNestedInput
    dailyReward?: DailyRewardUpdateManyWithoutBoxNestedInput
    boxRewardLevel?: BoxRewardLevelUpdateManyWithoutBoxNestedInput
  }

  export type BoxUncheckedUpdateWithoutArticleInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    boxTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    boxImage?: BoxImageUncheckedUpdateManyWithoutBoxNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutBoxNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutBoxNestedInput
    bannerImage?: BannerImageUncheckedUpdateManyWithoutBoxNestedInput
    boxParams?: BoxParamsUncheckedUpdateOneWithoutBoxNestedInput
    boxArticle?: BoxArticleUncheckedUpdateManyWithoutBoxNestedInput
    dailyReward?: DailyRewardUncheckedUpdateManyWithoutBoxNestedInput
    boxRewardLevel?: BoxRewardLevelUncheckedUpdateManyWithoutBoxNestedInput
  }

  export type ArticlePhotoUpsertWithWhereUniqueWithoutArticleInput = {
    where: ArticlePhotoWhereUniqueInput
    update: XOR<ArticlePhotoUpdateWithoutArticleInput, ArticlePhotoUncheckedUpdateWithoutArticleInput>
    create: XOR<ArticlePhotoCreateWithoutArticleInput, ArticlePhotoUncheckedCreateWithoutArticleInput>
  }

  export type ArticlePhotoUpdateWithWhereUniqueWithoutArticleInput = {
    where: ArticlePhotoWhereUniqueInput
    data: XOR<ArticlePhotoUpdateWithoutArticleInput, ArticlePhotoUncheckedUpdateWithoutArticleInput>
  }

  export type ArticlePhotoUpdateManyWithWhereWithoutArticleInput = {
    where: ArticlePhotoScalarWhereInput
    data: XOR<ArticlePhotoUpdateManyMutationInput, ArticlePhotoUncheckedUpdateManyWithoutArticlePhotoInput>
  }

  export type ArticlePhotoScalarWhereInput = {
    AND?: Enumerable<ArticlePhotoScalarWhereInput>
    OR?: Enumerable<ArticlePhotoScalarWhereInput>
    NOT?: Enumerable<ArticlePhotoScalarWhereInput>
    id?: StringFilter | string
    photoUrl?: StringFilter | string
    status?: EnumArticlePhotoStatusNullableFilter | ArticlePhotoStatus | null
    articleId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type PostUpsertWithWhereUniqueWithoutArticleInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutArticleInput, PostUncheckedUpdateWithoutArticleInput>
    create: XOR<PostCreateWithoutArticleInput, PostUncheckedCreateWithoutArticleInput>
  }

  export type PostUpdateWithWhereUniqueWithoutArticleInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutArticleInput, PostUncheckedUpdateWithoutArticleInput>
  }

  export type PostUpdateManyWithWhereWithoutArticleInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutPostInput>
  }

  export type PostScalarWhereInput = {
    AND?: Enumerable<PostScalarWhereInput>
    OR?: Enumerable<PostScalarWhereInput>
    NOT?: Enumerable<PostScalarWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    content?: StringFilter | string
    postUrl?: StringFilter | string
    articleId?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type PriceUpsertWithoutArticleInput = {
    update: XOR<PriceUpdateWithoutArticleInput, PriceUncheckedUpdateWithoutArticleInput>
    create: XOR<PriceCreateWithoutArticleInput, PriceUncheckedCreateWithoutArticleInput>
  }

  export type PriceUpdateWithoutArticleInput = {
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    oldPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    reduction?: NullableFloatFieldUpdateOperationsInput | number | null
    sellingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PriceUncheckedUpdateWithoutArticleInput = {
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    currentPrice?: FloatFieldUpdateOperationsInput | number
    oldPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    reduction?: NullableFloatFieldUpdateOperationsInput | number | null
    sellingPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxArticleUpsertWithWhereUniqueWithoutArticleInput = {
    where: BoxArticleWhereUniqueInput
    update: XOR<BoxArticleUpdateWithoutArticleInput, BoxArticleUncheckedUpdateWithoutArticleInput>
    create: XOR<BoxArticleCreateWithoutArticleInput, BoxArticleUncheckedCreateWithoutArticleInput>
  }

  export type BoxArticleUpdateWithWhereUniqueWithoutArticleInput = {
    where: BoxArticleWhereUniqueInput
    data: XOR<BoxArticleUpdateWithoutArticleInput, BoxArticleUncheckedUpdateWithoutArticleInput>
  }

  export type BoxArticleUpdateManyWithWhereWithoutArticleInput = {
    where: BoxArticleScalarWhereInput
    data: XOR<BoxArticleUpdateManyMutationInput, BoxArticleUncheckedUpdateManyWithoutBoxArticleInput>
  }

  export type GameUpsertWithWhereUniqueWithoutArticleInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutArticleInput, GameUncheckedUpdateWithoutArticleInput>
    create: XOR<GameCreateWithoutArticleInput, GameUncheckedCreateWithoutArticleInput>
  }

  export type GameUpdateWithWhereUniqueWithoutArticleInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutArticleInput, GameUncheckedUpdateWithoutArticleInput>
  }

  export type GameUpdateManyWithWhereWithoutArticleInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutGameInput>
  }

  export type BoxCreateWithoutBoxArticleInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    boxImage?: BoxImageCreateNestedManyWithoutBoxInput
    article?: ArticleCreateNestedManyWithoutBoxInput
    transaction?: TransactionCreateNestedManyWithoutBoxInput
    userBox?: UserBoxCreateNestedManyWithoutBoxInput
    bannerImage?: BannerImageCreateNestedManyWithoutBoxInput
    boxParams?: BoxParamsCreateNestedOneWithoutBoxInput
    boxType?: BoxTypeCreateNestedOneWithoutBoxInput
    dailyReward?: DailyRewardCreateNestedManyWithoutBoxInput
    boxRewardLevel?: BoxRewardLevelCreateNestedManyWithoutBoxInput
  }

  export type BoxUncheckedCreateWithoutBoxArticleInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    boxTypeId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    boxImage?: BoxImageUncheckedCreateNestedManyWithoutBoxInput
    article?: ArticleUncheckedCreateNestedManyWithoutBoxInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutBoxInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutBoxInput
    bannerImage?: BannerImageUncheckedCreateNestedManyWithoutBoxInput
    boxParams?: BoxParamsUncheckedCreateNestedOneWithoutBoxInput
    dailyReward?: DailyRewardUncheckedCreateNestedManyWithoutBoxInput
    boxRewardLevel?: BoxRewardLevelUncheckedCreateNestedManyWithoutBoxInput
  }

  export type BoxCreateOrConnectWithoutBoxArticleInput = {
    where: BoxWhereUniqueInput
    create: XOR<BoxCreateWithoutBoxArticleInput, BoxUncheckedCreateWithoutBoxArticleInput>
  }

  export type ArticleCreateWithoutBoxArticleInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    provider?: ProviderCreateNestedOneWithoutArticleInput
    unitySize?: UnitySizeCreateNestedOneWithoutArticleInput
    subCategory?: SubCategoryCreateNestedOneWithoutArticleInput
    box?: BoxCreateNestedOneWithoutArticleInput
    articlePhoto?: ArticlePhotoCreateNestedManyWithoutArticleInput
    post?: PostCreateNestedManyWithoutArticleInput
    price?: PriceCreateNestedOneWithoutArticleInput
    game?: GameCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutBoxArticleInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    providerId?: string | null
    unitySizeId?: string | null
    subCategoryId: string
    boxId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    articlePhoto?: ArticlePhotoUncheckedCreateNestedManyWithoutArticleInput
    post?: PostUncheckedCreateNestedManyWithoutArticleInput
    price?: PriceUncheckedCreateNestedOneWithoutArticleInput
    game?: GameUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutBoxArticleInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutBoxArticleInput, ArticleUncheckedCreateWithoutBoxArticleInput>
  }

  export type BoxUpsertWithoutBoxArticleInput = {
    update: XOR<BoxUpdateWithoutBoxArticleInput, BoxUncheckedUpdateWithoutBoxArticleInput>
    create: XOR<BoxCreateWithoutBoxArticleInput, BoxUncheckedCreateWithoutBoxArticleInput>
  }

  export type BoxUpdateWithoutBoxArticleInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    boxImage?: BoxImageUpdateManyWithoutBoxNestedInput
    article?: ArticleUpdateManyWithoutBoxNestedInput
    transaction?: TransactionUpdateManyWithoutBoxNestedInput
    userBox?: UserBoxUpdateManyWithoutBoxNestedInput
    bannerImage?: BannerImageUpdateManyWithoutBoxNestedInput
    boxParams?: BoxParamsUpdateOneWithoutBoxNestedInput
    boxType?: BoxTypeUpdateOneWithoutBoxNestedInput
    dailyReward?: DailyRewardUpdateManyWithoutBoxNestedInput
    boxRewardLevel?: BoxRewardLevelUpdateManyWithoutBoxNestedInput
  }

  export type BoxUncheckedUpdateWithoutBoxArticleInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    boxTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    boxImage?: BoxImageUncheckedUpdateManyWithoutBoxNestedInput
    article?: ArticleUncheckedUpdateManyWithoutBoxNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutBoxNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutBoxNestedInput
    bannerImage?: BannerImageUncheckedUpdateManyWithoutBoxNestedInput
    boxParams?: BoxParamsUncheckedUpdateOneWithoutBoxNestedInput
    dailyReward?: DailyRewardUncheckedUpdateManyWithoutBoxNestedInput
    boxRewardLevel?: BoxRewardLevelUncheckedUpdateManyWithoutBoxNestedInput
  }

  export type ArticleUpsertWithoutBoxArticleInput = {
    update: XOR<ArticleUpdateWithoutBoxArticleInput, ArticleUncheckedUpdateWithoutBoxArticleInput>
    create: XOR<ArticleCreateWithoutBoxArticleInput, ArticleUncheckedCreateWithoutBoxArticleInput>
  }

  export type ArticleUpdateWithoutBoxArticleInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: ProviderUpdateOneWithoutArticleNestedInput
    unitySize?: UnitySizeUpdateOneWithoutArticleNestedInput
    subCategory?: SubCategoryUpdateOneWithoutArticleNestedInput
    box?: BoxUpdateOneWithoutArticleNestedInput
    articlePhoto?: ArticlePhotoUpdateManyWithoutArticleNestedInput
    post?: PostUpdateManyWithoutArticleNestedInput
    price?: PriceUpdateOneWithoutArticleNestedInput
    game?: GameUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutBoxArticleInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    unitySizeId?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: StringFieldUpdateOperationsInput | string
    boxId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    articlePhoto?: ArticlePhotoUncheckedUpdateManyWithoutArticleNestedInput
    post?: PostUncheckedUpdateManyWithoutArticleNestedInput
    price?: PriceUncheckedUpdateOneWithoutArticleNestedInput
    game?: GameUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleCreateWithoutArticlePhotoInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    provider?: ProviderCreateNestedOneWithoutArticleInput
    unitySize?: UnitySizeCreateNestedOneWithoutArticleInput
    subCategory?: SubCategoryCreateNestedOneWithoutArticleInput
    box?: BoxCreateNestedOneWithoutArticleInput
    post?: PostCreateNestedManyWithoutArticleInput
    price?: PriceCreateNestedOneWithoutArticleInput
    boxArticle?: BoxArticleCreateNestedManyWithoutArticleInput
    game?: GameCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutArticlePhotoInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    providerId?: string | null
    unitySizeId?: string | null
    subCategoryId: string
    boxId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    post?: PostUncheckedCreateNestedManyWithoutArticleInput
    price?: PriceUncheckedCreateNestedOneWithoutArticleInput
    boxArticle?: BoxArticleUncheckedCreateNestedManyWithoutArticleInput
    game?: GameUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutArticlePhotoInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutArticlePhotoInput, ArticleUncheckedCreateWithoutArticlePhotoInput>
  }

  export type ArticleUpsertWithoutArticlePhotoInput = {
    update: XOR<ArticleUpdateWithoutArticlePhotoInput, ArticleUncheckedUpdateWithoutArticlePhotoInput>
    create: XOR<ArticleCreateWithoutArticlePhotoInput, ArticleUncheckedCreateWithoutArticlePhotoInput>
  }

  export type ArticleUpdateWithoutArticlePhotoInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: ProviderUpdateOneWithoutArticleNestedInput
    unitySize?: UnitySizeUpdateOneWithoutArticleNestedInput
    subCategory?: SubCategoryUpdateOneWithoutArticleNestedInput
    box?: BoxUpdateOneWithoutArticleNestedInput
    post?: PostUpdateManyWithoutArticleNestedInput
    price?: PriceUpdateOneWithoutArticleNestedInput
    boxArticle?: BoxArticleUpdateManyWithoutArticleNestedInput
    game?: GameUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutArticlePhotoInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    unitySizeId?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: StringFieldUpdateOperationsInput | string
    boxId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post?: PostUncheckedUpdateManyWithoutArticleNestedInput
    price?: PriceUncheckedUpdateOneWithoutArticleNestedInput
    boxArticle?: BoxArticleUncheckedUpdateManyWithoutArticleNestedInput
    game?: GameUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleCreateWithoutPostInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    provider?: ProviderCreateNestedOneWithoutArticleInput
    unitySize?: UnitySizeCreateNestedOneWithoutArticleInput
    subCategory?: SubCategoryCreateNestedOneWithoutArticleInput
    box?: BoxCreateNestedOneWithoutArticleInput
    articlePhoto?: ArticlePhotoCreateNestedManyWithoutArticleInput
    price?: PriceCreateNestedOneWithoutArticleInput
    boxArticle?: BoxArticleCreateNestedManyWithoutArticleInput
    game?: GameCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutPostInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    providerId?: string | null
    unitySizeId?: string | null
    subCategoryId: string
    boxId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    articlePhoto?: ArticlePhotoUncheckedCreateNestedManyWithoutArticleInput
    price?: PriceUncheckedCreateNestedOneWithoutArticleInput
    boxArticle?: BoxArticleUncheckedCreateNestedManyWithoutArticleInput
    game?: GameUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutPostInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutPostInput, ArticleUncheckedCreateWithoutPostInput>
  }

  export type ArticleUpsertWithoutPostInput = {
    update: XOR<ArticleUpdateWithoutPostInput, ArticleUncheckedUpdateWithoutPostInput>
    create: XOR<ArticleCreateWithoutPostInput, ArticleUncheckedCreateWithoutPostInput>
  }

  export type ArticleUpdateWithoutPostInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: ProviderUpdateOneWithoutArticleNestedInput
    unitySize?: UnitySizeUpdateOneWithoutArticleNestedInput
    subCategory?: SubCategoryUpdateOneWithoutArticleNestedInput
    box?: BoxUpdateOneWithoutArticleNestedInput
    articlePhoto?: ArticlePhotoUpdateManyWithoutArticleNestedInput
    price?: PriceUpdateOneWithoutArticleNestedInput
    boxArticle?: BoxArticleUpdateManyWithoutArticleNestedInput
    game?: GameUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutPostInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    unitySizeId?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: StringFieldUpdateOperationsInput | string
    boxId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    articlePhoto?: ArticlePhotoUncheckedUpdateManyWithoutArticleNestedInput
    price?: PriceUncheckedUpdateOneWithoutArticleNestedInput
    boxArticle?: BoxArticleUncheckedUpdateManyWithoutArticleNestedInput
    game?: GameUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleCreateWithoutPriceInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    provider?: ProviderCreateNestedOneWithoutArticleInput
    unitySize?: UnitySizeCreateNestedOneWithoutArticleInput
    subCategory?: SubCategoryCreateNestedOneWithoutArticleInput
    box?: BoxCreateNestedOneWithoutArticleInput
    articlePhoto?: ArticlePhotoCreateNestedManyWithoutArticleInput
    post?: PostCreateNestedManyWithoutArticleInput
    boxArticle?: BoxArticleCreateNestedManyWithoutArticleInput
    game?: GameCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutPriceInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    providerId?: string | null
    unitySizeId?: string | null
    subCategoryId: string
    boxId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    articlePhoto?: ArticlePhotoUncheckedCreateNestedManyWithoutArticleInput
    post?: PostUncheckedCreateNestedManyWithoutArticleInput
    boxArticle?: BoxArticleUncheckedCreateNestedManyWithoutArticleInput
    game?: GameUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutPriceInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutPriceInput, ArticleUncheckedCreateWithoutPriceInput>
  }

  export type ArticleUpsertWithoutPriceInput = {
    update: XOR<ArticleUpdateWithoutPriceInput, ArticleUncheckedUpdateWithoutPriceInput>
    create: XOR<ArticleCreateWithoutPriceInput, ArticleUncheckedCreateWithoutPriceInput>
  }

  export type ArticleUpdateWithoutPriceInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: ProviderUpdateOneWithoutArticleNestedInput
    unitySize?: UnitySizeUpdateOneWithoutArticleNestedInput
    subCategory?: SubCategoryUpdateOneWithoutArticleNestedInput
    box?: BoxUpdateOneWithoutArticleNestedInput
    articlePhoto?: ArticlePhotoUpdateManyWithoutArticleNestedInput
    post?: PostUpdateManyWithoutArticleNestedInput
    boxArticle?: BoxArticleUpdateManyWithoutArticleNestedInput
    game?: GameUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutPriceInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    unitySizeId?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: StringFieldUpdateOperationsInput | string
    boxId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    articlePhoto?: ArticlePhotoUncheckedUpdateManyWithoutArticleNestedInput
    post?: PostUncheckedUpdateManyWithoutArticleNestedInput
    boxArticle?: BoxArticleUncheckedUpdateManyWithoutArticleNestedInput
    game?: GameUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ShoppingCartCreateWithoutOrderInput = {
    id?: string
    winningDate: Date | string
    isClaimed?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    game: GameCreateNestedOneWithoutShoppingCartInput
    user: UserCreateNestedOneWithoutShoppingCartInput
    transaction?: TransactionCreateNestedManyWithoutShoppingCartInput
  }

  export type ShoppingCartUncheckedCreateWithoutOrderInput = {
    id?: string
    winningDate: Date | string
    isClaimed?: boolean | null
    gameId: string
    userId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    transaction?: TransactionUncheckedCreateNestedManyWithoutShoppingCartInput
  }

  export type ShoppingCartCreateOrConnectWithoutOrderInput = {
    where: ShoppingCartWhereUniqueInput
    create: XOR<ShoppingCartCreateWithoutOrderInput, ShoppingCartUncheckedCreateWithoutOrderInput>
  }

  export type ShoppingCartUpsertWithoutOrderInput = {
    update: XOR<ShoppingCartUpdateWithoutOrderInput, ShoppingCartUncheckedUpdateWithoutOrderInput>
    create: XOR<ShoppingCartCreateWithoutOrderInput, ShoppingCartUncheckedCreateWithoutOrderInput>
  }

  export type ShoppingCartUpdateWithoutOrderInput = {
    winningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    game?: GameUpdateOneRequiredWithoutShoppingCartNestedInput
    user?: UserUpdateOneRequiredWithoutShoppingCartNestedInput
    transaction?: TransactionUpdateManyWithoutShoppingCartNestedInput
  }

  export type ShoppingCartUncheckedUpdateWithoutOrderInput = {
    winningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction?: TransactionUncheckedUpdateManyWithoutShoppingCartNestedInput
  }

  export type GameCreateWithoutShoppingCartInput = {
    id?: string
    reference: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: EnumStatusGame
    version?: EnumVersionGame | null
    type?: EnumTypeGame | null
    gainPercentage?: number | null
    gainDraw?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    userBox?: UserBoxCreateNestedOneWithoutGameInput
    patronage?: PatronageCreateNestedOneWithoutGameInput
    article?: ArticleCreateNestedOneWithoutGameInput
    transaction?: TransactionCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutShoppingCartInput = {
    id?: string
    reference: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: EnumStatusGame
    version?: EnumVersionGame | null
    type?: EnumTypeGame | null
    userBoxId?: string | null
    patronageId?: string | null
    gainPercentage?: number | null
    gainDraw?: number | null
    articleId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    transaction?: TransactionUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutShoppingCartInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutShoppingCartInput, GameUncheckedCreateWithoutShoppingCartInput>
  }

  export type UserCreateWithoutShoppingCartInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeCustomerId?: string | null
    rule?: RuleCreateNestedOneWithoutUserInput
    address?: AddressCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    userBox?: UserBoxCreateNestedManyWithoutUserInput
    historical?: HistoricalCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    receiver?: ReceiverCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedManyWithoutUserInput
    patronage?: PatronageCreateNestedManyWithoutUserParentInput
    userChild?: PatronageCreateNestedOneWithoutUserChildInput
  }

  export type UserUncheckedCreateWithoutShoppingCartInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ruleId?: string | null
    stripeCustomerId?: string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutUserInput
    historical?: HistoricalUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receiver?: ReceiverUncheckedCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    patronage?: PatronageUncheckedCreateNestedManyWithoutUserParentInput
    userChild?: PatronageUncheckedCreateNestedOneWithoutUserChildInput
  }

  export type UserCreateOrConnectWithoutShoppingCartInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShoppingCartInput, UserUncheckedCreateWithoutShoppingCartInput>
  }

  export type TransactionCreateWithoutShoppingCartInput = {
    id?: string
    type: EnumTypeTransaction
    date: Date | string
    amount: number
    status: EnumStatusTransaction
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    box?: BoxCreateNestedOneWithoutTransactionInput
    wallet: WalletCreateNestedOneWithoutTransactionInput
    offer?: OfferCreateNestedOneWithoutTransactionInput
    bank?: BankCreateNestedOneWithoutTransactionInput
    game?: GameCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutShoppingCartInput = {
    id?: string
    type: EnumTypeTransaction
    date: Date | string
    amount: number
    status: EnumStatusTransaction
    boxId?: string | null
    walletId: string
    offerId?: string | null
    bankId?: string | null
    gameId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TransactionCreateOrConnectWithoutShoppingCartInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutShoppingCartInput, TransactionUncheckedCreateWithoutShoppingCartInput>
  }

  export type TransactionCreateManyShoppingCartInputEnvelope = {
    data: Enumerable<TransactionCreateManyShoppingCartInput>
  }

  export type OrderCreateWithoutShoppingCartInput = {
    id?: string
    status?: EnumOrderStatus
    followedLink?: string | null
    orderNumber?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrderUncheckedCreateWithoutShoppingCartInput = {
    id?: string
    status?: EnumOrderStatus
    followedLink?: string | null
    orderNumber?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type OrderCreateOrConnectWithoutShoppingCartInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutShoppingCartInput, OrderUncheckedCreateWithoutShoppingCartInput>
  }

  export type GameUpsertWithoutShoppingCartInput = {
    update: XOR<GameUpdateWithoutShoppingCartInput, GameUncheckedUpdateWithoutShoppingCartInput>
    create: XOR<GameCreateWithoutShoppingCartInput, GameUncheckedCreateWithoutShoppingCartInput>
  }

  export type GameUpdateWithoutShoppingCartInput = {
    reference?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEnumStatusGameFieldUpdateOperationsInput | EnumStatusGame
    version?: NullableEnumEnumVersionGameFieldUpdateOperationsInput | EnumVersionGame | null
    type?: NullableEnumEnumTypeGameFieldUpdateOperationsInput | EnumTypeGame | null
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gainDraw?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userBox?: UserBoxUpdateOneWithoutGameNestedInput
    patronage?: PatronageUpdateOneWithoutGameNestedInput
    article?: ArticleUpdateOneWithoutGameNestedInput
    transaction?: TransactionUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutShoppingCartInput = {
    reference?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEnumStatusGameFieldUpdateOperationsInput | EnumStatusGame
    version?: NullableEnumEnumVersionGameFieldUpdateOperationsInput | EnumVersionGame | null
    type?: NullableEnumEnumTypeGameFieldUpdateOperationsInput | EnumTypeGame | null
    userBoxId?: NullableStringFieldUpdateOperationsInput | string | null
    patronageId?: NullableStringFieldUpdateOperationsInput | string | null
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gainDraw?: NullableFloatFieldUpdateOperationsInput | number | null
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction?: TransactionUncheckedUpdateManyWithoutGameNestedInput
  }

  export type UserUpsertWithoutShoppingCartInput = {
    update: XOR<UserUpdateWithoutShoppingCartInput, UserUncheckedUpdateWithoutShoppingCartInput>
    create: XOR<UserCreateWithoutShoppingCartInput, UserUncheckedCreateWithoutShoppingCartInput>
  }

  export type UserUpdateWithoutShoppingCartInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    rule?: RuleUpdateOneWithoutUserNestedInput
    address?: AddressUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    userBox?: UserBoxUpdateManyWithoutUserNestedInput
    historical?: HistoricalUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    patronage?: PatronageUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUpdateOneWithoutUserChildNestedInput
  }

  export type UserUncheckedUpdateWithoutShoppingCartInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ruleId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutUserNestedInput
    historical?: HistoricalUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUncheckedUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    patronage?: PatronageUncheckedUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUncheckedUpdateOneWithoutUserChildNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutShoppingCartInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutShoppingCartInput, TransactionUncheckedUpdateWithoutShoppingCartInput>
    create: XOR<TransactionCreateWithoutShoppingCartInput, TransactionUncheckedCreateWithoutShoppingCartInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutShoppingCartInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutShoppingCartInput, TransactionUncheckedUpdateWithoutShoppingCartInput>
  }

  export type TransactionUpdateManyWithWhereWithoutShoppingCartInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTransactionInput>
  }

  export type OrderUpsertWithoutShoppingCartInput = {
    update: XOR<OrderUpdateWithoutShoppingCartInput, OrderUncheckedUpdateWithoutShoppingCartInput>
    create: XOR<OrderCreateWithoutShoppingCartInput, OrderUncheckedCreateWithoutShoppingCartInput>
  }

  export type OrderUpdateWithoutShoppingCartInput = {
    status?: EnumEnumOrderStatusFieldUpdateOperationsInput | EnumOrderStatus
    followedLink?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderUncheckedUpdateWithoutShoppingCartInput = {
    status?: EnumEnumOrderStatusFieldUpdateOperationsInput | EnumOrderStatus
    followedLink?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxCreateWithoutTransactionInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    boxImage?: BoxImageCreateNestedManyWithoutBoxInput
    article?: ArticleCreateNestedManyWithoutBoxInput
    userBox?: UserBoxCreateNestedManyWithoutBoxInput
    bannerImage?: BannerImageCreateNestedManyWithoutBoxInput
    boxParams?: BoxParamsCreateNestedOneWithoutBoxInput
    boxType?: BoxTypeCreateNestedOneWithoutBoxInput
    boxArticle?: BoxArticleCreateNestedManyWithoutBoxInput
    dailyReward?: DailyRewardCreateNestedManyWithoutBoxInput
    boxRewardLevel?: BoxRewardLevelCreateNestedManyWithoutBoxInput
  }

  export type BoxUncheckedCreateWithoutTransactionInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    boxTypeId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    boxImage?: BoxImageUncheckedCreateNestedManyWithoutBoxInput
    article?: ArticleUncheckedCreateNestedManyWithoutBoxInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutBoxInput
    bannerImage?: BannerImageUncheckedCreateNestedManyWithoutBoxInput
    boxParams?: BoxParamsUncheckedCreateNestedOneWithoutBoxInput
    boxArticle?: BoxArticleUncheckedCreateNestedManyWithoutBoxInput
    dailyReward?: DailyRewardUncheckedCreateNestedManyWithoutBoxInput
    boxRewardLevel?: BoxRewardLevelUncheckedCreateNestedManyWithoutBoxInput
  }

  export type BoxCreateOrConnectWithoutTransactionInput = {
    where: BoxWhereUniqueInput
    create: XOR<BoxCreateWithoutTransactionInput, BoxUncheckedCreateWithoutTransactionInput>
  }

  export type WalletCreateWithoutTransactionInput = {
    id?: string
    balance: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutTransactionInput = {
    id?: string
    balance: number
    userId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type WalletCreateOrConnectWithoutTransactionInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutTransactionInput, WalletUncheckedCreateWithoutTransactionInput>
  }

  export type OfferCreateWithoutTransactionInput = {
    id?: string
    name: string
    price: number
    priceThreeMonth?: number | null
    color?: string | null
    numberMysteryBoxBronze?: number
    numberMysteryBoxSylver?: number
    numberMysteryBoxGold?: number
    isAwardLevelActive?: boolean
    isWeeklyAwardActive?: boolean
    isStandardSupportActive?: boolean
    isVIPSupportActive?: boolean
    duration?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    subscription?: SubscriptionCreateNestedManyWithoutOfferInput
    bannerImage?: BannerImageCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutTransactionInput = {
    id?: string
    name: string
    price: number
    priceThreeMonth?: number | null
    color?: string | null
    numberMysteryBoxBronze?: number
    numberMysteryBoxSylver?: number
    numberMysteryBoxGold?: number
    isAwardLevelActive?: boolean
    isWeeklyAwardActive?: boolean
    isStandardSupportActive?: boolean
    isVIPSupportActive?: boolean
    duration?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutOfferInput
    bannerImage?: BannerImageUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutTransactionInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutTransactionInput, OfferUncheckedCreateWithoutTransactionInput>
  }

  export type ShoppingCartCreateWithoutTransactionInput = {
    id?: string
    winningDate: Date | string
    isClaimed?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    game: GameCreateNestedOneWithoutShoppingCartInput
    user: UserCreateNestedOneWithoutShoppingCartInput
    order?: OrderCreateNestedOneWithoutShoppingCartInput
  }

  export type ShoppingCartUncheckedCreateWithoutTransactionInput = {
    id?: string
    winningDate: Date | string
    isClaimed?: boolean | null
    gameId: string
    userId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    order?: OrderUncheckedCreateNestedOneWithoutShoppingCartInput
  }

  export type ShoppingCartCreateOrConnectWithoutTransactionInput = {
    where: ShoppingCartWhereUniqueInput
    create: XOR<ShoppingCartCreateWithoutTransactionInput, ShoppingCartUncheckedCreateWithoutTransactionInput>
  }

  export type BankCreateWithoutTransactionInput = {
    id?: string
    accountNumber: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BankUncheckedCreateWithoutTransactionInput = {
    id?: string
    accountNumber: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BankCreateOrConnectWithoutTransactionInput = {
    where: BankWhereUniqueInput
    create: XOR<BankCreateWithoutTransactionInput, BankUncheckedCreateWithoutTransactionInput>
  }

  export type GameCreateWithoutTransactionInput = {
    id?: string
    reference: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: EnumStatusGame
    version?: EnumVersionGame | null
    type?: EnumTypeGame | null
    gainPercentage?: number | null
    gainDraw?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    userBox?: UserBoxCreateNestedOneWithoutGameInput
    patronage?: PatronageCreateNestedOneWithoutGameInput
    article?: ArticleCreateNestedOneWithoutGameInput
    shoppingCart?: ShoppingCartCreateNestedOneWithoutGameInput
  }

  export type GameUncheckedCreateWithoutTransactionInput = {
    id?: string
    reference: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: EnumStatusGame
    version?: EnumVersionGame | null
    type?: EnumTypeGame | null
    userBoxId?: string | null
    patronageId?: string | null
    gainPercentage?: number | null
    gainDraw?: number | null
    articleId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    shoppingCart?: ShoppingCartUncheckedCreateNestedOneWithoutGameInput
  }

  export type GameCreateOrConnectWithoutTransactionInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutTransactionInput, GameUncheckedCreateWithoutTransactionInput>
  }

  export type BoxUpsertWithoutTransactionInput = {
    update: XOR<BoxUpdateWithoutTransactionInput, BoxUncheckedUpdateWithoutTransactionInput>
    create: XOR<BoxCreateWithoutTransactionInput, BoxUncheckedCreateWithoutTransactionInput>
  }

  export type BoxUpdateWithoutTransactionInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    boxImage?: BoxImageUpdateManyWithoutBoxNestedInput
    article?: ArticleUpdateManyWithoutBoxNestedInput
    userBox?: UserBoxUpdateManyWithoutBoxNestedInput
    bannerImage?: BannerImageUpdateManyWithoutBoxNestedInput
    boxParams?: BoxParamsUpdateOneWithoutBoxNestedInput
    boxType?: BoxTypeUpdateOneWithoutBoxNestedInput
    boxArticle?: BoxArticleUpdateManyWithoutBoxNestedInput
    dailyReward?: DailyRewardUpdateManyWithoutBoxNestedInput
    boxRewardLevel?: BoxRewardLevelUpdateManyWithoutBoxNestedInput
  }

  export type BoxUncheckedUpdateWithoutTransactionInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    boxTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    boxImage?: BoxImageUncheckedUpdateManyWithoutBoxNestedInput
    article?: ArticleUncheckedUpdateManyWithoutBoxNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutBoxNestedInput
    bannerImage?: BannerImageUncheckedUpdateManyWithoutBoxNestedInput
    boxParams?: BoxParamsUncheckedUpdateOneWithoutBoxNestedInput
    boxArticle?: BoxArticleUncheckedUpdateManyWithoutBoxNestedInput
    dailyReward?: DailyRewardUncheckedUpdateManyWithoutBoxNestedInput
    boxRewardLevel?: BoxRewardLevelUncheckedUpdateManyWithoutBoxNestedInput
  }

  export type WalletUpsertWithoutTransactionInput = {
    update: XOR<WalletUpdateWithoutTransactionInput, WalletUncheckedUpdateWithoutTransactionInput>
    create: XOR<WalletCreateWithoutTransactionInput, WalletUncheckedCreateWithoutTransactionInput>
  }

  export type WalletUpdateWithoutTransactionInput = {
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateWithoutTransactionInput = {
    balance?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OfferUpsertWithoutTransactionInput = {
    update: XOR<OfferUpdateWithoutTransactionInput, OfferUncheckedUpdateWithoutTransactionInput>
    create: XOR<OfferCreateWithoutTransactionInput, OfferUncheckedCreateWithoutTransactionInput>
  }

  export type OfferUpdateWithoutTransactionInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceThreeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    numberMysteryBoxBronze?: IntFieldUpdateOperationsInput | number
    numberMysteryBoxSylver?: IntFieldUpdateOperationsInput | number
    numberMysteryBoxGold?: IntFieldUpdateOperationsInput | number
    isAwardLevelActive?: BoolFieldUpdateOperationsInput | boolean
    isWeeklyAwardActive?: BoolFieldUpdateOperationsInput | boolean
    isStandardSupportActive?: BoolFieldUpdateOperationsInput | boolean
    isVIPSupportActive?: BoolFieldUpdateOperationsInput | boolean
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription?: SubscriptionUpdateManyWithoutOfferNestedInput
    bannerImage?: BannerImageUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateWithoutTransactionInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceThreeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    numberMysteryBoxBronze?: IntFieldUpdateOperationsInput | number
    numberMysteryBoxSylver?: IntFieldUpdateOperationsInput | number
    numberMysteryBoxGold?: IntFieldUpdateOperationsInput | number
    isAwardLevelActive?: BoolFieldUpdateOperationsInput | boolean
    isWeeklyAwardActive?: BoolFieldUpdateOperationsInput | boolean
    isStandardSupportActive?: BoolFieldUpdateOperationsInput | boolean
    isVIPSupportActive?: BoolFieldUpdateOperationsInput | boolean
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutOfferNestedInput
    bannerImage?: BannerImageUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type ShoppingCartUpsertWithoutTransactionInput = {
    update: XOR<ShoppingCartUpdateWithoutTransactionInput, ShoppingCartUncheckedUpdateWithoutTransactionInput>
    create: XOR<ShoppingCartCreateWithoutTransactionInput, ShoppingCartUncheckedCreateWithoutTransactionInput>
  }

  export type ShoppingCartUpdateWithoutTransactionInput = {
    winningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    game?: GameUpdateOneRequiredWithoutShoppingCartNestedInput
    user?: UserUpdateOneRequiredWithoutShoppingCartNestedInput
    order?: OrderUpdateOneWithoutShoppingCartNestedInput
  }

  export type ShoppingCartUncheckedUpdateWithoutTransactionInput = {
    winningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: OrderUncheckedUpdateOneWithoutShoppingCartNestedInput
  }

  export type BankUpsertWithoutTransactionInput = {
    update: XOR<BankUpdateWithoutTransactionInput, BankUncheckedUpdateWithoutTransactionInput>
    create: XOR<BankCreateWithoutTransactionInput, BankUncheckedCreateWithoutTransactionInput>
  }

  export type BankUpdateWithoutTransactionInput = {
    accountNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BankUncheckedUpdateWithoutTransactionInput = {
    accountNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameUpsertWithoutTransactionInput = {
    update: XOR<GameUpdateWithoutTransactionInput, GameUncheckedUpdateWithoutTransactionInput>
    create: XOR<GameCreateWithoutTransactionInput, GameUncheckedCreateWithoutTransactionInput>
  }

  export type GameUpdateWithoutTransactionInput = {
    reference?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEnumStatusGameFieldUpdateOperationsInput | EnumStatusGame
    version?: NullableEnumEnumVersionGameFieldUpdateOperationsInput | EnumVersionGame | null
    type?: NullableEnumEnumTypeGameFieldUpdateOperationsInput | EnumTypeGame | null
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gainDraw?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userBox?: UserBoxUpdateOneWithoutGameNestedInput
    patronage?: PatronageUpdateOneWithoutGameNestedInput
    article?: ArticleUpdateOneWithoutGameNestedInput
    shoppingCart?: ShoppingCartUpdateOneWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutTransactionInput = {
    reference?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEnumStatusGameFieldUpdateOperationsInput | EnumStatusGame
    version?: NullableEnumEnumVersionGameFieldUpdateOperationsInput | EnumVersionGame | null
    type?: NullableEnumEnumTypeGameFieldUpdateOperationsInput | EnumTypeGame | null
    userBoxId?: NullableStringFieldUpdateOperationsInput | string | null
    patronageId?: NullableStringFieldUpdateOperationsInput | string | null
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gainDraw?: NullableFloatFieldUpdateOperationsInput | number | null
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shoppingCart?: ShoppingCartUncheckedUpdateOneWithoutGameNestedInput
  }

  export type TransactionCreateWithoutBankInput = {
    id?: string
    type: EnumTypeTransaction
    date: Date | string
    amount: number
    status: EnumStatusTransaction
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    box?: BoxCreateNestedOneWithoutTransactionInput
    wallet: WalletCreateNestedOneWithoutTransactionInput
    offer?: OfferCreateNestedOneWithoutTransactionInput
    shoppingCart?: ShoppingCartCreateNestedOneWithoutTransactionInput
    game?: GameCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutBankInput = {
    id?: string
    type: EnumTypeTransaction
    date: Date | string
    amount: number
    status: EnumStatusTransaction
    boxId?: string | null
    walletId: string
    offerId?: string | null
    shoppingCartId?: string | null
    gameId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TransactionCreateOrConnectWithoutBankInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutBankInput, TransactionUncheckedCreateWithoutBankInput>
  }

  export type TransactionCreateManyBankInputEnvelope = {
    data: Enumerable<TransactionCreateManyBankInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutBankInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutBankInput, TransactionUncheckedUpdateWithoutBankInput>
    create: XOR<TransactionCreateWithoutBankInput, TransactionUncheckedCreateWithoutBankInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutBankInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutBankInput, TransactionUncheckedUpdateWithoutBankInput>
  }

  export type TransactionUpdateManyWithWhereWithoutBankInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTransactionInput>
  }

  export type UserCreateWithoutUserBoxInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeCustomerId?: string | null
    rule?: RuleCreateNestedOneWithoutUserInput
    address?: AddressCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartCreateNestedManyWithoutUserInput
    historical?: HistoricalCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    receiver?: ReceiverCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedManyWithoutUserInput
    patronage?: PatronageCreateNestedManyWithoutUserParentInput
    userChild?: PatronageCreateNestedOneWithoutUserChildInput
  }

  export type UserUncheckedCreateWithoutUserBoxInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ruleId?: string | null
    stripeCustomerId?: string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUserInput
    historical?: HistoricalUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receiver?: ReceiverUncheckedCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    patronage?: PatronageUncheckedCreateNestedManyWithoutUserParentInput
    userChild?: PatronageUncheckedCreateNestedOneWithoutUserChildInput
  }

  export type UserCreateOrConnectWithoutUserBoxInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserBoxInput, UserUncheckedCreateWithoutUserBoxInput>
  }

  export type BoxCreateWithoutUserBoxInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    boxImage?: BoxImageCreateNestedManyWithoutBoxInput
    article?: ArticleCreateNestedManyWithoutBoxInput
    transaction?: TransactionCreateNestedManyWithoutBoxInput
    bannerImage?: BannerImageCreateNestedManyWithoutBoxInput
    boxParams?: BoxParamsCreateNestedOneWithoutBoxInput
    boxType?: BoxTypeCreateNestedOneWithoutBoxInput
    boxArticle?: BoxArticleCreateNestedManyWithoutBoxInput
    dailyReward?: DailyRewardCreateNestedManyWithoutBoxInput
    boxRewardLevel?: BoxRewardLevelCreateNestedManyWithoutBoxInput
  }

  export type BoxUncheckedCreateWithoutUserBoxInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    boxTypeId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    boxImage?: BoxImageUncheckedCreateNestedManyWithoutBoxInput
    article?: ArticleUncheckedCreateNestedManyWithoutBoxInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutBoxInput
    bannerImage?: BannerImageUncheckedCreateNestedManyWithoutBoxInput
    boxParams?: BoxParamsUncheckedCreateNestedOneWithoutBoxInput
    boxArticle?: BoxArticleUncheckedCreateNestedManyWithoutBoxInput
    dailyReward?: DailyRewardUncheckedCreateNestedManyWithoutBoxInput
    boxRewardLevel?: BoxRewardLevelUncheckedCreateNestedManyWithoutBoxInput
  }

  export type BoxCreateOrConnectWithoutUserBoxInput = {
    where: BoxWhereUniqueInput
    create: XOR<BoxCreateWithoutUserBoxInput, BoxUncheckedCreateWithoutUserBoxInput>
  }

  export type GameCreateWithoutUserBoxInput = {
    id?: string
    reference: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: EnumStatusGame
    version?: EnumVersionGame | null
    type?: EnumTypeGame | null
    gainPercentage?: number | null
    gainDraw?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    patronage?: PatronageCreateNestedOneWithoutGameInput
    article?: ArticleCreateNestedOneWithoutGameInput
    shoppingCart?: ShoppingCartCreateNestedOneWithoutGameInput
    transaction?: TransactionCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutUserBoxInput = {
    id?: string
    reference: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: EnumStatusGame
    version?: EnumVersionGame | null
    type?: EnumTypeGame | null
    patronageId?: string | null
    gainPercentage?: number | null
    gainDraw?: number | null
    articleId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    shoppingCart?: ShoppingCartUncheckedCreateNestedOneWithoutGameInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutUserBoxInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutUserBoxInput, GameUncheckedCreateWithoutUserBoxInput>
  }

  export type GameCreateManyUserBoxInputEnvelope = {
    data: Enumerable<GameCreateManyUserBoxInput>
  }

  export type UserUpsertWithoutUserBoxInput = {
    update: XOR<UserUpdateWithoutUserBoxInput, UserUncheckedUpdateWithoutUserBoxInput>
    create: XOR<UserCreateWithoutUserBoxInput, UserUncheckedCreateWithoutUserBoxInput>
  }

  export type UserUpdateWithoutUserBoxInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    rule?: RuleUpdateOneWithoutUserNestedInput
    address?: AddressUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUpdateManyWithoutUserNestedInput
    historical?: HistoricalUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    patronage?: PatronageUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUpdateOneWithoutUserChildNestedInput
  }

  export type UserUncheckedUpdateWithoutUserBoxInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ruleId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUserNestedInput
    historical?: HistoricalUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUncheckedUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    patronage?: PatronageUncheckedUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUncheckedUpdateOneWithoutUserChildNestedInput
  }

  export type BoxUpsertWithoutUserBoxInput = {
    update: XOR<BoxUpdateWithoutUserBoxInput, BoxUncheckedUpdateWithoutUserBoxInput>
    create: XOR<BoxCreateWithoutUserBoxInput, BoxUncheckedCreateWithoutUserBoxInput>
  }

  export type BoxUpdateWithoutUserBoxInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    boxImage?: BoxImageUpdateManyWithoutBoxNestedInput
    article?: ArticleUpdateManyWithoutBoxNestedInput
    transaction?: TransactionUpdateManyWithoutBoxNestedInput
    bannerImage?: BannerImageUpdateManyWithoutBoxNestedInput
    boxParams?: BoxParamsUpdateOneWithoutBoxNestedInput
    boxType?: BoxTypeUpdateOneWithoutBoxNestedInput
    boxArticle?: BoxArticleUpdateManyWithoutBoxNestedInput
    dailyReward?: DailyRewardUpdateManyWithoutBoxNestedInput
    boxRewardLevel?: BoxRewardLevelUpdateManyWithoutBoxNestedInput
  }

  export type BoxUncheckedUpdateWithoutUserBoxInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    boxTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    boxImage?: BoxImageUncheckedUpdateManyWithoutBoxNestedInput
    article?: ArticleUncheckedUpdateManyWithoutBoxNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutBoxNestedInput
    bannerImage?: BannerImageUncheckedUpdateManyWithoutBoxNestedInput
    boxParams?: BoxParamsUncheckedUpdateOneWithoutBoxNestedInput
    boxArticle?: BoxArticleUncheckedUpdateManyWithoutBoxNestedInput
    dailyReward?: DailyRewardUncheckedUpdateManyWithoutBoxNestedInput
    boxRewardLevel?: BoxRewardLevelUncheckedUpdateManyWithoutBoxNestedInput
  }

  export type GameUpsertWithWhereUniqueWithoutUserBoxInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutUserBoxInput, GameUncheckedUpdateWithoutUserBoxInput>
    create: XOR<GameCreateWithoutUserBoxInput, GameUncheckedCreateWithoutUserBoxInput>
  }

  export type GameUpdateWithWhereUniqueWithoutUserBoxInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutUserBoxInput, GameUncheckedUpdateWithoutUserBoxInput>
  }

  export type GameUpdateManyWithWhereWithoutUserBoxInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutGameInput>
  }

  export type BoxCreateWithoutBannerImageInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    boxImage?: BoxImageCreateNestedManyWithoutBoxInput
    article?: ArticleCreateNestedManyWithoutBoxInput
    transaction?: TransactionCreateNestedManyWithoutBoxInput
    userBox?: UserBoxCreateNestedManyWithoutBoxInput
    boxParams?: BoxParamsCreateNestedOneWithoutBoxInput
    boxType?: BoxTypeCreateNestedOneWithoutBoxInput
    boxArticle?: BoxArticleCreateNestedManyWithoutBoxInput
    dailyReward?: DailyRewardCreateNestedManyWithoutBoxInput
    boxRewardLevel?: BoxRewardLevelCreateNestedManyWithoutBoxInput
  }

  export type BoxUncheckedCreateWithoutBannerImageInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    boxTypeId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    boxImage?: BoxImageUncheckedCreateNestedManyWithoutBoxInput
    article?: ArticleUncheckedCreateNestedManyWithoutBoxInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutBoxInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutBoxInput
    boxParams?: BoxParamsUncheckedCreateNestedOneWithoutBoxInput
    boxArticle?: BoxArticleUncheckedCreateNestedManyWithoutBoxInput
    dailyReward?: DailyRewardUncheckedCreateNestedManyWithoutBoxInput
    boxRewardLevel?: BoxRewardLevelUncheckedCreateNestedManyWithoutBoxInput
  }

  export type BoxCreateOrConnectWithoutBannerImageInput = {
    where: BoxWhereUniqueInput
    create: XOR<BoxCreateWithoutBannerImageInput, BoxUncheckedCreateWithoutBannerImageInput>
  }

  export type OfferCreateWithoutBannerImageInput = {
    id?: string
    name: string
    price: number
    priceThreeMonth?: number | null
    color?: string | null
    numberMysteryBoxBronze?: number
    numberMysteryBoxSylver?: number
    numberMysteryBoxGold?: number
    isAwardLevelActive?: boolean
    isWeeklyAwardActive?: boolean
    isStandardSupportActive?: boolean
    isVIPSupportActive?: boolean
    duration?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    subscription?: SubscriptionCreateNestedManyWithoutOfferInput
    transaction?: TransactionCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutBannerImageInput = {
    id?: string
    name: string
    price: number
    priceThreeMonth?: number | null
    color?: string | null
    numberMysteryBoxBronze?: number
    numberMysteryBoxSylver?: number
    numberMysteryBoxGold?: number
    isAwardLevelActive?: boolean
    isWeeklyAwardActive?: boolean
    isStandardSupportActive?: boolean
    isVIPSupportActive?: boolean
    duration?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutOfferInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutBannerImageInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutBannerImageInput, OfferUncheckedCreateWithoutBannerImageInput>
  }

  export type BoxUpsertWithoutBannerImageInput = {
    update: XOR<BoxUpdateWithoutBannerImageInput, BoxUncheckedUpdateWithoutBannerImageInput>
    create: XOR<BoxCreateWithoutBannerImageInput, BoxUncheckedCreateWithoutBannerImageInput>
  }

  export type BoxUpdateWithoutBannerImageInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    boxImage?: BoxImageUpdateManyWithoutBoxNestedInput
    article?: ArticleUpdateManyWithoutBoxNestedInput
    transaction?: TransactionUpdateManyWithoutBoxNestedInput
    userBox?: UserBoxUpdateManyWithoutBoxNestedInput
    boxParams?: BoxParamsUpdateOneWithoutBoxNestedInput
    boxType?: BoxTypeUpdateOneWithoutBoxNestedInput
    boxArticle?: BoxArticleUpdateManyWithoutBoxNestedInput
    dailyReward?: DailyRewardUpdateManyWithoutBoxNestedInput
    boxRewardLevel?: BoxRewardLevelUpdateManyWithoutBoxNestedInput
  }

  export type BoxUncheckedUpdateWithoutBannerImageInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    boxTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    boxImage?: BoxImageUncheckedUpdateManyWithoutBoxNestedInput
    article?: ArticleUncheckedUpdateManyWithoutBoxNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutBoxNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutBoxNestedInput
    boxParams?: BoxParamsUncheckedUpdateOneWithoutBoxNestedInput
    boxArticle?: BoxArticleUncheckedUpdateManyWithoutBoxNestedInput
    dailyReward?: DailyRewardUncheckedUpdateManyWithoutBoxNestedInput
    boxRewardLevel?: BoxRewardLevelUncheckedUpdateManyWithoutBoxNestedInput
  }

  export type OfferUpsertWithoutBannerImageInput = {
    update: XOR<OfferUpdateWithoutBannerImageInput, OfferUncheckedUpdateWithoutBannerImageInput>
    create: XOR<OfferCreateWithoutBannerImageInput, OfferUncheckedCreateWithoutBannerImageInput>
  }

  export type OfferUpdateWithoutBannerImageInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceThreeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    numberMysteryBoxBronze?: IntFieldUpdateOperationsInput | number
    numberMysteryBoxSylver?: IntFieldUpdateOperationsInput | number
    numberMysteryBoxGold?: IntFieldUpdateOperationsInput | number
    isAwardLevelActive?: BoolFieldUpdateOperationsInput | boolean
    isWeeklyAwardActive?: BoolFieldUpdateOperationsInput | boolean
    isStandardSupportActive?: BoolFieldUpdateOperationsInput | boolean
    isVIPSupportActive?: BoolFieldUpdateOperationsInput | boolean
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription?: SubscriptionUpdateManyWithoutOfferNestedInput
    transaction?: TransactionUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateWithoutBannerImageInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceThreeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    numberMysteryBoxBronze?: IntFieldUpdateOperationsInput | number
    numberMysteryBoxSylver?: IntFieldUpdateOperationsInput | number
    numberMysteryBoxGold?: IntFieldUpdateOperationsInput | number
    isAwardLevelActive?: BoolFieldUpdateOperationsInput | boolean
    isWeeklyAwardActive?: BoolFieldUpdateOperationsInput | boolean
    isStandardSupportActive?: BoolFieldUpdateOperationsInput | boolean
    isVIPSupportActive?: BoolFieldUpdateOperationsInput | boolean
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription?: SubscriptionUncheckedUpdateManyWithoutOfferNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type BoxCreateWithoutBoxParamsInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    boxImage?: BoxImageCreateNestedManyWithoutBoxInput
    article?: ArticleCreateNestedManyWithoutBoxInput
    transaction?: TransactionCreateNestedManyWithoutBoxInput
    userBox?: UserBoxCreateNestedManyWithoutBoxInput
    bannerImage?: BannerImageCreateNestedManyWithoutBoxInput
    boxType?: BoxTypeCreateNestedOneWithoutBoxInput
    boxArticle?: BoxArticleCreateNestedManyWithoutBoxInput
    dailyReward?: DailyRewardCreateNestedManyWithoutBoxInput
    boxRewardLevel?: BoxRewardLevelCreateNestedManyWithoutBoxInput
  }

  export type BoxUncheckedCreateWithoutBoxParamsInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    boxTypeId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    boxImage?: BoxImageUncheckedCreateNestedManyWithoutBoxInput
    article?: ArticleUncheckedCreateNestedManyWithoutBoxInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutBoxInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutBoxInput
    bannerImage?: BannerImageUncheckedCreateNestedManyWithoutBoxInput
    boxArticle?: BoxArticleUncheckedCreateNestedManyWithoutBoxInput
    dailyReward?: DailyRewardUncheckedCreateNestedManyWithoutBoxInput
    boxRewardLevel?: BoxRewardLevelUncheckedCreateNestedManyWithoutBoxInput
  }

  export type BoxCreateOrConnectWithoutBoxParamsInput = {
    where: BoxWhereUniqueInput
    create: XOR<BoxCreateWithoutBoxParamsInput, BoxUncheckedCreateWithoutBoxParamsInput>
  }

  export type BoxUpsertWithoutBoxParamsInput = {
    update: XOR<BoxUpdateWithoutBoxParamsInput, BoxUncheckedUpdateWithoutBoxParamsInput>
    create: XOR<BoxCreateWithoutBoxParamsInput, BoxUncheckedCreateWithoutBoxParamsInput>
  }

  export type BoxUpdateWithoutBoxParamsInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    boxImage?: BoxImageUpdateManyWithoutBoxNestedInput
    article?: ArticleUpdateManyWithoutBoxNestedInput
    transaction?: TransactionUpdateManyWithoutBoxNestedInput
    userBox?: UserBoxUpdateManyWithoutBoxNestedInput
    bannerImage?: BannerImageUpdateManyWithoutBoxNestedInput
    boxType?: BoxTypeUpdateOneWithoutBoxNestedInput
    boxArticle?: BoxArticleUpdateManyWithoutBoxNestedInput
    dailyReward?: DailyRewardUpdateManyWithoutBoxNestedInput
    boxRewardLevel?: BoxRewardLevelUpdateManyWithoutBoxNestedInput
  }

  export type BoxUncheckedUpdateWithoutBoxParamsInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    boxTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    boxImage?: BoxImageUncheckedUpdateManyWithoutBoxNestedInput
    article?: ArticleUncheckedUpdateManyWithoutBoxNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutBoxNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutBoxNestedInput
    bannerImage?: BannerImageUncheckedUpdateManyWithoutBoxNestedInput
    boxArticle?: BoxArticleUncheckedUpdateManyWithoutBoxNestedInput
    dailyReward?: DailyRewardUncheckedUpdateManyWithoutBoxNestedInput
    boxRewardLevel?: BoxRewardLevelUncheckedUpdateManyWithoutBoxNestedInput
  }

  export type UserCreateWithoutHistoricalInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeCustomerId?: string | null
    rule?: RuleCreateNestedOneWithoutUserInput
    address?: AddressCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartCreateNestedManyWithoutUserInput
    userBox?: UserBoxCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    receiver?: ReceiverCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedManyWithoutUserInput
    patronage?: PatronageCreateNestedManyWithoutUserParentInput
    userChild?: PatronageCreateNestedOneWithoutUserChildInput
  }

  export type UserUncheckedCreateWithoutHistoricalInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ruleId?: string | null
    stripeCustomerId?: string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUserInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receiver?: ReceiverUncheckedCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    patronage?: PatronageUncheckedCreateNestedManyWithoutUserParentInput
    userChild?: PatronageUncheckedCreateNestedOneWithoutUserChildInput
  }

  export type UserCreateOrConnectWithoutHistoricalInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHistoricalInput, UserUncheckedCreateWithoutHistoricalInput>
  }

  export type UserUpsertWithoutHistoricalInput = {
    update: XOR<UserUpdateWithoutHistoricalInput, UserUncheckedUpdateWithoutHistoricalInput>
    create: XOR<UserCreateWithoutHistoricalInput, UserUncheckedCreateWithoutHistoricalInput>
  }

  export type UserUpdateWithoutHistoricalInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    rule?: RuleUpdateOneWithoutUserNestedInput
    address?: AddressUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    patronage?: PatronageUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUpdateOneWithoutUserChildNestedInput
  }

  export type UserUncheckedUpdateWithoutHistoricalInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ruleId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUncheckedUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    patronage?: PatronageUncheckedUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUncheckedUpdateOneWithoutUserChildNestedInput
  }

  export type UserCreateWithoutMessageInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeCustomerId?: string | null
    rule?: RuleCreateNestedOneWithoutUserInput
    address?: AddressCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartCreateNestedManyWithoutUserInput
    userBox?: UserBoxCreateNestedManyWithoutUserInput
    historical?: HistoricalCreateNestedManyWithoutUserInput
    receiver?: ReceiverCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedManyWithoutUserInput
    patronage?: PatronageCreateNestedManyWithoutUserParentInput
    userChild?: PatronageCreateNestedOneWithoutUserChildInput
  }

  export type UserUncheckedCreateWithoutMessageInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ruleId?: string | null
    stripeCustomerId?: string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUserInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutUserInput
    historical?: HistoricalUncheckedCreateNestedManyWithoutUserInput
    receiver?: ReceiverUncheckedCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    patronage?: PatronageUncheckedCreateNestedManyWithoutUserParentInput
    userChild?: PatronageUncheckedCreateNestedOneWithoutUserChildInput
  }

  export type UserCreateOrConnectWithoutMessageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessageInput, UserUncheckedCreateWithoutMessageInput>
  }

  export type ReceiverCreateWithoutMessageInput = {
    id?: string
    readingDate: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    receiver: UserCreateNestedOneWithoutReceiverInput
  }

  export type ReceiverUncheckedCreateWithoutMessageInput = {
    id?: string
    readingDate: Date | string
    receiverId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ReceiverCreateOrConnectWithoutMessageInput = {
    where: ReceiverWhereUniqueInput
    create: XOR<ReceiverCreateWithoutMessageInput, ReceiverUncheckedCreateWithoutMessageInput>
  }

  export type ReceiverCreateManyMessageInputEnvelope = {
    data: Enumerable<ReceiverCreateManyMessageInput>
  }

  export type UserUpsertWithoutMessageInput = {
    update: XOR<UserUpdateWithoutMessageInput, UserUncheckedUpdateWithoutMessageInput>
    create: XOR<UserCreateWithoutMessageInput, UserUncheckedCreateWithoutMessageInput>
  }

  export type UserUpdateWithoutMessageInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    rule?: RuleUpdateOneWithoutUserNestedInput
    address?: AddressUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUpdateManyWithoutUserNestedInput
    historical?: HistoricalUpdateManyWithoutUserNestedInput
    receiver?: ReceiverUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    patronage?: PatronageUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUpdateOneWithoutUserChildNestedInput
  }

  export type UserUncheckedUpdateWithoutMessageInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ruleId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutUserNestedInput
    historical?: HistoricalUncheckedUpdateManyWithoutUserNestedInput
    receiver?: ReceiverUncheckedUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    patronage?: PatronageUncheckedUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUncheckedUpdateOneWithoutUserChildNestedInput
  }

  export type ReceiverUpsertWithWhereUniqueWithoutMessageInput = {
    where: ReceiverWhereUniqueInput
    update: XOR<ReceiverUpdateWithoutMessageInput, ReceiverUncheckedUpdateWithoutMessageInput>
    create: XOR<ReceiverCreateWithoutMessageInput, ReceiverUncheckedCreateWithoutMessageInput>
  }

  export type ReceiverUpdateWithWhereUniqueWithoutMessageInput = {
    where: ReceiverWhereUniqueInput
    data: XOR<ReceiverUpdateWithoutMessageInput, ReceiverUncheckedUpdateWithoutMessageInput>
  }

  export type ReceiverUpdateManyWithWhereWithoutMessageInput = {
    where: ReceiverScalarWhereInput
    data: XOR<ReceiverUpdateManyMutationInput, ReceiverUncheckedUpdateManyWithoutReceiverInput>
  }

  export type UserCreateWithoutReceiverInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeCustomerId?: string | null
    rule?: RuleCreateNestedOneWithoutUserInput
    address?: AddressCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartCreateNestedManyWithoutUserInput
    userBox?: UserBoxCreateNestedManyWithoutUserInput
    historical?: HistoricalCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    temoignage?: TemoignageCreateNestedManyWithoutUserInput
    subscription?: SubscriptionCreateNestedManyWithoutUserInput
    patronage?: PatronageCreateNestedManyWithoutUserParentInput
    userChild?: PatronageCreateNestedOneWithoutUserChildInput
  }

  export type UserUncheckedCreateWithoutReceiverInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ruleId?: string | null
    stripeCustomerId?: string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUserInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutUserInput
    historical?: HistoricalUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    temoignage?: TemoignageUncheckedCreateNestedManyWithoutUserInput
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    patronage?: PatronageUncheckedCreateNestedManyWithoutUserParentInput
    userChild?: PatronageUncheckedCreateNestedOneWithoutUserChildInput
  }

  export type UserCreateOrConnectWithoutReceiverInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceiverInput, UserUncheckedCreateWithoutReceiverInput>
  }

  export type MessageCreateWithoutReceiverInput = {
    id?: string
    message: string
    sendingDate: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    sender: UserCreateNestedOneWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutReceiverInput = {
    id?: string
    message: string
    sendingDate: Date | string
    senderId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MessageCreateOrConnectWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type UserUpsertWithoutReceiverInput = {
    update: XOR<UserUpdateWithoutReceiverInput, UserUncheckedUpdateWithoutReceiverInput>
    create: XOR<UserCreateWithoutReceiverInput, UserUncheckedCreateWithoutReceiverInput>
  }

  export type UserUpdateWithoutReceiverInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    rule?: RuleUpdateOneWithoutUserNestedInput
    address?: AddressUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUpdateManyWithoutUserNestedInput
    historical?: HistoricalUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    temoignage?: TemoignageUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    patronage?: PatronageUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUpdateOneWithoutUserChildNestedInput
  }

  export type UserUncheckedUpdateWithoutReceiverInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ruleId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutUserNestedInput
    historical?: HistoricalUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    temoignage?: TemoignageUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    patronage?: PatronageUncheckedUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUncheckedUpdateOneWithoutUserChildNestedInput
  }

  export type MessageUpsertWithoutReceiverInput = {
    update: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageUpdateWithoutReceiverInput = {
    message?: StringFieldUpdateOperationsInput | string
    sendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender?: UserUpdateOneRequiredWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutReceiverInput = {
    message?: StringFieldUpdateOperationsInput | string
    sendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutTemoignageInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeCustomerId?: string | null
    rule?: RuleCreateNestedOneWithoutUserInput
    address?: AddressCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartCreateNestedManyWithoutUserInput
    userBox?: UserBoxCreateNestedManyWithoutUserInput
    historical?: HistoricalCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    receiver?: ReceiverCreateNestedManyWithoutReceiverInput
    subscription?: SubscriptionCreateNestedManyWithoutUserInput
    patronage?: PatronageCreateNestedManyWithoutUserParentInput
    userChild?: PatronageCreateNestedOneWithoutUserChildInput
  }

  export type UserUncheckedCreateWithoutTemoignageInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ruleId?: string | null
    stripeCustomerId?: string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUserInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutUserInput
    historical?: HistoricalUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receiver?: ReceiverUncheckedCreateNestedManyWithoutReceiverInput
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
    patronage?: PatronageUncheckedCreateNestedManyWithoutUserParentInput
    userChild?: PatronageUncheckedCreateNestedOneWithoutUserChildInput
  }

  export type UserCreateOrConnectWithoutTemoignageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTemoignageInput, UserUncheckedCreateWithoutTemoignageInput>
  }

  export type UserUpsertWithoutTemoignageInput = {
    update: XOR<UserUpdateWithoutTemoignageInput, UserUncheckedUpdateWithoutTemoignageInput>
    create: XOR<UserCreateWithoutTemoignageInput, UserUncheckedCreateWithoutTemoignageInput>
  }

  export type UserUpdateWithoutTemoignageInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    rule?: RuleUpdateOneWithoutUserNestedInput
    address?: AddressUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUpdateManyWithoutUserNestedInput
    historical?: HistoricalUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUpdateManyWithoutReceiverNestedInput
    subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    patronage?: PatronageUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUpdateOneWithoutUserChildNestedInput
  }

  export type UserUncheckedUpdateWithoutTemoignageInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ruleId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutUserNestedInput
    historical?: HistoricalUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUncheckedUpdateManyWithoutReceiverNestedInput
    subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    patronage?: PatronageUncheckedUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUncheckedUpdateOneWithoutUserChildNestedInput
  }

  export type SubscriptionCreateWithoutOfferInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    durationType?: EnumPriceSubscription | null
    status?: EnumStatusSubscription | null
    autoRenewal?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutOfferInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    durationType?: EnumPriceSubscription | null
    status?: EnumStatusSubscription | null
    autoRenewal?: boolean
    userId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubscriptionCreateOrConnectWithoutOfferInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutOfferInput, SubscriptionUncheckedCreateWithoutOfferInput>
  }

  export type SubscriptionCreateManyOfferInputEnvelope = {
    data: Enumerable<SubscriptionCreateManyOfferInput>
  }

  export type BannerImageCreateWithoutOfferInput = {
    id?: string
    bannerImgUrl: string
    bannerLink?: string | null
    type?: BannerImageType | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    box?: BoxCreateNestedOneWithoutBannerImageInput
  }

  export type BannerImageUncheckedCreateWithoutOfferInput = {
    id?: string
    bannerImgUrl: string
    bannerLink?: string | null
    type?: BannerImageType | null
    boxId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BannerImageCreateOrConnectWithoutOfferInput = {
    where: BannerImageWhereUniqueInput
    create: XOR<BannerImageCreateWithoutOfferInput, BannerImageUncheckedCreateWithoutOfferInput>
  }

  export type BannerImageCreateManyOfferInputEnvelope = {
    data: Enumerable<BannerImageCreateManyOfferInput>
  }

  export type TransactionCreateWithoutOfferInput = {
    id?: string
    type: EnumTypeTransaction
    date: Date | string
    amount: number
    status: EnumStatusTransaction
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    box?: BoxCreateNestedOneWithoutTransactionInput
    wallet: WalletCreateNestedOneWithoutTransactionInput
    shoppingCart?: ShoppingCartCreateNestedOneWithoutTransactionInput
    bank?: BankCreateNestedOneWithoutTransactionInput
    game?: GameCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutOfferInput = {
    id?: string
    type: EnumTypeTransaction
    date: Date | string
    amount: number
    status: EnumStatusTransaction
    boxId?: string | null
    walletId: string
    shoppingCartId?: string | null
    bankId?: string | null
    gameId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TransactionCreateOrConnectWithoutOfferInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutOfferInput, TransactionUncheckedCreateWithoutOfferInput>
  }

  export type TransactionCreateManyOfferInputEnvelope = {
    data: Enumerable<TransactionCreateManyOfferInput>
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutOfferInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutOfferInput, SubscriptionUncheckedUpdateWithoutOfferInput>
    create: XOR<SubscriptionCreateWithoutOfferInput, SubscriptionUncheckedCreateWithoutOfferInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutOfferInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutOfferInput, SubscriptionUncheckedUpdateWithoutOfferInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutOfferInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type BannerImageUpsertWithWhereUniqueWithoutOfferInput = {
    where: BannerImageWhereUniqueInput
    update: XOR<BannerImageUpdateWithoutOfferInput, BannerImageUncheckedUpdateWithoutOfferInput>
    create: XOR<BannerImageCreateWithoutOfferInput, BannerImageUncheckedCreateWithoutOfferInput>
  }

  export type BannerImageUpdateWithWhereUniqueWithoutOfferInput = {
    where: BannerImageWhereUniqueInput
    data: XOR<BannerImageUpdateWithoutOfferInput, BannerImageUncheckedUpdateWithoutOfferInput>
  }

  export type BannerImageUpdateManyWithWhereWithoutOfferInput = {
    where: BannerImageScalarWhereInput
    data: XOR<BannerImageUpdateManyMutationInput, BannerImageUncheckedUpdateManyWithoutBannerImageInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutOfferInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutOfferInput, TransactionUncheckedUpdateWithoutOfferInput>
    create: XOR<TransactionCreateWithoutOfferInput, TransactionUncheckedCreateWithoutOfferInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutOfferInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutOfferInput, TransactionUncheckedUpdateWithoutOfferInput>
  }

  export type TransactionUpdateManyWithWhereWithoutOfferInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTransactionInput>
  }

  export type UserCreateWithoutSubscriptionInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeCustomerId?: string | null
    rule?: RuleCreateNestedOneWithoutUserInput
    address?: AddressCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartCreateNestedManyWithoutUserInput
    userBox?: UserBoxCreateNestedManyWithoutUserInput
    historical?: HistoricalCreateNestedManyWithoutUserInput
    message?: MessageCreateNestedManyWithoutSenderInput
    receiver?: ReceiverCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageCreateNestedManyWithoutUserInput
    patronage?: PatronageCreateNestedManyWithoutUserParentInput
    userChild?: PatronageCreateNestedOneWithoutUserChildInput
  }

  export type UserUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ruleId?: string | null
    stripeCustomerId?: string | null
    address?: AddressUncheckedCreateNestedOneWithoutUserInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedCreateNestedManyWithoutUserInput
    codeConfirmMail?: CodeConfirmMailUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUserInput
    userBox?: UserBoxUncheckedCreateNestedManyWithoutUserInput
    historical?: HistoricalUncheckedCreateNestedManyWithoutUserInput
    message?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receiver?: ReceiverUncheckedCreateNestedManyWithoutReceiverInput
    temoignage?: TemoignageUncheckedCreateNestedManyWithoutUserInput
    patronage?: PatronageUncheckedCreateNestedManyWithoutUserParentInput
    userChild?: PatronageUncheckedCreateNestedOneWithoutUserChildInput
  }

  export type UserCreateOrConnectWithoutSubscriptionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
  }

  export type OfferCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    price: number
    priceThreeMonth?: number | null
    color?: string | null
    numberMysteryBoxBronze?: number
    numberMysteryBoxSylver?: number
    numberMysteryBoxGold?: number
    isAwardLevelActive?: boolean
    isWeeklyAwardActive?: boolean
    isStandardSupportActive?: boolean
    isVIPSupportActive?: boolean
    duration?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bannerImage?: BannerImageCreateNestedManyWithoutOfferInput
    transaction?: TransactionCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    price: number
    priceThreeMonth?: number | null
    color?: string | null
    numberMysteryBoxBronze?: number
    numberMysteryBoxSylver?: number
    numberMysteryBoxGold?: number
    isAwardLevelActive?: boolean
    isWeeklyAwardActive?: boolean
    isStandardSupportActive?: boolean
    isVIPSupportActive?: boolean
    duration?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    bannerImage?: BannerImageUncheckedCreateNestedManyWithoutOfferInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutSubscriptionInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutSubscriptionInput, OfferUncheckedCreateWithoutSubscriptionInput>
  }

  export type UserUpsertWithoutSubscriptionInput = {
    update: XOR<UserUpdateWithoutSubscriptionInput, UserUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<UserCreateWithoutSubscriptionInput, UserUncheckedCreateWithoutSubscriptionInput>
  }

  export type UserUpdateWithoutSubscriptionInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    rule?: RuleUpdateOneWithoutUserNestedInput
    address?: AddressUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUpdateManyWithoutUserNestedInput
    historical?: HistoricalUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUpdateManyWithoutUserNestedInput
    patronage?: PatronageUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUpdateOneWithoutUserChildNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ruleId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutUserNestedInput
    historical?: HistoricalUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUncheckedUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUncheckedUpdateManyWithoutUserNestedInput
    patronage?: PatronageUncheckedUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUncheckedUpdateOneWithoutUserChildNestedInput
  }

  export type OfferUpsertWithoutSubscriptionInput = {
    update: XOR<OfferUpdateWithoutSubscriptionInput, OfferUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<OfferCreateWithoutSubscriptionInput, OfferUncheckedCreateWithoutSubscriptionInput>
  }

  export type OfferUpdateWithoutSubscriptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceThreeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    numberMysteryBoxBronze?: IntFieldUpdateOperationsInput | number
    numberMysteryBoxSylver?: IntFieldUpdateOperationsInput | number
    numberMysteryBoxGold?: IntFieldUpdateOperationsInput | number
    isAwardLevelActive?: BoolFieldUpdateOperationsInput | boolean
    isWeeklyAwardActive?: BoolFieldUpdateOperationsInput | boolean
    isStandardSupportActive?: BoolFieldUpdateOperationsInput | boolean
    isVIPSupportActive?: BoolFieldUpdateOperationsInput | boolean
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannerImage?: BannerImageUpdateManyWithoutOfferNestedInput
    transaction?: TransactionUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateWithoutSubscriptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    priceThreeMonth?: NullableFloatFieldUpdateOperationsInput | number | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    numberMysteryBoxBronze?: IntFieldUpdateOperationsInput | number
    numberMysteryBoxSylver?: IntFieldUpdateOperationsInput | number
    numberMysteryBoxGold?: IntFieldUpdateOperationsInput | number
    isAwardLevelActive?: BoolFieldUpdateOperationsInput | boolean
    isWeeklyAwardActive?: BoolFieldUpdateOperationsInput | boolean
    isStandardSupportActive?: BoolFieldUpdateOperationsInput | boolean
    isVIPSupportActive?: BoolFieldUpdateOperationsInput | boolean
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bannerImage?: BannerImageUncheckedUpdateManyWithoutOfferNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type UserBoxCreateWithoutGameInput = {
    id?: string
    type: EnumUserBoxType
    duration?: Date | string | null
    dayNumber?: number | null
    isPlayed?: boolean | null
    isLocked?: boolean | null
    playedDate?: Date | string | null
    activationDate?: Date | string | null
    deactivationDate?: Date | string | null
    orderNumber?: number | null
    name?: string | null
    unlockThreshold?: number | null
    description?: string | null
    lot?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutUserBoxInput
    box: BoxCreateNestedOneWithoutUserBoxInput
  }

  export type UserBoxUncheckedCreateWithoutGameInput = {
    id?: string
    type: EnumUserBoxType
    duration?: Date | string | null
    dayNumber?: number | null
    isPlayed?: boolean | null
    isLocked?: boolean | null
    playedDate?: Date | string | null
    activationDate?: Date | string | null
    deactivationDate?: Date | string | null
    orderNumber?: number | null
    name?: string | null
    unlockThreshold?: number | null
    description?: string | null
    userId: string
    boxId: string
    lot?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UserBoxCreateOrConnectWithoutGameInput = {
    where: UserBoxWhereUniqueInput
    create: XOR<UserBoxCreateWithoutGameInput, UserBoxUncheckedCreateWithoutGameInput>
  }

  export type PatronageCreateWithoutGameInput = {
    id?: string
    gainPercentage?: number | null
    discountPercentage?: number | null
    status?: EnumStatusPatronage | null
    bonusEndDate?: Date | string | null
    bonusCollect?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    userParent: UserCreateNestedOneWithoutPatronageInput
    userChild: UserCreateNestedOneWithoutUserChildInput
  }

  export type PatronageUncheckedCreateWithoutGameInput = {
    id?: string
    gainPercentage?: number | null
    discountPercentage?: number | null
    status?: EnumStatusPatronage | null
    bonusEndDate?: Date | string | null
    userParentId: string
    userChildId: string
    bonusCollect?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PatronageCreateOrConnectWithoutGameInput = {
    where: PatronageWhereUniqueInput
    create: XOR<PatronageCreateWithoutGameInput, PatronageUncheckedCreateWithoutGameInput>
  }

  export type ArticleCreateWithoutGameInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    provider?: ProviderCreateNestedOneWithoutArticleInput
    unitySize?: UnitySizeCreateNestedOneWithoutArticleInput
    subCategory?: SubCategoryCreateNestedOneWithoutArticleInput
    box?: BoxCreateNestedOneWithoutArticleInput
    articlePhoto?: ArticlePhotoCreateNestedManyWithoutArticleInput
    post?: PostCreateNestedManyWithoutArticleInput
    price?: PriceCreateNestedOneWithoutArticleInput
    boxArticle?: BoxArticleCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutGameInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    providerId?: string | null
    unitySizeId?: string | null
    subCategoryId: string
    boxId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    articlePhoto?: ArticlePhotoUncheckedCreateNestedManyWithoutArticleInput
    post?: PostUncheckedCreateNestedManyWithoutArticleInput
    price?: PriceUncheckedCreateNestedOneWithoutArticleInput
    boxArticle?: BoxArticleUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutGameInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutGameInput, ArticleUncheckedCreateWithoutGameInput>
  }

  export type ShoppingCartCreateWithoutGameInput = {
    id?: string
    winningDate: Date | string
    isClaimed?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutShoppingCartInput
    transaction?: TransactionCreateNestedManyWithoutShoppingCartInput
    order?: OrderCreateNestedOneWithoutShoppingCartInput
  }

  export type ShoppingCartUncheckedCreateWithoutGameInput = {
    id?: string
    winningDate: Date | string
    isClaimed?: boolean | null
    userId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    transaction?: TransactionUncheckedCreateNestedManyWithoutShoppingCartInput
    order?: OrderUncheckedCreateNestedOneWithoutShoppingCartInput
  }

  export type ShoppingCartCreateOrConnectWithoutGameInput = {
    where: ShoppingCartWhereUniqueInput
    create: XOR<ShoppingCartCreateWithoutGameInput, ShoppingCartUncheckedCreateWithoutGameInput>
  }

  export type TransactionCreateWithoutGameInput = {
    id?: string
    type: EnumTypeTransaction
    date: Date | string
    amount: number
    status: EnumStatusTransaction
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    box?: BoxCreateNestedOneWithoutTransactionInput
    wallet: WalletCreateNestedOneWithoutTransactionInput
    offer?: OfferCreateNestedOneWithoutTransactionInput
    shoppingCart?: ShoppingCartCreateNestedOneWithoutTransactionInput
    bank?: BankCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutGameInput = {
    id?: string
    type: EnumTypeTransaction
    date: Date | string
    amount: number
    status: EnumStatusTransaction
    boxId?: string | null
    walletId: string
    offerId?: string | null
    shoppingCartId?: string | null
    bankId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TransactionCreateOrConnectWithoutGameInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutGameInput, TransactionUncheckedCreateWithoutGameInput>
  }

  export type TransactionCreateManyGameInputEnvelope = {
    data: Enumerable<TransactionCreateManyGameInput>
  }

  export type UserBoxUpsertWithoutGameInput = {
    update: XOR<UserBoxUpdateWithoutGameInput, UserBoxUncheckedUpdateWithoutGameInput>
    create: XOR<UserBoxCreateWithoutGameInput, UserBoxUncheckedCreateWithoutGameInput>
  }

  export type UserBoxUpdateWithoutGameInput = {
    type?: EnumEnumUserBoxTypeFieldUpdateOperationsInput | EnumUserBoxType
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isPlayed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    playedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderNumber?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unlockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lot?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserBoxNestedInput
    box?: BoxUpdateOneRequiredWithoutUserBoxNestedInput
  }

  export type UserBoxUncheckedUpdateWithoutGameInput = {
    type?: EnumEnumUserBoxTypeFieldUpdateOperationsInput | EnumUserBoxType
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isPlayed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    playedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderNumber?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unlockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    boxId?: StringFieldUpdateOperationsInput | string
    lot?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PatronageUpsertWithoutGameInput = {
    update: XOR<PatronageUpdateWithoutGameInput, PatronageUncheckedUpdateWithoutGameInput>
    create: XOR<PatronageCreateWithoutGameInput, PatronageUncheckedCreateWithoutGameInput>
  }

  export type PatronageUpdateWithoutGameInput = {
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumEnumStatusPatronageFieldUpdateOperationsInput | EnumStatusPatronage | null
    bonusEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bonusCollect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userParent?: UserUpdateOneRequiredWithoutPatronageNestedInput
    userChild?: UserUpdateOneRequiredWithoutUserChildNestedInput
  }

  export type PatronageUncheckedUpdateWithoutGameInput = {
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumEnumStatusPatronageFieldUpdateOperationsInput | EnumStatusPatronage | null
    bonusEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userParentId?: StringFieldUpdateOperationsInput | string
    userChildId?: StringFieldUpdateOperationsInput | string
    bonusCollect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArticleUpsertWithoutGameInput = {
    update: XOR<ArticleUpdateWithoutGameInput, ArticleUncheckedUpdateWithoutGameInput>
    create: XOR<ArticleCreateWithoutGameInput, ArticleUncheckedCreateWithoutGameInput>
  }

  export type ArticleUpdateWithoutGameInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: ProviderUpdateOneWithoutArticleNestedInput
    unitySize?: UnitySizeUpdateOneWithoutArticleNestedInput
    subCategory?: SubCategoryUpdateOneWithoutArticleNestedInput
    box?: BoxUpdateOneWithoutArticleNestedInput
    articlePhoto?: ArticlePhotoUpdateManyWithoutArticleNestedInput
    post?: PostUpdateManyWithoutArticleNestedInput
    price?: PriceUpdateOneWithoutArticleNestedInput
    boxArticle?: BoxArticleUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutGameInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    unitySizeId?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: StringFieldUpdateOperationsInput | string
    boxId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    articlePhoto?: ArticlePhotoUncheckedUpdateManyWithoutArticleNestedInput
    post?: PostUncheckedUpdateManyWithoutArticleNestedInput
    price?: PriceUncheckedUpdateOneWithoutArticleNestedInput
    boxArticle?: BoxArticleUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ShoppingCartUpsertWithoutGameInput = {
    update: XOR<ShoppingCartUpdateWithoutGameInput, ShoppingCartUncheckedUpdateWithoutGameInput>
    create: XOR<ShoppingCartCreateWithoutGameInput, ShoppingCartUncheckedCreateWithoutGameInput>
  }

  export type ShoppingCartUpdateWithoutGameInput = {
    winningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutShoppingCartNestedInput
    transaction?: TransactionUpdateManyWithoutShoppingCartNestedInput
    order?: OrderUpdateOneWithoutShoppingCartNestedInput
  }

  export type ShoppingCartUncheckedUpdateWithoutGameInput = {
    winningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction?: TransactionUncheckedUpdateManyWithoutShoppingCartNestedInput
    order?: OrderUncheckedUpdateOneWithoutShoppingCartNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutGameInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutGameInput, TransactionUncheckedUpdateWithoutGameInput>
    create: XOR<TransactionCreateWithoutGameInput, TransactionUncheckedCreateWithoutGameInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutGameInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutGameInput, TransactionUncheckedUpdateWithoutGameInput>
  }

  export type TransactionUpdateManyWithWhereWithoutGameInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTransactionInput>
  }

  export type CodeConfirmLoginCreateManyUserInput = {
    id?: string
    uuid: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CodeConfirmMailCreateManyUserInput = {
    id?: string
    uuid: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ShoppingCartCreateManyUserInput = {
    id?: string
    winningDate: Date | string
    isClaimed?: boolean | null
    gameId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UserBoxCreateManyUserInput = {
    id?: string
    type: EnumUserBoxType
    duration?: Date | string | null
    dayNumber?: number | null
    isPlayed?: boolean | null
    isLocked?: boolean | null
    playedDate?: Date | string | null
    activationDate?: Date | string | null
    deactivationDate?: Date | string | null
    orderNumber?: number | null
    name?: string | null
    unlockThreshold?: number | null
    description?: string | null
    boxId: string
    lot?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type HistoricalCreateManyUserInput = {
    id?: string
    date: Date | string
    description: string
    action: EnumHistoricalAction
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MessageCreateManySenderInput = {
    id?: string
    message: string
    sendingDate: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ReceiverCreateManyReceiverInput = {
    id?: string
    readingDate: Date | string
    messageId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TemoignageCreateManyUserInput = {
    id?: string
    comment: string
    rating: number
    commentDate: Date | string
    isToShow?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubscriptionCreateManyUserInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    durationType?: EnumPriceSubscription | null
    status?: EnumStatusSubscription | null
    autoRenewal?: boolean
    offerId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PatronageCreateManyUserParentInput = {
    id?: string
    gainPercentage?: number | null
    discountPercentage?: number | null
    status?: EnumStatusPatronage | null
    bonusEndDate?: Date | string | null
    userChildId: string
    bonusCollect?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type CodeConfirmLoginUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CodeConfirmLoginUncheckedUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CodeConfirmLoginUncheckedUpdateManyWithoutCodeConfirmLoginInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CodeConfirmMailUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CodeConfirmMailUncheckedUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CodeConfirmMailUncheckedUpdateManyWithoutCodeConfirmMailInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ShoppingCartUpdateWithoutUserInput = {
    winningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    game?: GameUpdateOneRequiredWithoutShoppingCartNestedInput
    transaction?: TransactionUpdateManyWithoutShoppingCartNestedInput
    order?: OrderUpdateOneWithoutShoppingCartNestedInput
  }

  export type ShoppingCartUncheckedUpdateWithoutUserInput = {
    winningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gameId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction?: TransactionUncheckedUpdateManyWithoutShoppingCartNestedInput
    order?: OrderUncheckedUpdateOneWithoutShoppingCartNestedInput
  }

  export type ShoppingCartUncheckedUpdateManyWithoutShoppingCartInput = {
    winningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isClaimed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gameId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserBoxUpdateWithoutUserInput = {
    type?: EnumEnumUserBoxTypeFieldUpdateOperationsInput | EnumUserBoxType
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isPlayed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    playedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderNumber?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unlockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lot?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    box?: BoxUpdateOneRequiredWithoutUserBoxNestedInput
    game?: GameUpdateManyWithoutUserBoxNestedInput
  }

  export type UserBoxUncheckedUpdateWithoutUserInput = {
    type?: EnumEnumUserBoxTypeFieldUpdateOperationsInput | EnumUserBoxType
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isPlayed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    playedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderNumber?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unlockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    boxId?: StringFieldUpdateOperationsInput | string
    lot?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    game?: GameUncheckedUpdateManyWithoutUserBoxNestedInput
  }

  export type UserBoxUncheckedUpdateManyWithoutUserBoxInput = {
    type?: EnumEnumUserBoxTypeFieldUpdateOperationsInput | EnumUserBoxType
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isPlayed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    playedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderNumber?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unlockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    boxId?: StringFieldUpdateOperationsInput | string
    lot?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HistoricalUpdateWithoutUserInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    action?: EnumEnumHistoricalActionFieldUpdateOperationsInput | EnumHistoricalAction
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HistoricalUncheckedUpdateWithoutUserInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    action?: EnumEnumHistoricalActionFieldUpdateOperationsInput | EnumHistoricalAction
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HistoricalUncheckedUpdateManyWithoutHistoricalInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    action?: EnumEnumHistoricalActionFieldUpdateOperationsInput | EnumHistoricalAction
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUpdateWithoutSenderInput = {
    message?: StringFieldUpdateOperationsInput | string
    sendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiver?: ReceiverUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    message?: StringFieldUpdateOperationsInput | string
    sendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiver?: ReceiverUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutMessageInput = {
    message?: StringFieldUpdateOperationsInput | string
    sendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReceiverUpdateWithoutReceiverInput = {
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: MessageUpdateOneRequiredWithoutReceiverNestedInput
  }

  export type ReceiverUncheckedUpdateWithoutReceiverInput = {
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReceiverUncheckedUpdateManyWithoutReceiverInput = {
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    messageId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TemoignageUpdateWithoutUserInput = {
    comment?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    commentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isToShow?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TemoignageUncheckedUpdateWithoutUserInput = {
    comment?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    commentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isToShow?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TemoignageUncheckedUpdateManyWithoutTemoignageInput = {
    comment?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    commentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isToShow?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionUpdateWithoutUserInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationType?: NullableEnumEnumPriceSubscriptionFieldUpdateOperationsInput | EnumPriceSubscription | null
    status?: NullableEnumEnumStatusSubscriptionFieldUpdateOperationsInput | EnumStatusSubscription | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offer?: OfferUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationType?: NullableEnumEnumPriceSubscriptionFieldUpdateOperationsInput | EnumPriceSubscription | null
    status?: NullableEnumEnumStatusSubscriptionFieldUpdateOperationsInput | EnumStatusSubscription | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    offerId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionUncheckedUpdateManyWithoutSubscriptionInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationType?: NullableEnumEnumPriceSubscriptionFieldUpdateOperationsInput | EnumPriceSubscription | null
    status?: NullableEnumEnumStatusSubscriptionFieldUpdateOperationsInput | EnumStatusSubscription | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    offerId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PatronageUpdateWithoutUserParentInput = {
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumEnumStatusPatronageFieldUpdateOperationsInput | EnumStatusPatronage | null
    bonusEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bonusCollect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userChild?: UserUpdateOneRequiredWithoutUserChildNestedInput
    game?: GameUpdateManyWithoutPatronageNestedInput
  }

  export type PatronageUncheckedUpdateWithoutUserParentInput = {
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumEnumStatusPatronageFieldUpdateOperationsInput | EnumStatusPatronage | null
    bonusEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userChildId?: StringFieldUpdateOperationsInput | string
    bonusCollect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    game?: GameUncheckedUpdateManyWithoutPatronageNestedInput
  }

  export type PatronageUncheckedUpdateManyWithoutPatronageInput = {
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    discountPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableEnumEnumStatusPatronageFieldUpdateOperationsInput | EnumStatusPatronage | null
    bonusEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userChildId?: StringFieldUpdateOperationsInput | string
    bonusCollect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameCreateManyPatronageInput = {
    id?: string
    reference: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: EnumStatusGame
    version?: EnumVersionGame | null
    type?: EnumTypeGame | null
    userBoxId?: string | null
    gainPercentage?: number | null
    gainDraw?: number | null
    articleId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type GameUpdateWithoutPatronageInput = {
    reference?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEnumStatusGameFieldUpdateOperationsInput | EnumStatusGame
    version?: NullableEnumEnumVersionGameFieldUpdateOperationsInput | EnumVersionGame | null
    type?: NullableEnumEnumTypeGameFieldUpdateOperationsInput | EnumTypeGame | null
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gainDraw?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userBox?: UserBoxUpdateOneWithoutGameNestedInput
    article?: ArticleUpdateOneWithoutGameNestedInput
    shoppingCart?: ShoppingCartUpdateOneWithoutGameNestedInput
    transaction?: TransactionUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutPatronageInput = {
    reference?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEnumStatusGameFieldUpdateOperationsInput | EnumStatusGame
    version?: NullableEnumEnumVersionGameFieldUpdateOperationsInput | EnumVersionGame | null
    type?: NullableEnumEnumTypeGameFieldUpdateOperationsInput | EnumTypeGame | null
    userBoxId?: NullableStringFieldUpdateOperationsInput | string | null
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gainDraw?: NullableFloatFieldUpdateOperationsInput | number | null
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shoppingCart?: ShoppingCartUncheckedUpdateOneWithoutGameNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateManyWithoutGameInput = {
    reference?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEnumStatusGameFieldUpdateOperationsInput | EnumStatusGame
    version?: NullableEnumEnumVersionGameFieldUpdateOperationsInput | EnumVersionGame | null
    type?: NullableEnumEnumTypeGameFieldUpdateOperationsInput | EnumTypeGame | null
    userBoxId?: NullableStringFieldUpdateOperationsInput | string | null
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gainDraw?: NullableFloatFieldUpdateOperationsInput | number | null
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateManyRuleInput = {
    id?: string
    firstName: string
    lastName?: string | null
    username: string
    photoUrl?: string | null
    email: string
    isActif?: boolean
    isMember?: boolean
    isAdmin?: boolean
    emailIsVerified?: boolean
    twoAuthIsActive?: boolean
    phone?: string | null
    gender?: EnumGender | null
    birthDate?: Date | string | null
    password: string
    socketId?: string | null
    refreshToken?: string | null
    supportingDocumentUrl?: string | null
    isValideSupportingDocument?: boolean
    registrationBonus?: number | null
    latestConnectedDate?: Date | string | null
    signInCount?: number | null
    lotCount?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    stripeCustomerId?: string | null
  }

  export type UserUpdateWithoutRuleInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUpdateManyWithoutUserNestedInput
    historical?: HistoricalUpdateManyWithoutUserNestedInput
    message?: MessageUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUpdateManyWithoutUserNestedInput
    patronage?: PatronageUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUpdateOneWithoutUserChildNestedInput
  }

  export type UserUncheckedUpdateWithoutRuleInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: AddressUncheckedUpdateOneWithoutUserNestedInput
    codeConfirmLogin?: CodeConfirmLoginUncheckedUpdateManyWithoutUserNestedInput
    codeConfirmMail?: CodeConfirmMailUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    shoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUserNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutUserNestedInput
    historical?: HistoricalUncheckedUpdateManyWithoutUserNestedInput
    message?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receiver?: ReceiverUncheckedUpdateManyWithoutReceiverNestedInput
    temoignage?: TemoignageUncheckedUpdateManyWithoutUserNestedInput
    subscription?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
    patronage?: PatronageUncheckedUpdateManyWithoutUserParentNestedInput
    userChild?: PatronageUncheckedUpdateOneWithoutUserChildNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUserInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    isActif?: BoolFieldUpdateOperationsInput | boolean
    isMember?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    emailIsVerified?: BoolFieldUpdateOperationsInput | boolean
    twoAuthIsActive?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumEnumGenderFieldUpdateOperationsInput | EnumGender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    socketId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    supportingDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isValideSupportingDocument?: BoolFieldUpdateOperationsInput | boolean
    registrationBonus?: NullableFloatFieldUpdateOperationsInput | number | null
    latestConnectedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    signInCount?: NullableIntFieldUpdateOperationsInput | number | null
    lotCount?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionUpdateWithoutRulesInput = {
    name?: EnumEnumPermissionFieldUpdateOperationsInput | EnumPermission
    keyword?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    models?: ModelUpdateManyWithoutPermissionsNestedInput
  }

  export type PermissionUncheckedUpdateWithoutRulesInput = {
    name?: EnumEnumPermissionFieldUpdateOperationsInput | EnumPermission
    keyword?: StringFieldUpdateOperationsInput | string
    rulesIDs?: PermissionUpdaterulesIDsInput | Enumerable<string>
    modelsIDs?: PermissionUpdatemodelsIDsInput | Enumerable<string>
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    models?: ModelUncheckedUpdateManyWithoutPermissionsNestedInput
  }

  export type PermissionUncheckedUpdateManyWithoutPermissionsInput = {
    name?: EnumEnumPermissionFieldUpdateOperationsInput | EnumPermission
    keyword?: StringFieldUpdateOperationsInput | string
    rulesIDs?: PermissionUpdaterulesIDsInput | Enumerable<string>
    modelsIDs?: PermissionUpdatemodelsIDsInput | Enumerable<string>
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RuleUpdateWithoutPermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateManyWithoutRuleNestedInput
  }

  export type RuleUncheckedUpdateWithoutPermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    permissionIDs?: RuleUpdatepermissionIDsInput | Enumerable<string>
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type RuleUncheckedUpdateManyWithoutRulesInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    permissionIDs?: RuleUpdatepermissionIDsInput | Enumerable<string>
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelUpdateWithoutPermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelUncheckedUpdateWithoutPermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    permissionIDs?: ModelUpdatepermissionIDsInput | Enumerable<string>
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelUncheckedUpdateManyWithoutModelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    permissionIDs?: ModelUpdatepermissionIDsInput | Enumerable<string>
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PermissionUpdateWithoutModelsInput = {
    name?: EnumEnumPermissionFieldUpdateOperationsInput | EnumPermission
    keyword?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rules?: RuleUpdateManyWithoutPermissionsNestedInput
  }

  export type PermissionUncheckedUpdateWithoutModelsInput = {
    name?: EnumEnumPermissionFieldUpdateOperationsInput | EnumPermission
    keyword?: StringFieldUpdateOperationsInput | string
    rulesIDs?: PermissionUpdaterulesIDsInput | Enumerable<string>
    modelsIDs?: PermissionUpdatemodelsIDsInput | Enumerable<string>
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rules?: RuleUncheckedUpdateManyWithoutPermissionsNestedInput
  }

  export type TransactionCreateManyWalletInput = {
    id?: string
    type: EnumTypeTransaction
    date: Date | string
    amount: number
    status: EnumStatusTransaction
    boxId?: string | null
    offerId?: string | null
    shoppingCartId?: string | null
    bankId?: string | null
    gameId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TransactionUpdateWithoutWalletInput = {
    type?: EnumEnumTypeTransactionFieldUpdateOperationsInput | EnumTypeTransaction
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumEnumStatusTransactionFieldUpdateOperationsInput | EnumStatusTransaction
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    box?: BoxUpdateOneWithoutTransactionNestedInput
    offer?: OfferUpdateOneWithoutTransactionNestedInput
    shoppingCart?: ShoppingCartUpdateOneWithoutTransactionNestedInput
    bank?: BankUpdateOneWithoutTransactionNestedInput
    game?: GameUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutWalletInput = {
    type?: EnumEnumTypeTransactionFieldUpdateOperationsInput | EnumTypeTransaction
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumEnumStatusTransactionFieldUpdateOperationsInput | EnumStatusTransaction
    boxId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingCartId?: NullableStringFieldUpdateOperationsInput | string | null
    bankId?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUncheckedUpdateManyWithoutTransactionInput = {
    type?: EnumEnumTypeTransactionFieldUpdateOperationsInput | EnumTypeTransaction
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumEnumStatusTransactionFieldUpdateOperationsInput | EnumStatusTransaction
    boxId?: NullableStringFieldUpdateOperationsInput | string | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingCartId?: NullableStringFieldUpdateOperationsInput | string | null
    bankId?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxCreateManyBoxTypeInput = {
    id?: string
    reference: string
    name: string
    price: number
    number: number
    description: string
    badge?: EnumBadgeBox | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BoxUpdateWithoutBoxTypeInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    boxImage?: BoxImageUpdateManyWithoutBoxNestedInput
    article?: ArticleUpdateManyWithoutBoxNestedInput
    transaction?: TransactionUpdateManyWithoutBoxNestedInput
    userBox?: UserBoxUpdateManyWithoutBoxNestedInput
    bannerImage?: BannerImageUpdateManyWithoutBoxNestedInput
    boxParams?: BoxParamsUpdateOneWithoutBoxNestedInput
    boxArticle?: BoxArticleUpdateManyWithoutBoxNestedInput
    dailyReward?: DailyRewardUpdateManyWithoutBoxNestedInput
    boxRewardLevel?: BoxRewardLevelUpdateManyWithoutBoxNestedInput
  }

  export type BoxUncheckedUpdateWithoutBoxTypeInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    boxImage?: BoxImageUncheckedUpdateManyWithoutBoxNestedInput
    article?: ArticleUncheckedUpdateManyWithoutBoxNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutBoxNestedInput
    userBox?: UserBoxUncheckedUpdateManyWithoutBoxNestedInput
    bannerImage?: BannerImageUncheckedUpdateManyWithoutBoxNestedInput
    boxParams?: BoxParamsUncheckedUpdateOneWithoutBoxNestedInput
    boxArticle?: BoxArticleUncheckedUpdateManyWithoutBoxNestedInput
    dailyReward?: DailyRewardUncheckedUpdateManyWithoutBoxNestedInput
    boxRewardLevel?: BoxRewardLevelUncheckedUpdateManyWithoutBoxNestedInput
  }

  export type BoxUncheckedUpdateManyWithoutBoxInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    badge?: NullableEnumEnumBadgeBoxFieldUpdateOperationsInput | EnumBadgeBox | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxImageCreateManyBoxInput = {
    id?: string
    photoUrl: string
    status: EnumBoxImageStatus
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ArticleCreateManyBoxInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    providerId?: string | null
    unitySizeId?: string | null
    subCategoryId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TransactionCreateManyBoxInput = {
    id?: string
    type: EnumTypeTransaction
    date: Date | string
    amount: number
    status: EnumStatusTransaction
    walletId: string
    offerId?: string | null
    shoppingCartId?: string | null
    bankId?: string | null
    gameId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UserBoxCreateManyBoxInput = {
    id?: string
    type: EnumUserBoxType
    duration?: Date | string | null
    dayNumber?: number | null
    isPlayed?: boolean | null
    isLocked?: boolean | null
    playedDate?: Date | string | null
    activationDate?: Date | string | null
    deactivationDate?: Date | string | null
    orderNumber?: number | null
    name?: string | null
    unlockThreshold?: number | null
    description?: string | null
    userId: string
    lot?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BannerImageCreateManyBoxInput = {
    id?: string
    bannerImgUrl: string
    bannerLink?: string | null
    type?: BannerImageType | null
    offerId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BoxArticleCreateManyBoxInput = {
    id?: string
    winningChance: number
    articleId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type DailyRewardCreateManyBoxInput = {
    id?: string
    number: number
  }

  export type BoxRewardLevelCreateManyBoxInput = {
    id?: string
    rewardLevelId: string
  }

  export type BoxImageUpdateWithoutBoxInput = {
    photoUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumEnumBoxImageStatusFieldUpdateOperationsInput | EnumBoxImageStatus
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxImageUncheckedUpdateWithoutBoxInput = {
    photoUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumEnumBoxImageStatusFieldUpdateOperationsInput | EnumBoxImageStatus
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxImageUncheckedUpdateManyWithoutBoxImageInput = {
    photoUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumEnumBoxImageStatusFieldUpdateOperationsInput | EnumBoxImageStatus
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArticleUpdateWithoutBoxInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: ProviderUpdateOneWithoutArticleNestedInput
    unitySize?: UnitySizeUpdateOneWithoutArticleNestedInput
    subCategory?: SubCategoryUpdateOneWithoutArticleNestedInput
    articlePhoto?: ArticlePhotoUpdateManyWithoutArticleNestedInput
    post?: PostUpdateManyWithoutArticleNestedInput
    price?: PriceUpdateOneWithoutArticleNestedInput
    boxArticle?: BoxArticleUpdateManyWithoutArticleNestedInput
    game?: GameUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutBoxInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    unitySizeId?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    articlePhoto?: ArticlePhotoUncheckedUpdateManyWithoutArticleNestedInput
    post?: PostUncheckedUpdateManyWithoutArticleNestedInput
    price?: PriceUncheckedUpdateOneWithoutArticleNestedInput
    boxArticle?: BoxArticleUncheckedUpdateManyWithoutArticleNestedInput
    game?: GameUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateManyWithoutArticleInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    unitySizeId?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUpdateWithoutBoxInput = {
    type?: EnumEnumTypeTransactionFieldUpdateOperationsInput | EnumTypeTransaction
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumEnumStatusTransactionFieldUpdateOperationsInput | EnumStatusTransaction
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wallet?: WalletUpdateOneRequiredWithoutTransactionNestedInput
    offer?: OfferUpdateOneWithoutTransactionNestedInput
    shoppingCart?: ShoppingCartUpdateOneWithoutTransactionNestedInput
    bank?: BankUpdateOneWithoutTransactionNestedInput
    game?: GameUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutBoxInput = {
    type?: EnumEnumTypeTransactionFieldUpdateOperationsInput | EnumTypeTransaction
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumEnumStatusTransactionFieldUpdateOperationsInput | EnumStatusTransaction
    walletId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingCartId?: NullableStringFieldUpdateOperationsInput | string | null
    bankId?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserBoxUpdateWithoutBoxInput = {
    type?: EnumEnumUserBoxTypeFieldUpdateOperationsInput | EnumUserBoxType
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isPlayed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    playedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderNumber?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unlockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lot?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutUserBoxNestedInput
    game?: GameUpdateManyWithoutUserBoxNestedInput
  }

  export type UserBoxUncheckedUpdateWithoutBoxInput = {
    type?: EnumEnumUserBoxTypeFieldUpdateOperationsInput | EnumUserBoxType
    duration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dayNumber?: NullableIntFieldUpdateOperationsInput | number | null
    isPlayed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    playedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deactivationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderNumber?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unlockThreshold?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    lot?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    game?: GameUncheckedUpdateManyWithoutUserBoxNestedInput
  }

  export type BannerImageUpdateWithoutBoxInput = {
    bannerImgUrl?: StringFieldUpdateOperationsInput | string
    bannerLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumBannerImageTypeFieldUpdateOperationsInput | BannerImageType | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offer?: OfferUpdateOneWithoutBannerImageNestedInput
  }

  export type BannerImageUncheckedUpdateWithoutBoxInput = {
    bannerImgUrl?: StringFieldUpdateOperationsInput | string
    bannerLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumBannerImageTypeFieldUpdateOperationsInput | BannerImageType | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BannerImageUncheckedUpdateManyWithoutBannerImageInput = {
    bannerImgUrl?: StringFieldUpdateOperationsInput | string
    bannerLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumBannerImageTypeFieldUpdateOperationsInput | BannerImageType | null
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxArticleUpdateWithoutBoxInput = {
    winningChance?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    article?: ArticleUpdateOneRequiredWithoutBoxArticleNestedInput
  }

  export type BoxArticleUncheckedUpdateWithoutBoxInput = {
    winningChance?: FloatFieldUpdateOperationsInput | number
    articleId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxArticleUncheckedUpdateManyWithoutBoxArticleInput = {
    winningChance?: FloatFieldUpdateOperationsInput | number
    articleId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DailyRewardUpdateWithoutBoxInput = {
    number?: IntFieldUpdateOperationsInput | number
  }

  export type DailyRewardUncheckedUpdateWithoutBoxInput = {
    number?: IntFieldUpdateOperationsInput | number
  }

  export type DailyRewardUncheckedUpdateManyWithoutDailyRewardInput = {
    number?: IntFieldUpdateOperationsInput | number
  }

  export type BoxRewardLevelUpdateWithoutBoxInput = {
    rewardLevel?: RewardLevelUpdateOneRequiredWithoutBoxRewardLevelNestedInput
  }

  export type BoxRewardLevelUncheckedUpdateWithoutBoxInput = {
    rewardLevelId?: StringFieldUpdateOperationsInput | string
  }

  export type BoxRewardLevelUncheckedUpdateManyWithoutBoxRewardLevelInput = {
    rewardLevelId?: StringFieldUpdateOperationsInput | string
  }

  export type BoxRewardLevelCreateManyRewardLevelInput = {
    id?: string
    boxId: string
  }

  export type BoxRewardLevelUpdateWithoutRewardLevelInput = {
    box?: BoxUpdateOneRequiredWithoutBoxRewardLevelNestedInput
  }

  export type BoxRewardLevelUncheckedUpdateWithoutRewardLevelInput = {
    boxId?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleCreateManyProviderInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    unitySizeId?: string | null
    subCategoryId: string
    boxId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ArticleUpdateWithoutProviderInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unitySize?: UnitySizeUpdateOneWithoutArticleNestedInput
    subCategory?: SubCategoryUpdateOneWithoutArticleNestedInput
    box?: BoxUpdateOneWithoutArticleNestedInput
    articlePhoto?: ArticlePhotoUpdateManyWithoutArticleNestedInput
    post?: PostUpdateManyWithoutArticleNestedInput
    price?: PriceUpdateOneWithoutArticleNestedInput
    boxArticle?: BoxArticleUpdateManyWithoutArticleNestedInput
    game?: GameUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutProviderInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    unitySizeId?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: StringFieldUpdateOperationsInput | string
    boxId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    articlePhoto?: ArticlePhotoUncheckedUpdateManyWithoutArticleNestedInput
    post?: PostUncheckedUpdateManyWithoutArticleNestedInput
    price?: PriceUncheckedUpdateOneWithoutArticleNestedInput
    boxArticle?: BoxArticleUncheckedUpdateManyWithoutArticleNestedInput
    game?: GameUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type SubCategoryCreateManyCategoryInput = {
    id?: string
    reference: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubCategoryUpdateWithoutCategoryInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    article?: ArticleUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryUncheckedUpdateWithoutCategoryInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    article?: ArticleUncheckedUpdateManyWithoutSubCategoryNestedInput
  }

  export type SubCategoryUncheckedUpdateManyWithoutSubCategoryInput = {
    reference?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArticleCreateManySubCategoryInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    providerId?: string | null
    unitySizeId?: string | null
    boxId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ArticleUpdateWithoutSubCategoryInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: ProviderUpdateOneWithoutArticleNestedInput
    unitySize?: UnitySizeUpdateOneWithoutArticleNestedInput
    box?: BoxUpdateOneWithoutArticleNestedInput
    articlePhoto?: ArticlePhotoUpdateManyWithoutArticleNestedInput
    post?: PostUpdateManyWithoutArticleNestedInput
    price?: PriceUpdateOneWithoutArticleNestedInput
    boxArticle?: BoxArticleUpdateManyWithoutArticleNestedInput
    game?: GameUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutSubCategoryInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    unitySizeId?: NullableStringFieldUpdateOperationsInput | string | null
    boxId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    articlePhoto?: ArticlePhotoUncheckedUpdateManyWithoutArticleNestedInput
    post?: PostUncheckedUpdateManyWithoutArticleNestedInput
    price?: PriceUncheckedUpdateOneWithoutArticleNestedInput
    boxArticle?: BoxArticleUncheckedUpdateManyWithoutArticleNestedInput
    game?: GameUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleCreateManyUnitySizeInput = {
    id?: string
    reference: string
    designation: string
    type?: EnumTypeMode | null
    size?: string | null
    color?: string | null
    productUrl?: string | null
    observation?: string | null
    winningChance?: number | null
    providerId?: string | null
    subCategoryId: string
    boxId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ArticleUpdateWithoutUnitySizeInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: ProviderUpdateOneWithoutArticleNestedInput
    subCategory?: SubCategoryUpdateOneWithoutArticleNestedInput
    box?: BoxUpdateOneWithoutArticleNestedInput
    articlePhoto?: ArticlePhotoUpdateManyWithoutArticleNestedInput
    post?: PostUpdateManyWithoutArticleNestedInput
    price?: PriceUpdateOneWithoutArticleNestedInput
    boxArticle?: BoxArticleUpdateManyWithoutArticleNestedInput
    game?: GameUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutUnitySizeInput = {
    reference?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    type?: NullableEnumEnumTypeModeFieldUpdateOperationsInput | EnumTypeMode | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    productUrl?: NullableStringFieldUpdateOperationsInput | string | null
    observation?: NullableStringFieldUpdateOperationsInput | string | null
    winningChance?: NullableFloatFieldUpdateOperationsInput | number | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    subCategoryId?: StringFieldUpdateOperationsInput | string
    boxId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    articlePhoto?: ArticlePhotoUncheckedUpdateManyWithoutArticleNestedInput
    post?: PostUncheckedUpdateManyWithoutArticleNestedInput
    price?: PriceUncheckedUpdateOneWithoutArticleNestedInput
    boxArticle?: BoxArticleUncheckedUpdateManyWithoutArticleNestedInput
    game?: GameUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticlePhotoCreateManyArticleInput = {
    id?: string
    photoUrl: string
    status?: ArticlePhotoStatus | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type PostCreateManyArticleInput = {
    id?: string
    title: string
    content: string
    postUrl: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BoxArticleCreateManyArticleInput = {
    id?: string
    winningChance: number
    boxId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type GameCreateManyArticleInput = {
    id?: string
    reference: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: EnumStatusGame
    version?: EnumVersionGame | null
    type?: EnumTypeGame | null
    userBoxId?: string | null
    patronageId?: string | null
    gainPercentage?: number | null
    gainDraw?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ArticlePhotoUpdateWithoutArticleInput = {
    photoUrl?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumArticlePhotoStatusFieldUpdateOperationsInput | ArticlePhotoStatus | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArticlePhotoUncheckedUpdateWithoutArticleInput = {
    photoUrl?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumArticlePhotoStatusFieldUpdateOperationsInput | ArticlePhotoStatus | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArticlePhotoUncheckedUpdateManyWithoutArticlePhotoInput = {
    photoUrl?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumArticlePhotoStatusFieldUpdateOperationsInput | ArticlePhotoStatus | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostUpdateWithoutArticleInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostUncheckedUpdateWithoutArticleInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostUncheckedUpdateManyWithoutPostInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BoxArticleUpdateWithoutArticleInput = {
    winningChance?: FloatFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    box?: BoxUpdateOneRequiredWithoutBoxArticleNestedInput
  }

  export type BoxArticleUncheckedUpdateWithoutArticleInput = {
    winningChance?: FloatFieldUpdateOperationsInput | number
    boxId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameUpdateWithoutArticleInput = {
    reference?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEnumStatusGameFieldUpdateOperationsInput | EnumStatusGame
    version?: NullableEnumEnumVersionGameFieldUpdateOperationsInput | EnumVersionGame | null
    type?: NullableEnumEnumTypeGameFieldUpdateOperationsInput | EnumTypeGame | null
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gainDraw?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userBox?: UserBoxUpdateOneWithoutGameNestedInput
    patronage?: PatronageUpdateOneWithoutGameNestedInput
    shoppingCart?: ShoppingCartUpdateOneWithoutGameNestedInput
    transaction?: TransactionUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutArticleInput = {
    reference?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEnumStatusGameFieldUpdateOperationsInput | EnumStatusGame
    version?: NullableEnumEnumVersionGameFieldUpdateOperationsInput | EnumVersionGame | null
    type?: NullableEnumEnumTypeGameFieldUpdateOperationsInput | EnumTypeGame | null
    userBoxId?: NullableStringFieldUpdateOperationsInput | string | null
    patronageId?: NullableStringFieldUpdateOperationsInput | string | null
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gainDraw?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shoppingCart?: ShoppingCartUncheckedUpdateOneWithoutGameNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutGameNestedInput
  }

  export type TransactionCreateManyShoppingCartInput = {
    id?: string
    type: EnumTypeTransaction
    date: Date | string
    amount: number
    status: EnumStatusTransaction
    boxId?: string | null
    walletId: string
    offerId?: string | null
    bankId?: string | null
    gameId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TransactionUpdateWithoutShoppingCartInput = {
    type?: EnumEnumTypeTransactionFieldUpdateOperationsInput | EnumTypeTransaction
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumEnumStatusTransactionFieldUpdateOperationsInput | EnumStatusTransaction
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    box?: BoxUpdateOneWithoutTransactionNestedInput
    wallet?: WalletUpdateOneRequiredWithoutTransactionNestedInput
    offer?: OfferUpdateOneWithoutTransactionNestedInput
    bank?: BankUpdateOneWithoutTransactionNestedInput
    game?: GameUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutShoppingCartInput = {
    type?: EnumEnumTypeTransactionFieldUpdateOperationsInput | EnumTypeTransaction
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumEnumStatusTransactionFieldUpdateOperationsInput | EnumStatusTransaction
    boxId?: NullableStringFieldUpdateOperationsInput | string | null
    walletId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    bankId?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionCreateManyBankInput = {
    id?: string
    type: EnumTypeTransaction
    date: Date | string
    amount: number
    status: EnumStatusTransaction
    boxId?: string | null
    walletId: string
    offerId?: string | null
    shoppingCartId?: string | null
    gameId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TransactionUpdateWithoutBankInput = {
    type?: EnumEnumTypeTransactionFieldUpdateOperationsInput | EnumTypeTransaction
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumEnumStatusTransactionFieldUpdateOperationsInput | EnumStatusTransaction
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    box?: BoxUpdateOneWithoutTransactionNestedInput
    wallet?: WalletUpdateOneRequiredWithoutTransactionNestedInput
    offer?: OfferUpdateOneWithoutTransactionNestedInput
    shoppingCart?: ShoppingCartUpdateOneWithoutTransactionNestedInput
    game?: GameUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutBankInput = {
    type?: EnumEnumTypeTransactionFieldUpdateOperationsInput | EnumTypeTransaction
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumEnumStatusTransactionFieldUpdateOperationsInput | EnumStatusTransaction
    boxId?: NullableStringFieldUpdateOperationsInput | string | null
    walletId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingCartId?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameCreateManyUserBoxInput = {
    id?: string
    reference: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: EnumStatusGame
    version?: EnumVersionGame | null
    type?: EnumTypeGame | null
    patronageId?: string | null
    gainPercentage?: number | null
    gainDraw?: number | null
    articleId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type GameUpdateWithoutUserBoxInput = {
    reference?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEnumStatusGameFieldUpdateOperationsInput | EnumStatusGame
    version?: NullableEnumEnumVersionGameFieldUpdateOperationsInput | EnumVersionGame | null
    type?: NullableEnumEnumTypeGameFieldUpdateOperationsInput | EnumTypeGame | null
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gainDraw?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patronage?: PatronageUpdateOneWithoutGameNestedInput
    article?: ArticleUpdateOneWithoutGameNestedInput
    shoppingCart?: ShoppingCartUpdateOneWithoutGameNestedInput
    transaction?: TransactionUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutUserBoxInput = {
    reference?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEnumStatusGameFieldUpdateOperationsInput | EnumStatusGame
    version?: NullableEnumEnumVersionGameFieldUpdateOperationsInput | EnumVersionGame | null
    type?: NullableEnumEnumTypeGameFieldUpdateOperationsInput | EnumTypeGame | null
    patronageId?: NullableStringFieldUpdateOperationsInput | string | null
    gainPercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    gainDraw?: NullableFloatFieldUpdateOperationsInput | number | null
    articleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shoppingCart?: ShoppingCartUncheckedUpdateOneWithoutGameNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutGameNestedInput
  }

  export type ReceiverCreateManyMessageInput = {
    id?: string
    readingDate: Date | string
    receiverId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ReceiverUpdateWithoutMessageInput = {
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiver?: UserUpdateOneRequiredWithoutReceiverNestedInput
  }

  export type ReceiverUncheckedUpdateWithoutMessageInput = {
    readingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionCreateManyOfferInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    durationType?: EnumPriceSubscription | null
    status?: EnumStatusSubscription | null
    autoRenewal?: boolean
    userId: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type BannerImageCreateManyOfferInput = {
    id?: string
    bannerImgUrl: string
    bannerLink?: string | null
    type?: BannerImageType | null
    boxId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TransactionCreateManyOfferInput = {
    id?: string
    type: EnumTypeTransaction
    date: Date | string
    amount: number
    status: EnumStatusTransaction
    boxId?: string | null
    walletId: string
    shoppingCartId?: string | null
    bankId?: string | null
    gameId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type SubscriptionUpdateWithoutOfferInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationType?: NullableEnumEnumPriceSubscriptionFieldUpdateOperationsInput | EnumPriceSubscription | null
    status?: NullableEnumEnumStatusSubscriptionFieldUpdateOperationsInput | EnumStatusSubscription | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutOfferInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    durationType?: NullableEnumEnumPriceSubscriptionFieldUpdateOperationsInput | EnumPriceSubscription | null
    status?: NullableEnumEnumStatusSubscriptionFieldUpdateOperationsInput | EnumStatusSubscription | null
    autoRenewal?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BannerImageUpdateWithoutOfferInput = {
    bannerImgUrl?: StringFieldUpdateOperationsInput | string
    bannerLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumBannerImageTypeFieldUpdateOperationsInput | BannerImageType | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    box?: BoxUpdateOneWithoutBannerImageNestedInput
  }

  export type BannerImageUncheckedUpdateWithoutOfferInput = {
    bannerImgUrl?: StringFieldUpdateOperationsInput | string
    bannerLink?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableEnumBannerImageTypeFieldUpdateOperationsInput | BannerImageType | null
    boxId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUpdateWithoutOfferInput = {
    type?: EnumEnumTypeTransactionFieldUpdateOperationsInput | EnumTypeTransaction
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumEnumStatusTransactionFieldUpdateOperationsInput | EnumStatusTransaction
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    box?: BoxUpdateOneWithoutTransactionNestedInput
    wallet?: WalletUpdateOneRequiredWithoutTransactionNestedInput
    shoppingCart?: ShoppingCartUpdateOneWithoutTransactionNestedInput
    bank?: BankUpdateOneWithoutTransactionNestedInput
    game?: GameUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutOfferInput = {
    type?: EnumEnumTypeTransactionFieldUpdateOperationsInput | EnumTypeTransaction
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumEnumStatusTransactionFieldUpdateOperationsInput | EnumStatusTransaction
    boxId?: NullableStringFieldUpdateOperationsInput | string | null
    walletId?: StringFieldUpdateOperationsInput | string
    shoppingCartId?: NullableStringFieldUpdateOperationsInput | string | null
    bankId?: NullableStringFieldUpdateOperationsInput | string | null
    gameId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionCreateManyGameInput = {
    id?: string
    type: EnumTypeTransaction
    date: Date | string
    amount: number
    status: EnumStatusTransaction
    boxId?: string | null
    walletId: string
    offerId?: string | null
    shoppingCartId?: string | null
    bankId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type TransactionUpdateWithoutGameInput = {
    type?: EnumEnumTypeTransactionFieldUpdateOperationsInput | EnumTypeTransaction
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumEnumStatusTransactionFieldUpdateOperationsInput | EnumStatusTransaction
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    box?: BoxUpdateOneWithoutTransactionNestedInput
    wallet?: WalletUpdateOneRequiredWithoutTransactionNestedInput
    offer?: OfferUpdateOneWithoutTransactionNestedInput
    shoppingCart?: ShoppingCartUpdateOneWithoutTransactionNestedInput
    bank?: BankUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutGameInput = {
    type?: EnumEnumTypeTransactionFieldUpdateOperationsInput | EnumTypeTransaction
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumEnumStatusTransactionFieldUpdateOperationsInput | EnumStatusTransaction
    boxId?: NullableStringFieldUpdateOperationsInput | string | null
    walletId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingCartId?: NullableStringFieldUpdateOperationsInput | string | null
    bankId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}